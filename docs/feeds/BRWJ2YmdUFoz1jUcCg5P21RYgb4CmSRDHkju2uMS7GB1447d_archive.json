{"id":"BRWJ2YmdUFoz1jUcCg5P21RYgb4CmSRDHkju2uMS7GB1447d","title":"Mouse Vs Python","displayTitle":"Dev - Python Blog","url":"https://blog.pythonlibrary.org/feed","feedLink":"https://www.blog.pythonlibrary.org/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":3,"items":[{"title":"An Intro to ty – The Extremely Fast Python type checker","url":"https://www.blog.pythonlibrary.org/2025/06/25/an-intro-to-ty-the-extremely-fast-python-type-checker/","date":1750855546,"author":"Mike","guid":318,"unread":true,"content":"<p><a href=\"https://github.com/astral-sh/ty\">Ty is a brand new, extremely fast Python type checker</a> written in Rust from the fine folks at Astral, the makers of Ruff. Ty is in preview and is not ready for production use, but you can still try it out on your code base to see how it compares to Mypy or other popular Python type checkers.</p><p>If you prefer to install ty, you can use pip:</p><h2>Using the ty Type Checker</h2><p>Want to give ty a try? You can run it in much the same way as you would Ruff. Open up your terminal and navigate to your project’s top-level directory. Then run the following command:</p><p>If ty finds anything, you will quickly see the output in your terminal.</p><p>Astral has also provided a way to exclude files from type checking. By default, ty ignores files listed in an&nbsp;&nbsp;or&nbsp;&nbsp;file.</p><p>Ruff is a great tool and has been adopted by many teams since its release. Ty will likely follow a similar trajectory if it as fast and useful as Ruff has been. Only time will tell. However, these new developments in Python tooling are exciting and will be fun to try. If you have used ty, feel free to jump into the comments and let me know what you think.</p>","contentLength":1098,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Python 201 – All About the TypedDict","url":"https://www.blog.pythonlibrary.org/2025/06/17/python-201-all-about-the-typeddict/","date":1750166753,"author":"Mike","guid":317,"unread":true,"content":"<p>Python has supported the concept of type hinting for quite a while now. However, unlike other programming languages, Python does not enforce type hints. You must use an external tool, such as Mypy, for that.</p><p>In this tutorial, you will learn all about <a href=\"https://peps.python.org/pep-0589/\"></a>, a special way of adding type hinting to <strong>Heterogeneous dictionaries</strong>. A heterogeneous dictionary is a dictionary that has values that are not all the same type.</p><p>But before you learn how to use the TypedDict, you should review how to type hint a regular dictionary.</p><h2>Type Hinting a Regular Dictionary</h2><p>A regular Python dictionary is defined as follows:</p><pre data-enlighter-language=\"python\">my_dictionary = {\"some_key\": \"some_value\"}</pre><p>You can use any hashable type for the key, such as a string or an integer. The value of a dictionary can be any type whatsoever.</p><p>When you want to type hint a dictionary, you would use the following: <strong>dict[key_type, value_type]</strong></p><p>Now let’s apply that to the example above:</p><pre data-enlighter-language=\"python\">my_dictionary: dict[str, str]&nbsp;=&nbsp;{\"some_key\":&nbsp;\"some_value\"}</pre><p>If you are using a version of Python before 3.9, you will need to do the following instead:</p><pre data-enlighter-language=\"python\">from typing import Dict\n\nmy_dictionary: Dict[str, str] = {\"some_key\": \"some_value\"}</pre><p>Fortunately, modern Python no longer requires that extra import.</p><p>Now you’re ready to learn about how and why you might want to use the TypedDict</p><p>The TypedDict was introduced to Python in 3.8. You can read the full details about it in <a href=\"https://peps.python.org/pep-0589/\">PEP 589</a>. The reason you would use a TypedDict over a regular dictionary is when you have a dictionary with values of different types.</p><pre data-enlighter-language=\"python\">my_dictionary = {\"names\": [\"Mike\", \"Andrea\", \"John\"],\n                 \"type\": \"employee\",\n                 \"code\": 123456\n                }</pre><p>Type hinting this type of dictionary is more complex. You can do something like this, though:</p><pre data-enlighter-language=\"python\">my_dictionary: dict[str, list | str | int] = {\"names\": [\"Mike\", \"Andrea\", \"John\"], \"otype\": \"employee\", \"code\": 123456 }</pre><p>Depending on how your type checker is configured, this might work. However, if you write code that modifies the list, your type checker may complain that a string doesn’t have an append method or vice versa.</p><p>To make the type checker happier, you should use a .</p><p>Here’s how you would use one with this example:</p><pre data-enlighter-language=\"generic\">from typing import TypedDict\n\nclass MultiTypeDict(TypedDict):\n    names: list\n    otype: str\n    code: int\n\nmy_dictionary: MultiTypeDict = {\"names\": [\"Mike\", \"Andrea\", \"John\"], \"otype\": \"employee\", \"code\": 123456 }</pre><p>Isn’t that great? There’s just one problem. What if your dictionary’s keys have spaces in them? You cannot create class attributes with spaces!</p><p>There’s a workaround for that. Check it out in the next section.</p><h2>Creating a TypedDict with Keys that Have Spaces</h2><p>For this example, you will create a new dictionary with four keys, three of which contain spaces.</p><p>To make a TypedDict for this type of dictionary, you need to call the TypedDict constructor instead of subclassing it:</p><pre data-enlighter-language=\"python\">from typing import TypedDict\n\nResults = TypedDict(\"Results\",{\"Animal Habitats\": list,\n                               \"Tested\": bool,\n                               \"Animal Name\": str,\n                               \"Animal Location\": str})\n\nactual_results: Results = {\n    \"Animal Habitats\": [\"Asia\", \"N. America\"],\n    \"Tested\": False,\n    \"Animal Name\": \"Tigris\",\n    \"Animal Location\": \"North Bay\",\n}</pre><p>When you call TypedDict, you pass in the typename (what you would have named the class) and the fields the dictionary should have. You’ll note that the fields are a dictionary. This is where you will put the keys that contain spaces and those without spaces.</p><p>Give it a try and you’ll find it works great!</p><p> is a handy tool for storing a complex dictionary. You will find that sometimes you even have these complex dictionaries inside of lists, tuples or even other dictionaries. Using the TypedDict can make type-hinting these data structures easier and prevent hard-to-detect defects from creeping in.</p>","contentLength":3868,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Parsing XML Comments with Python","url":"https://www.blog.pythonlibrary.org/2025/06/05/parsing-xml-comments-with-python/","date":1749130224,"author":"Mike","guid":316,"unread":true,"content":"<p>The Extensible Markup Language (XML) is a markup format originally for XML. Some companies use XML as a data serialization format or for configuration. Recently, I needed to learn how to uncomment some lines in an XML file to enable some settings that were defined in the XML.</p><p>Fortunately, Python’s  module provides a way to do this. Let’s find out how!</p><h2>AI Answers Might Not Work</h2><p>When I used Google to search for an answer to this question: “How to edit comments in XML with Python”, Google Gemini piped up with this answer:</p><pre data-enlighter-language=\"python\">import xml.etree.ElementTree as ET\n\nxml_file = \"PATH_TO_XML\"\n\ntree = ET.parse(xml_file)\nroot = tree.getroot()\n\nfor element in root.iter():\n    if isinstance(element.tag, str) and element.tag.startswith('{'):\n        continue\n    if element.tag == ET.Comment:\n        text = element.text.strip()\n        print(text)</pre><p>Unfortunately, this code does not work. But it is close.</p><p>If you look through StackOverflow and similar forums, you will discover that you need a custom parser. Here’s how to create one:</p><pre data-enlighter-language=\"generic\">import xml.etree.ElementTree as ET\n\nxml_file = r\"PATH_TO_XML\"\n\nparser = ET.XMLParser(target=ET.TreeBuilder(insert_comments=True))\ntree = ET.parse(xml_file, parser)\nroot = tree.getroot()\n\nfor element in root.iter():\n    if isinstance(element.tag, str) and element.tag.startswith('{'):\n        continue\n\n    if element.tag == ET.Comment:\n        text = element.text.strip()        \n        print(text)</pre><p>The key point here is to create an instance of ET.XMLParser and set&nbsp; to True. Then the code will work.</p><p>Note that this example just prints out the commented text. You would need to do something like this to grab the commented text and reinsert it as a valid XML element:</p><pre data-enlighter-language=\"python\">for element in root.iter():\n   if isinstance(element.tag, str) and element.tag.startswith('{'):\n      continue\n   if element.tag == ET.Comment:\n      text = element.text.strip()\n      if \"COMMENTED CODE SUBSTRING\" in text:\n         new_element = ET.fromstring(f\"&lt;{text}&gt;\")\n         # Insert the uncommented text as a new XML element\n         root.insert(list(root).index(element), new_element)\n         # Remove the element that was commented out originally\n         root.remove(element)\n\n# Make indentation work for the output\nET.indent(tree, space=\"\\t\", level=0)\n\nwith open(XML_PATH, \"wb\") as f:\n   tree.write(f)</pre><p>Here, you loop over each element or tag in the XML. You check if the element is a comment type. If it is, you check for the substring you are looking for in the comment’s text. When you find the substring, you extract the entire string from the comment, create a new element, insert it as a regular element, and remove the comment.</p><p>XML is a handy format, and Python includes several different methods of working with XML in its  module. Several different third-party XML modules, such as lxml, are also great alternatives. If you work with XML, hopefully you will find this article helpful.</p><p>Have fun and happy coding!</p>","contentLength":2928,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","python"]}