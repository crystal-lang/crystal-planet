{"id":"4RDcb1QCVpCZpB54ijAYcT1W2","title":"Recent Discussions","displayTitle":"Recent Discussions","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":3,"items":[{"title":"Memory usage of HTTP one-shot vs maintaining a persistent connection","url":"https://forum.crystal-lang.org/t/memory-usage-of-http-one-shot-vs-maintaining-a-persistent-connection/8237","date":1752609485,"author":"jgaskins","guid":49,"unread":true,"content":"<p>I deployed <a href=\"https://zomglol.wtf/@joco_ks_weather\" rel=\"noopener nofollow ugc\">a Mastodon bot</a> a couple weeks ago that polls a US National Weather Service RSS feed for an airport in my county and posts to Mastodon when it updates. I was using the  “one-shot” methods that spin up an HTTP connection, send the request, then terminate the connection.</p><p>I expected this bot to use very little RAM (less than 10MB) because it’s  very little:</p><ol><li>Makes an HTTP request to get the RSS feed</li><li>Iterates over each feed item (there’s only one)</li><li>If it hasn’t been posted yet (tracked by a key in Redis or a record in SQLite), make an HTTP request to the Mastodon API</li></ol><p>What surprised me was that RAM consumption grew over time.</p><p>The first two lines show linear memory growth. I restarted the app and it happened again. Then I tried a few more experiments:</p><ul><li>Replace SQLite with Redis</li><li>Replace the RSS feed parser with using stdlib  directly</li><li>Remove all XML parsing and just use regexes (yes, <a href=\"https://stackoverflow.com/a/1732454\" rel=\"noopener nofollow ugc\">I know</a>, don’t worry about it)</li><li>Compile the app using  for the specific aarch64 CPUs I’m using on GCP</li><li>Cap memory usage to 20MB so it’ll just restart when it exceeds it</li><li>Use a persistent HTTP connection</li></ul><p>The first 4 didn’t do anything useful. Capping memory usage actually caused an additional problem — it caused the app to crash  persisting that it was posting to Mastodon but  actually posting.</p><p>The punchline is in the image above, but after almost 24 hours using a persistent HTTP connection (<a href=\"https://github.com/jgaskins/http_client\" rel=\"noopener nofollow ugc\">with a connection pool</a>) for both the RSS feed and the Mastodon API, memory usage has tapered at about 5MB. This is the only thing that kept RAM stable at single-digit MB.</p><p>That makes me wonder if there’s something in OpenSSL (either in the version of OpenSSL itself that’s included in <a href=\"https://github.com/toddsundsted/ktistec\" rel=\"noopener nofollow ugc\">the 84codes Alpine-based container images</a> or in the Crystal bindings for it) that’s causing it to leak memory. I’ve only ever seen this kind of memory growth in <a href=\"https://github.com/toddsundsted/ktistec\" rel=\"noopener nofollow ugc\">Ktistec</a>, which is why I thought it might be something in SQLite but it happening when running one-shot HTTP requests would also track.</p><p>Regardless of the reason, if you want to minimize memory consumption in an app that talks to other HTTP services, reusing HTTP connections will do that.</p>","contentLength":2132,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"OpenSSL::Digest store and resume","url":"https://forum.crystal-lang.org/t/openssl-digest-store-and-resume/8236","date":1752597712,"author":"dup2","guid":48,"unread":true,"content":"<p>I’m trying to implement a “resumable” SHA256 digest which can be persisted and later resumed when new data arrives, the use case is a distributed uploader where the data arrives in chunks.</p><p>For this, I’m trying to store a LibCrypto::EVP_MD_CTX_Struct somewhere (disk, redis) and then later resuming with a new Digest::SHA256 instance (or an extension of it as the initializer with a ctx is protected).</p><p>Any pointers for this? Is this even possible? (I failed so far..)</p>","contentLength":472,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Bind macro for use in web dev","url":"https://forum.crystal-lang.org/t/bind-macro-for-use-in-web-dev/8229","date":1752493677,"author":"u89012","guid":47,"unread":true,"content":"<p>I’ve the following macros (which works fine) which I’d like to enhance so it can be used to bind to form args as well – I’ve tried a bunch of variations but can’t seem to get it right, LLMs haven’t been helpful either (as they seem to produce code that iterates over the  which refuses to compile), can someone please help?</p><pre><code>macro bind(type)\n  {{type}}.from_json(context.request.body.not_nil!)\nend\n\nmacro bind(**args)\n  NamedTuple({{args.double_splat}}).from_json(context.request.body.not_nil!)\nend\n</code></pre><p>Which can be used like so:</p><pre><code>alias User = NamedTuple(email: String, password: String, remember_me: Bool?)\n#...\npayload = bind(User) #works fine for predefined types\n\n# using the second version with **args\npayload = bind(email: String, password: String, remember_me: Bool?) #works fine for one off captures too\n</code></pre><p>Assuming  exists (which merges ,  and ) how would one go about extending the above two macros so it handles both JSON and form params? I understand binding to form params can be tricky for nested structures but I’m hoping to get to a bare minimum version that can be useful.</p>","contentLength":1092,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["community"]}