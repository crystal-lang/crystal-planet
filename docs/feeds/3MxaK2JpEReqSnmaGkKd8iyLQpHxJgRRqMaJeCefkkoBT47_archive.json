{"id":"3MxaK2JpEReqSnmaGkKd8iyLQpHxJgRRqMaJeCefkkoBT47","title":"Hacker News - Newest: \"Crystal\"","displayTitle":"Hacker News - Newest: \"Crystal\"","url":"https://hnrss.org/newest?q=Crystal","feedLink":"https://news.ycombinator.com/newest","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":7,"items":[{"title":"Tether invests in Crystal Intelligence for tracing blockchain transactions","url":"https://tether.io/news/tether-announces-strategic-investment-in-crystal-intelligence-strengthening-blockchain-forensics-and-efforts-to-combat-illicit-stablecoin-activity/","date":1751992313,"author":"wslh","guid":82,"unread":true,"content":"<p>8 July 2025 – <a href=\"https://tether.io/\"></a>, the largest company in the digital asset industry, has made a strategic investment in <a href=\"https://crystalintelligence.com/\">Crystal Intelligence</a>, a leading blockchain analytics firm providing advanced risk monitoring, fraud detection, and regulatory intelligence solutions. The investment represents another component of Tether’s coordinated efforts to combat illicit stablecoin use by supporting law enforcement and building a more secure and resilient digital asset ecosystem.</p><p>In 2024, the FBI <a href=\"https://www.cnbc.com/video/2025/04/24/fbi-says-americans-lost-a-record-9point3-billion-to-crypto-crime-in-2024-cnbc-crypto-world.html\">reported more than $9.3 billion in cryptocurrency-related scam losses in the United States</a>, which was a 66% increase from the previous year. In response to the escalating threat environment, Tether has continued its leading role in voluntarily supporting law enforcement officials and investigations into criminals abusing stablecoin technology. To date, Tether has assisted more than 255 law enforcement agencies across 55 jurisdictions, including the U.S. Secret Service and FBI, and has frozen over $2.7 billion USD₮ tied to illicit activity.</p><p>This strategic investment reinforces the investigative tools used by enforcement agencies, regulators, and institutions worldwide and builds on Tether and Crystal Intelligence’s ongoing work to enhance intelligence capabilities. Notably, both organizations have supported the development of Scam Alert (<a href=\"http://scam-alert.io\">scam-alert.io</a>), a public-facing platform that flags wallet addresses associated with scams and abusive activity in real time.</p><p>“Tether is firmly committed to supporting law enforcement agencies in a shared effort to combat illicit activity,” said <strong>Paolo Ardoino, CEO of Tether</strong>. “With the latest in advanced intelligence tools, like those being developed by Crystal Intelligence, we are enhancing our ability to assist authorities in tracing the movement of funds in real time. Tether has already contributed to freezing billions in unlawful funds and has supported investigations across dozens of jurisdictions. This strategic investment will strengthen our capacity to collaborate more effectively and reinforce a clear message: USD₮ is the the digital dollar for the people, bad actors will be stopped.”</p><p>“As the crypto industry matures, so must its foundations of trust and intelligence,” said <strong>Navin Gupta, CEO of Crystal Intelligence</strong>. “Tether’s backing is both a validation of the work we’ve done together and a joint commitment to future-proofing the industry through actionable insight, integrity, and innovation. We see too many players waiting for mandates. At Crystal, we believe responsible innovation means getting ahead of threats and not just reacting to them.”</p><p>The investment in Crystal Intelligence complements Tether’s broader compliance-focused infrastructure strategy. Recent efforts include the <a href=\"https://tether.io/news/hadron-by-tether-integrates-chainalysis-sets-new-standard-for-compliant-tokenization/\">integration of institutional-grade monitoring</a> to ensure tokenized real-world assets are issued and maintained with transparency and regulatory alignment.&nbsp;</p><p>This latest initiative reflects Tether’s ongoing commitment to proactive crime prevention, global enforcement cooperation, and the responsible growth of the digital asset ecosystem.</p>","contentLength":3099,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=44501611"},{"title":"Crystal: An IVE: Integrated Vibe Environment","url":"https://github.com/stravu/crystal","date":1750388026,"author":"handfuloflight","guid":81,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=44324326"},{"title":"Calling Go from Elixir with a CNode in Crystal","url":"https://relistan.com/calling-go-from-elixir-with-a-cnode","date":1750280902,"author":"mmcclure","guid":80,"unread":true,"content":"<p>At <a href=\"https://mozi.app\">Mozi</a>, we needed to connect a new Elixir Phoenix LiveView\napp to an existing Go backend. This is how we did it.</p><p>We have a backend built in Go, which is fully-evented along the lines of the\npatterns we used at Community, described in a <a href=\"https://relistan.com/event-sourcing-and-event-bus\">previous\npost</a>. In order to support all of that, we have\nsome hefty internal libraries and existing patterns, and get a lot for free by\nbuilding on top of them.</p><p>Previously the only frontend to our application was an iOS app and that app is\n event-sourced and evented. And now <a href=\"https://github.com/patoms\">Tom\nPatterer</a> and I wanted to add a webapp to the mix,\nin order to support scenarios outside of the iOS app, either because they work\nbetter on the web, or so we can support Android and desktop browsers to limited\nextent (for now) as well. We chose Phoenix LiveView for the web frontend\nbecause it is a great fit for this kind of web app, the main backend developers\nat Mozi already know Elixir well, and the comparable Go live implementation is\nnot as robust or complete.</p><p>However, we  didn’t want to have to rewrite/duplicate a lot of the\ncode that handles events in our existing Go services, or maintain two different\nstacks. It would be great if the Elixir app could just call the Go code.</p><p>I have actually done this before and it works: you can compile the Go code into\na C ABI library and then call it from Elixir via NIFs (Native Implemented\nFunctions). If you aren’t familiar with the BEAM ecosystem (Erlang VM on which\nElixir runs), NIFs are foreign function interface glue that allows you to call\nC code from code running on the BEAM. There are some problems with this\napproach (not in order of importance):</p><ol><li><p>You have two runtimes with complex internal schedulers running in the same\nprocess, potentially competing with each other for resources.</p></li><li><p>One of the great things about the BEAM is that it is super robust and with\nOTP applications (OTP is the framework built originally to run phone\nswitches), you get a lot of fault tolerance built in. But now you have some C\ncode in the BEAM and that has to be exactly right or your Elixir app will\ncrash.</p></li><li><p>Compiles and builds become a mess because your build for your Elixir app is\neither linked against the C (Go) library, or you create an Elixir lib that\nwraps the C library. In either case you end up with a painful build somewhere.</p></li></ol><p>There are probably some other issues I haven’t mentioned. It’s not a great\nsolution.</p><p>Ports are another option. They are a sub-process running on the other end of a pipe\nthat you control from the BEAM process. This is a bit better because you have a\nseparate process and there is not a worry about two schedulers in the same process.\nHowever, the overhead is higher and you are still not fully decoupled because the\nBEAM process has to manage the running port and sub-process. This was the most\nviable option other than the one we chose, which allows even more decoupling.</p><p>The option we actually chose was to implement what is called a “C Node” in the\nErlang ecosystem. There is a library that ships with the Erlang distribution\ncalled\n<a href=\"https://www.erlang.org/doc/apps/erl_interface/ei_users_guide.html\"></a>\nthat allows you to implement a BEAM distribution node in C. What that means is\nthat you can write C code that will talk to the Elixir/Erlang application over\nthe native distribution protocol used to connect nodes together running the\nBEAM.</p><p>This is a great option because, while it does introduce more overhead than the\nNIFs, it allows you to fully decouple the codebases from each other at both\ncompile and runtime. All you need to do is write a lightweight wrapper library\nin the Elixir side that makes it easy to call the remote node using native\nElixir functions like . And on the C side you use the library to decode\nthe distribution messages and process them as needed, then call the library to\nreturn data back, or make other remote calls. If the nodes are connected,\nsending to the remote node feels just like making a normal function call from\nthe Elixir side.</p><p>What we did was build the Go code as a C ABI library. We then wrote a small C\nwrapper that processes some CLI args and environment variables, and starts\nlooping on the inbound messages. It calls the Go code as needed from the C\ncode. In this setup,  is in the C code and the Go code is initialized\nand called from there.</p><p>The way it works is that the C code starts up and calls to the Elixir app on a\nwell-known local address. This then begins distribution with the BEAM running\nthe Elixir app. You can tell on the Elixir side if the C node is connected by\ncalling . On the C side the call either succeeds or fails,\nso you can easily manage retries as needed. In our case, embracing the “let it\ncrash” philosophy, the process exits cleanly, shutting down the Go code. Then\nit is restarted by <a href=\"https://skarnet.org/software/s6-linux-init/\">S6</a> running\ninside the container. Because we use a well-known name for the C node, it’s\neasy to tell if it is connected or not.</p><p>Discovering the remote node is handled in  like this:</p><figure><pre><code data-lang=\"elixir\"></code></pre></figure><p>As the comment says, this then makes it easy to override the sidecar in tests,\nusing a a mock or stub as needed. Note that we did not implement\n and this is not necessary.</p><p>Some small number (of the 5 of you who got this far) of you may now be\nasking… but why use C, there is a Go implementation of the BEAM distribution\nprotocol? I had been watching this implementation, called\n<a href=\"https://github.com/ergo-services/ergo\">Ergo</a>, for awhile. I wrote some simple\nstuff using it. There was always a bit of an issue with making sure it\nsupported the latest OTP version. In the past I steered away from it because we\ncouldn’t realiably be sure that we would be able to upgrade Elixir and not\nsuffer issues talking to Go. As of last fall, in a major departure, that\nproject no longer supports the native distribution protocol. Instead, you must\nrun a separate implementation on the BEAM side. And it’s now a commercial\noffering. Fair enough, the developer deserves to make some money, but I am glad\nwe didn’t build anything serious on it.</p><p>Back to our C node. While I can write and maintain C code, I’m one of the few\npeople here who can. So in order to improve the maintainability of the\ncodebase, I decided to rewrite the C code in\n<a href=\"https://crystallang.org\">Crystal</a>, a strongly typed language that looks and\nfeels a lot like Ruby but is compiled to native machine code. This was not a\nmajor effort. It took some work to build the wrappers for the \nlibrary, but it wasn’t too bad. We  get this for free in C, but the\nCrystal wrappers are thin, and in the end the total line count (as a basic\nmeasure of complexity) of the Crystal code is still less than the C code. The\nresult is a three language mash-up that actually feels pretty slick and fairly\nnatural. It is certainly nicer to work on than the C code was.</p><p>To make life a little easier, we exposed some additional functions from Go to\nallow the Crystal code to log using our same Go logging setup and a few other\nbasic infrastructure bits that we then don’t have to duplicate in Crystal.\nThere is a performance penalty every time you cross the C/Go boundary, but for\nour use case, it’s not a big deal.</p><p>This is roughly what it looks like to work with the  library.\nNote that  is the Crystal module wrapping the Go functions.</p><figure><pre><code data-lang=\"crystal\"></code></pre></figure><p>It’s quite solid! We build and deploy the Crystal/Go code as a single Docker\ncontainer, running in the same Kubernetes pod as the Elixir app. They are be\nindependently built and are only coupled by the deploy-time configuration that\nspecifies which version of each to deploy in the pod.</p><p>Because both Crystal and Go are able to build easily on both macOS and Linux,\nwe can develop locally on macOS and build and deploy on Linux. It took a bit of\nfiddling to find the right distribution of Linux to build on with easy support\nfor Crystal and that Go would run on properly.</p><p>The only hard part here was a temporary issue: in the end I had to build a\ncustom build of the Go 1.24 compiler on Alpine Linux that has a patch to\nproperly support MUSL libc when starting under Cgo. Shortly this won’t be\nncessary as I did not write <a href=\"https://go-review.googlesource.com/c/go/+/610837\">this\npatch</a> myself, it was\ncontributed to the Go project but has not yet shipped.</p><p>If there is enough interest, I will work to open source the Crystal wrapper we\nwrote to  so others can use it as well. Hit me up <a href=\"https://mstdn.social/@relistan\">on\nMastodon</a> to let me know you are interested!</p>","contentLength":8168,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=44313292"},{"title":"Money Can't Buy Happiness – Or Can It? – By Crystal Jackson – An Injustice","url":"https://aninjusticemag.com/money-cant-buy-happiness-or-can-it-f956ce9fab4a","date":1750162943,"author":"rbanffy","guid":79,"unread":true,"content":"<div><h2>The next time someone says it doesn’t buy happiness, share this</h2></div><p>Every time someone says that money doesn’t buy happiness, I sort of want to take a rolled newspaper and slap them with it. This impulse is innocent enough as I don’t have newspaper on hand, and hitting someone with the newspaper on my phone would be inappropriate.</p><p>It could injure my phone.</p><p>Plus, I’m not really a violent person. I settle for a violently dramatic eye roll instead. Because money does buy happiness in its way. At least, it buys many things that support happiness. Anyone who says otherwise is living in a bubble of privilege and lacks empathy. Here are a few things that money buys that might not be happiness but definitely supports that objective:</p><p>We can say that money doesn’t buy happiness, but it can pay for healthcare. In 2022, the average U.S. citizen spent <a href=\"https://www.cms.gov/data-research/statistics-trends-and-reports/national-health-expenditure-data/historical#:~:text=U.S.%20health%20care%20spending%20grew,spending%20accounted%20for%2017.3%20percent.\" rel=\"noopener ugc nofollow\" target=\"_blank\">$13,493</a> per person on healthcare. That’s an expense many households just can’t afford. Money can allow us to afford health insurance, medication, and even preventative care. We can get the testing we need when we have concerns, and we can access our health providers for antibiotics when we’re struck by illness. Without healthcare, our quality of life suffers.</p>","contentLength":1220,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=44298257"},{"title":"Tourists damage crystal-covered chair in Italian museum by sitting on it","url":"https://www.theguardian.com/world/2025/jun/16/palazzo-maffei-verona-italian-museum-police-tourists-van-gogh-chair","date":1750097938,"author":"mykowebhn","guid":78,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=44292020"},{"title":"Multiple Claude Code Sessions in an Easy UI: Crystal","url":"https://github.com/stravu/crystal","date":1749744568,"author":"jbentley1","guid":77,"unread":true,"content":"<p>The constant waiting with Claude Code was driving my team crazy. Yes, you can have multiple sessions from the command line but it is cumbersome and confusing. Not only do you need to execute several commands to switch across, but then you forget what each session was doing and don't have easy ways to track it.</p><p>Crystal was born out of the necessity to solve this problem and help myself and our developers at Stravu be more productive. Even though it was originally just for us, we kept getting interest so I decided to open source it and share with the world.</p><p>- Run multiple Claude Code instances against the same codebase</p><p>- Each session gets its own git worktree</p><p>- Built-in git operations (rebase, squash, diff viewer)</p><p>- Build and run your application inside its worktree</p><p>Instead of an IDE, we are calling it the first IVE (Integrated Vibe Environment).</p><p>Open source and available now for macOS</p>","contentLength":889,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=44259353"},{"title":"Calling Go from Elixir with a CNode (In Crystal)","url":"https://relistan.com/calling-go-from-elixir-with-a-cnode","date":1749653804,"author":"relistan","guid":76,"unread":true,"content":"<p>At <a href=\"https://mozi.app\">Mozi</a>, we needed to connect a new Elixir Phoenix LiveView\napp to an existing Go backend. This is how we did it.</p><p>We have a backend built in Go, which is fully-evented along the lines of the\npatterns we used at Community, described in a <a href=\"https://relistan.com/event-sourcing-and-event-bus\">previous\npost</a>. In order to support all of that, we have\nsome hefty internal libraries and existing patterns, and get a lot for free by\nbuilding on top of them.</p><p>Previously the only frontend to our application was an iOS app and that app is\n event-sourced and evented. And now <a href=\"https://github.com/patoms\">Tom\nPatterer</a> and I wanted to add a webapp to the mix,\nin order to support scenarios outside of the iOS app, either because they work\nbetter on the web, or so we can support Android and desktop browsers to limited\nextent (for now) as well. We chose Phoenix LiveView for the web frontend\nbecause it is a great fit for this kind of web app, the main backend developers\nat Mozi already know Elixir well, and the comparable Go live implementation is\nnot as robust or complete.</p><p>However, we  didn’t want to have to rewrite/duplicate a lot of the\ncode that handles events in our existing Go services, or maintain two different\nstacks. It would be great if the Elixir app could just call the Go code.</p><p>I have actually done this before and it works: you can compile the Go code into\na C ABI library and then call it from Elixir via NIFs (Native Implemented\nFunctions). If you aren’t familiar with the BEAM ecosystem (Erlang VM on which\nElixir runs), NIFs are foreign function interface glue that allows you to call\nC code from code running on the BEAM. There are some problems with this\napproach (not in order of importance):</p><ol><li><p>You have two runtimes with complex internal schedulers running in the same\nprocess, potentially competing with each other for resources.</p></li><li><p>One of the great things about the BEAM is that it is super robust and with\nOTP applications (OTP is the framework built originally to run phone\nswitches), you get a lot of fault tolerance built in. But now you have some C\ncode in the BEAM and that has to be exactly right or your Elixir app will\ncrash.</p></li><li><p>Compiles and builds become a mess because your build for your Elixir app is\neither linked against the C (Go) library, or you create an Elixir lib that\nwraps the C library. In either case you end up with a painful build somewhere.</p></li></ol><p>There are probably some other issues I haven’t mentioned. It’s not a great\nsolution.</p><p>Ports are another option. They are a sub-process running on the other end of a pipe\nthat you control from the BEAM process. This is a bit better because you have a\nseparate process and there is not a worry about two schedulers in the same process.\nHowever, the overhead is higher and you are still not fully decoupled because the\nBEAM process has to manage the running port and sub-process. This was the most\nviable option other than the one we chose, which allows even more decoupling.</p><p>The option we actually chose was to implement what is called a “C Node” in the\nErlang ecosystem. There is a library that ships with the Erlang distribution\ncalled\n<a href=\"https://www.erlang.org/doc/apps/erl_interface/ei_users_guide.html\"></a>\nthat allows you to implement a BEAM distribution node in C. What that means is\nthat you can write C code that will talk to the Elixir/Erlang application over\nthe native distribution protocol used to connect nodes together running the\nBEAM.</p><p>This is a great option because, while it does introduce more overhead than the\nNIFs, it allows you to fully decouple the codebases from each other at both\ncompile and runtime. All you need to do is write a lightweight wrapper library\nin the Elixir side that makes it easy to call the remote node using native\nElixir functions like . And on the C side you use the library to decode\nthe distribution messages and process them as needed, then call the library to\nreturn data back, or make other remote calls. If the nodes are connected,\nsending to the remote node feels just like making a normal function call from\nthe Elixir side.</p><p>What we did was build the Go code as a C ABI library. We then wrote a small C\nwrapper that processes some CLI args and environment variables, and starts\nlooping on the inbound messages. It calls the Go code as needed from the C\ncode. In this setup,  is in the C code and the Go code is initialized\nand called from there.</p><p>The way it works is that the C code starts up and calls to the Elixir app on a\nwell-known local address. This then begins distribution with the BEAM running\nthe Elixir app. You can tell on the Elixir side if the C node is connected by\ncalling . On the C side the call either succeeds or fails,\nso you can easily manage retries as needed. In our case, embracing the “let it\ncrash” philosophy, the process exits cleanly, shutting down the Go code. Then\nit is restarted by <a href=\"https://skarnet.org/software/s6-linux-init/\">S6</a> running\ninside the container. Because we use a well-known name for the C node, it’s\neasy to tell if it is connected or not.</p><p>Discovering the remote node is handled in  like this:</p><figure><pre><code data-lang=\"elixir\"></code></pre></figure><p>As the comment says, this then makes it easy to override the sidecar in tests,\nusing a a mock or stub as needed. Note that we did not implement\n and this is not necessary.</p><p>Some small number (of the 5 of you who got this far) of you may now be\nasking… but why use C, there is a Go implementation of the BEAM distribution\nprotocol? I had been watching this implementation, called\n<a href=\"https://github.com/ergo-services/ergo\">Ergo</a>, for awhile. I wrote some simple\nstuff using it. There was always a bit of an issue with making sure it\nsupported the latest OTP version. In the past I steered away from it because we\ncouldn’t realiably be sure that we would be able to upgrade Elixir and not\nsuffer issues talking to Go. As of last fall, in a major departure, that\nproject no longer supports the native distribution protocol. Instead, you must\nrun a separate implementation on the BEAM side. And it’s now a commercial\noffering. Fair enough, the developer deserves to make some money, but I am glad\nwe didn’t build anything serious on it.</p><p>Back to our C node. While I can write and maintain C code, I’m one of the few\npeople here who can. So in order to improve the maintainability of the\ncodebase, I decided to rewrite the C code in\n<a href=\"https://crystallang.org\">Crystal</a>, a strongly typed language that looks and\nfeels a lot like Ruby but is compiled to native machine code. This was not a\nmajor effort. It took some work to build the wrappers for the \nlibrary, but it wasn’t too bad. We  get this for free in C, but the\nCrystal wrappers are thin, and in the end the total line count (as a basic\nmeasure of complexity) of the Crystal code is still less than the C code. The\nresult is a three language mash-up that actually feels pretty slick and fairly\nnatural. It is certainly nicer to work on than the C code was.</p><p>To make life a little easier, we exposed some additional functions from Go to\nallow the Crystal code to log using our same Go logging setup and a few other\nbasic infrastructure bits that we then don’t have to duplicate in Crystal.\nThere is a performance penalty every time you cross the C/Go boundary, but for\nour use case, it’s not a big deal.</p><p>This is roughly what it looks like to work with the  library.\nNote that  is the Crystal module wrapping the Go functions.</p><figure><pre><code data-lang=\"crystal\"></code></pre></figure><p>It’s quite solid! We build and deploy the Crystal/Go code as a single Docker\ncontainer, running in the same Kubernetes pod as the Elixir app. They are be\nindependently built and are only coupled by the deploy-time configuration that\nspecifies which version of each to deploy in the pod.</p><p>Because both Crystal and Go are able to build easily on both macOS and Linux,\nwe can develop locally on macOS and build and deploy on Linux. It took a bit of\nfiddling to find the right distribution of Linux to build on with easy support\nfor Crystal and that Go would run on properly.</p><p>The only hard part here was a temporary issue: in the end I had to build a\ncustom build of the Go 1.24 compiler on Alpine Linux that has a patch to\nproperly support MUSL libc when starting under Cgo. Shortly this won’t be\nncessary as I did not write <a href=\"https://go-review.googlesource.com/c/go/+/610837\">this\npatch</a> myself, it was\ncontributed to the Go project but has not yet shipped.</p><p>If there is enough interest, I will work to open source the Crystal wrapper we\nwrote to  so others can use it as well. Hit me up <a href=\"https://mstdn.social/@relistan\">on\nMastodon</a> to let me know you are interested!</p>","contentLength":8168,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=44248338"}],"tags":["HN","hn"]}