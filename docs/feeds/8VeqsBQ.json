{"id":"8VeqsBQ","title":"Blogs","displayTitle":"Blogs","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":4,"items":[{"title":"Embedding the Crystal Compiler in Your Program","url":"https://dev.to/kojix2/embedding-the-crystal-compiler-in-your-program-2ief","date":1754732786,"author":"kojix2","guid":78,"unread":true,"content":"<p>First, create a new Crystal project.</p><div><pre><code>crystal init app duck_egg\nduck_egg\n</code></pre></div><p>Edit the  file as follows.\nIn this example, we add  and  to the  section.</p><div><pre><code></code></pre></div><p>Create  and add the following code.</p><div><pre><code></code></pre></div><p>In this program, the Crystal compiler is embedded in the target ðŸ¥š.\nWhen ðŸ¥š is executed, a random bird is selected.<p>\nThe embedded compiler generates a binary that displays the bird and its sound.</p></p><p>First, build the program.</p><p>Next, check the  environment variable to find the location of the Crystal standard library.</p><p>The Crystal compiler requires the standard library even for very simple code such as .\nTherefore,  must be set to include the path to the standard library.</p><div><pre><code>lib:/usr/local/bin/../share/crystal/src\n</code></pre></div><p>Run the generated binary:</p><p>By using the Crystal compiler as a library, you can generate and compile code dynamically. This technique can be applied in many interesting ways.</p>","contentLength":859,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Writing SIMD in Crystal with Inline Assembly","url":"https://dev.to/kojix2/writing-simd-in-crystal-with-inline-assembly-1lkp","date":1754530110,"author":"kojix2","guid":77,"unread":true,"content":"<p>In this article, we explore how to write SIMD instructionsâ€”SSE for x86\\64 and NEON for AArch64â€”using inline assembly in the Crystal programming language.\nCrystal uses LLVM as its backend, but <a href=\"https://github.com/crystal-lang/crystal/issues/3057\" rel=\"noopener noreferrer\">it doesnâ€™t yet fully optimize with SIMD</a>.\nThis is not a performance tuning guide, but rather a fun exploration into low-level programming with Crystal.</p><p>Crystal provides the  keyword for writing inline assembly. The syntax is based on LLVM's integrated assembler.</p><div><pre><code></code></pre></div><ul><li>: LLVM-style assembly code</li><li>: Registers that will be modified</li><li>: Optional (e.g., )</li></ul><h2>\n  \n  \n  Types of SIMD Instructions\n</h2><ul><li> for Intel and AMD CPUs (x86_64)</li><li> for ARM CPUs (like Apple Silicon)</li></ul><ul><li>General-purpose: , , , , , , , , </li></ul><div><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr></tbody></table></div><h3>\n  \n  \n  Registers Used in AArch64 (NEON)\n</h3><ul><li><ul><li> = 8 Ã— 16-bit half-precision floats</li></ul></li></ul><h2>\n  \n  \n  Examples of Register Specification\n</h2><ul></ul><ul><li>LLVM assigns SSE registers automatically</li><li>NEON requires explicit register naming in inline assembly</li></ul><div><pre><code>  crystal build  llvm-ir foo.cr\n</code></pre></div><div><pre><code>  crystal build  asm foo.cr\n</code></pre></div><ul><li><p>Use of  and  for low-level memory access</p></li></ul><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><div><pre><code></code></pre></div><h2>\n  \n  \n  Examining LLVM-IR and Assembly\n</h2><p>To inspect LLVM IR output:</p><div><pre><code>crystal build your_file.cr  llvm-ir </code></pre></div><div><pre><code>crystal build your_file.cr  asm </code></pre></div><p>Youâ€™ll see that your inline  blocks are preserved as-is, even with optimizations ().</p><div><pre><code></code></pre></div><div><pre><code>Lloh2300:\n        ldr     q1, [x9, lCPI312_43@PAGEOFF]\n        add     x8, sp, #164\n        add     x9, sp, #128\n        str     q0, [sp, #128]\n        stur    q1, [x29, #-128]\n        ; InlineAsm Start\n        ld1.4s  { v0 }, [x9]\n        ld1.4s  { v1 }, [x10]\n        fadd.4s v2, v0, v1\n        st1.4s  { v2 }, [x8]\n        ; InlineAsm End\n        ldr     q0, [x25]\n        str     q0, [sp, #16]\n</code></pre></div><p>When using SIMD with parallelism, memory bandwidth can become the bottleneck.\nAlthough Crystal currently runs single-threaded by default, true parallelism is in progress, and memory limitations may become relevant in the future.</p><p>Weâ€™ve explored how to write SIMD operations in Crystal using inline , and examined how those instructions are lowered into LLVM IR and eventually into assembly.</p><p>This was a deep dive into low-level Crystal.</p><h2>\n  \n  \n  Appendix: SIMD Instruction Reference\n</h2><div><table><tbody><tr><td>Load/store 4 Ã— Float32 (unaligned)</td></tr><tr><td>Load/store 4 Ã— Float32 (aligned)</td></tr><tr><td>Load/store 4 Ã— Int32 or 8 Ã— Int16</td></tr><tr><td>Store scalar Float32 (lowest lane)</td></tr><tr></tr><tr></tr><tr><td>Horizontal add of Float32 pairs</td></tr><tr><td>Element-wise max (Float32)</td></tr><tr><td>Shuffle Float32 lanes (for reduction)</td></tr></tbody></table></div><div><table><tbody><tr><td>Load vector (e.g. , )</td></tr><tr></tr><tr><td>Pairwise add (Float32 reduction)</td></tr><tr><td>Pairwise max (Float32 reduction)</td></tr><tr><td>Vector-wide add (optional)</td></tr><tr><td>Vector-wide max (optional)</td></tr></tbody></table></div><ul><li>SSE's  and  require 16-byte alignment.</li><li>NEON's ,  reduce in two steps: 4 â†’ 2 â†’ 1.</li><li> is used with masks like ,  for reordering lanes during reduction.</li><li>Saturated arithmetic (, ) clamps values on overflow.</li></ul><p>Thanks for reading â€” and happy crystaling! ðŸ’Ž</p>","contentLength":2706,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Building Portable Crystal Binaries on macOS with GitHub Actions","url":"https://dev.to/kojix2/how-to-distribute-a-statically-linked-crystal-binary-on-macos-with-github-actions-1gc6","date":1753065259,"author":"kojix2","guid":76,"unread":true,"content":"<p>If youâ€™ve ever tried to share a <a href=\"https://github.com/crystal-lang/crystal\" rel=\"noopener noreferrer\">Crystal</a> tool you built, you may have noticed that distributing it on macOS isnâ€™t as straightforward as on Linux. On Linux, you can just use the <a href=\"https://crystal-lang.org/reference/1.17/guides/static_linking.html#musl-libc\" rel=\"noopener noreferrer\">official Docker image with musl</a> to build fully static binaries.</p><p>But macOS is different. Its design <a href=\"https://crystal-lang.org/reference/1.17/guides/static_linking.html#macos\" rel=\"noopener noreferrer\">doesnâ€™t allow fully static linking</a>, soâ€”just like with Rust or Goâ€”you end up with binaries that must dynamically link to system libraries. These are what we call .</p><p>By default, Crystal binaries on macOS depend on Homebrew libraries like , , and . Thatâ€™s not really portable. In this post, Iâ€™ll show you how to avoid those dependencies and build more portable binaries for macOS using GitHub Actions.</p><h2>\n  \n  \n  How Crystal Resolves Libraries\n</h2><p>Crystal looks for libraries in this order:</p><ol><li> environment variable</li><li> from the  annotation</li></ol><ul><li>Tries the specified  name</li><li>Falls back to the library name</li><li>Only if both fail does it use a plain  flag</li></ul><p>Hereâ€™s the catch: even if you pass static libraries via , pkg-config runs first. If it succeeds, it usually chooses shared librariesâ€”and ignores the static ones you gave.</p><p>One way around pkg-config is to symlink the static libraries and link them directly:</p><div><pre><code></code></pre></div><h3>\n  \n  \n  Method 2: Disable PKG_CONFIG_PATH\n</h3><p>Another trick is to simply disable pkg-config so it canâ€™t interfere:</p><div><pre><code></code></pre></div><p>Combining both methods is the most reliable -- especially for libraries like  and .</p><ul><li>The  runner gives you an Apple Silicon (Arm) binary</li><li>For Intel builds, use the  runner</li></ul><h2>\n  \n  \n  Alternative: Homebrew Tap\n</h2><p>If you want the easiest experience for users, publishing a Homebrew tap is the way to go. That way, they can build your tool from source and let Homebrew handle dependencies.</p><p>Still, prebuilt binaries are handy. With the approaches above, you can distribute Crystal binaries on macOS much like you would with Rust.</p><p>Thatâ€™s it for today. How about sharing the Crystal tool you built over the weekend?</p>","contentLength":1876,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"A FIRST CLASS RECOVERY HACKER THAT IS TRUSTWORTHY AND RELIABLE. THE HACK ANGELS","url":"https://dev.to/jay_williams_fb26412ca75d/a-first-class-recovery-hacker-that-is-trustworthy-and-reliable-the-hack-angels-34fh","date":1751653543,"author":"Jay Williams","guid":75,"unread":true,"content":"<p>I suffered in the hands of scammers losing my crypto assets worth $380,000 to a binary option site online with so much debt on me. I seriously needed the help of a legitimate hacking firm to assist in my case. I went searching for a hacker through the Internet seeking for a possible solution to my predicament and I saw comments about THE HACK ANGELS RECOVERY EXPERT. I had to trust the reviews and contacted them to inquire about their recovery services and what it takes to hire them, they laid down their working terms and conditions which I accepted before they commenced with the recovery. I canâ€™t thank THE HACK ANGELS RECOVERY EXPERT enough for retrieving back my funds from these heartless scammers,</p><p>My sincere gratitude goes to the woman who commented on how she used THE HACK ANGELS RECOVERY EXPERT to recover her Bitcoin and return it to her wallet. If you ever find yourself in a similar predicament, I highly recommend reaching out to THE HACK ANGELS RECOVERY EXPERT. They are truly a Godsend, and their services can make a significant difference. Thank you once again, THE HACK ANGELS RECOVERY EXPERT, for restoring my lost funds. Get in touch with the team through the info below.</p><p>WhatsApp +1(520)2 0 0-2 3 2 0</p><p>If you're in London, you can even visit them in person at their office located at 45-46 Red Lion Street, London WC1R 4PF, UK. Donâ€™t hesitate to reach out if you need help!</p>","contentLength":1399,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["blog"]}