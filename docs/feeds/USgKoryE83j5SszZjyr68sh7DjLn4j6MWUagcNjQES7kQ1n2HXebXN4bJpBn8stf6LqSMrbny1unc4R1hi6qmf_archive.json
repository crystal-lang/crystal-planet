{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Command Pattern as an API Architecture Style","url":"https://ymz-ncnk.medium.com/command-pattern-as-an-api-architecture-style-be9ac25d6d94","date":1750938487,"author":"/u/ymz-ncnk","guid":312,"unread":true,"content":"<p>Would you like a fast and flexible interaction with your API? To achieve this goal, it is necessary to:</p><ol><li>Decide on the API architectural style.</li><li>Choose the serialization format.</li><li>Use efficient implementations of both.</li></ol><p>It’s always better to solve a general problem by breaking it down into smaller parts, so let’s take a closer look at each.</p><p>We already have numerous API architectural styles, such as REST, RPC, and SOAP, to name a few. I would like to add our old friend to them — the <a href=\"https://en.wikipedia.org/wiki/Command_pattern\" rel=\"noopener ugc nofollow\" target=\"_blank\">Command Pattern</a>, or more precisely, the Command Pattern over the network. Offering the following advantages, it can be a good candidate for this role:</p><ul><li>Provides a way to model transactions. Commands share a common interface and can perform multiple actions at a time, making them ideal for this purpose.</li><li>Allows to save user actions as a list of Commands, which can be useful for logging user activities, replaying operations, or implementing auditing mechanisms.</li><li>Provides Undo/Redo functionality.</li><li>Follows the open/closed principle. New Commands can be added easily without modifying existing code.</li><li>Enhances testability, as Commands can be tested in isolation.</li></ul><p>Let’s compare it with RPC.</p><p>Why RPC? Because they are similar — both approaches involve performing an arbitrary action on the server.</p><p>The most obvious difference is that the Command Pattern operates with Commands, whereas RPC relies on functions.</p><p><strong>II. Similar Representation</strong></p><p>Despite that, they look the same when transmitted over the network:</p><pre></pre><p>That’s quite unexpected, isn’t it?</p><p><strong>III. Number of Actions at a Time</strong></p><p>Unlike the Command Pattern, RPC can perform only one action at a time, which is not very convenient. Let’s look at the following function composition:</p><p>RPC suggests to make two requests or have a function like , to reduce the number of round trips. The latter option, by the way, is not ideal. The desire to get rid of latency problems will affect the communication interface — it will become more broad and complex. This is, actually, what the guys from <a href=\"https://capnproto.org\" rel=\"noopener ugc nofollow\" target=\"_blank\">Cap’n Proto</a> say. Offering own <a href=\"https://capnproto.org/rpc.html\" rel=\"noopener ugc nofollow\" target=\"_blank\">solution</a> they describe this problem in more detail.</p><p>On the other hand, function composition is not an issue for the Command Pattern:</p><pre></pre><p>In general it allows to perform an unlimited number of actions with a single request, without adding interface complexity or compromising performance.</p><p><strong>IV. Commands Inside Functions</strong></p><p>RPC can actually be implemented using the Command Pattern. In this case, functions can simply send Commands to the server:</p><pre></pre><p>Thus, all we need to know is how to deal with Commands. This knowledge is more versatile and allows to improve even existing RPC systems.</p><h2><strong>Command Pattern Challenges</strong></h2><p>While offering a more flexible and general abstraction, the Command Pattern also introduces some challenges:</p><ul><li>Server should somehow distinguish one Command from another. : Before each Command, send its type.</li><li>Commands must return results, and each Command can have its own. : Instead of returning, the Command itself can be responsible for sending one or more results back.</li></ul><pre></pre><ul><li>During execution, a Command may encounter an error. How should it be handled? : If we want the client to know about this error, the Command can send it back as a result. In another case, the Command can terminate the connection with the client, returning an error to the Invoker.</li></ul><pre></pre><ul><li>To limit its execution time, the Command must know when it was received by the server. This time may differ from the start of execution. : The Command can receive it as a parameter.</li></ul><pre></pre><p>That’s how the Command Pattern, adapted to our needs, might look. To see it in action, we need to consider one more thing.</p><p>To send data somewhere, it must first be converted into a sequence of bytes. This can be done in various ways, which is why so many serialization formats exist. One of the most important metrics to consider is the number of bytes used by the format. The fewer bytes we need to transfer over the network, the faster our application will be.</p><p>The MUS format was created with these thoughts in mind. It uses almost no metadata and is actually a fairly simple format. I don’t want to repeat myself a lot, so here’s a <a href=\"https://medium.com/@ymz-ncnk/mus-serialization-format-21d7be309e8d\" rel=\"noopener\">link</a> where you can read more about it.</p><p>And that’s all for the theory.</p><p>The ideas described above have already been implemented for Go in the form of two libraries:  and .</p><p><a href=\"https://github.com/cmd-stream/cmd-stream-go\" rel=\"noopener ugc nofollow\" target=\"_blank\">cmd-stream-go</a> is a high-performance client-server library that implements the Command Pattern and:</p><ul><li>Can work over TCP, TLS or mutual TLS.</li><li>Has an asynchronous client, that uses only one connection for both sending Commands and receiving Results.</li><li>Supports the server streaming, i.e. a Command can send back multiple Results.</li><li>Provides reconnect and keepalive features.</li><li>Supports the Circuit Breaker pattern.</li><li>Has OpenTelemetry integration.</li><li>Can work with various serialization formats.</li><li>Has a modular architecture.</li></ul><p><a href=\"https://github.com/mus-format/mus-go\" rel=\"noopener ugc nofollow\" target=\"_blank\">mus-go</a> is a MUS format serializer, it:</p><ul><li>Represents a set of serialization primitives that can be used to implement not only MUS but also other serialization formats.</li><li>Can run on both 32 and 64-bit systems.</li><li>Can validate and skip data while unmarshalling.</li><li>Can serialize data structures such as graphs or linked lists.</li><li>Supports data versioning.</li><li>Supports out-of-order deserialization.</li><li>Supports zero allocation deserialization.</li></ul><p>In addition, as you can see in the <a href=\"https://github.com/ymz-ncnk/go-serialization-benchmarks\" rel=\"noopener ugc nofollow\" target=\"_blank\">benchmarks</a>, it demonstrates excellent performance:</p><pre></pre><ul><li>NS/OP — Nanoseconds per operation.</li><li>B/SIZE — Number of bytes used to encode the data.</li><li>B/OP — Number of bytes allocated per operation.</li><li>ALLOCS/OP — Number of allocations per operation.</li></ul><p>Among these <a href=\"https://github.com/cmd-stream/cmd-stream-examples-go\" rel=\"noopener ugc nofollow\" target=\"_blank\">examples</a>, you can find <a href=\"https://github.com/cmd-stream/cmd-stream-examples-go/tree/main/rpc\" rel=\"noopener ugc nofollow\" target=\"_blank\">one</a> where  is used as a communication tool for the RPC approach. As for <a href=\"https://github.com/ymz-ncnk/go-client-server-benchmarks\" rel=\"noopener ugc nofollow\" target=\"_blank\">benchmarks</a>,  is about 3 times faster than :</p><p>Sending Commands is a pretty good abstraction. It’s similar to RPC, but doesn’t limit us to just one action. Moreover, the Command Pattern can either replace RPC or be used as a tool for building it. Also it offers several advantages mentioned above and already has the high-performance implementation. All of this makes the Command Pattern a great choice for an API architectural style.</p><p><a rel=\"noopener\" href=\"https://ymz-ncnk.medium.com/command-pattern-as-an-api-architecture-style-part-ii-beeae1da0594\" data-discover=\"true\">Command Pattern Over the Network →</a></p>","contentLength":6026,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1lky2ps/command_pattern_as_an_api_architecture_style/"},{"title":"My Journey from Java to Go: Why I Think Go's Packages Are Actually Better","url":"https://www.reddit.com/r/golang/comments/1lkvjpi/my_journey_from_java_to_go_why_i_think_gos/","date":1750929424,"author":"/u/hosmanagic","guid":314,"unread":true,"content":"<p>When I was going through <em>The Go Programming Language</em> (Kernighan et al.), I thought I’d just skim the chapter on packages. In Java, at least, it's a relatively unremarkable topic—something you don’t spend much time thinking about.</p><p>But Go is different. Interestingly, Go packages made me think more deeply about code organization than Java packages ever did.</p><p>The more I reflected on Go packages—especially while writing this article—the more they made sense. And to be honest, I think Java should reconsider some of its package conventions, as they might be one of the reasons for its \"notorious\" verbosity.</p>","contentLength":613,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Run web compatible Half-Life or Counter Strike 1.6 dedicated server using xash3d-fwgs and go pion","url":"https://www.reddit.com/r/golang/comments/1lktz9l/run_web_compatible_halflife_or_counter_strike_16/","date":1750923128,"author":"/u/yohimik","guid":313,"unread":true,"content":"<p>Hey there Recently I made a cgo wrapper for xash3d-fwgs engine which runs hl and cs<p> Furthermore, I added a webrtc example to demonstrate how to connect to the server from the web</p> why go?<p> go has backend session based engines like nakama, so it's easy to run something like cs2 using just cs1.6 and go</p><a href=\"https://github.com/yohimik/goxash3d-fwgs\">https://github.com/yohimik/goxash3d-fwgs</a></p>","contentLength":339,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How Do You Handle Orphaned Processes?","url":"https://www.reddit.com/r/golang/comments/1lknghk/how_do_you_handle_orphaned_processes/","date":1750901224,"author":"/u/Hamguy1234","guid":310,"unread":true,"content":"<p>For a little bit of context, I'm currently writing a library to assist in the creation of a chess GUI. This library implements the UCI chess protocol, and as part of that it will be necessary to run a variety of uci compatible chess engines.</p><p>The straightforward approach is to use , and then if the engine begins to misbehave call . The obvious issue with this is that child processes are not killed and in the case of a chess engine these child processes could run for a very long time while taking a lot of cpu. To me it seems like it comes down to two options, but if Go has something more graceful than either of these I would love to know.</p><ul><li>Ignore child processes and hope they terminate promptly, (this seems to put too much faith in the assumption that other programmers will prevent orphaned processes from running for too long.)</li><li>Create OS dependent code for killing a program (such as posix process groups).</li></ul><p>The second option seems to be the most correct, but it is more work on my side, and it forces me to say my library is only supported on certain platforms. </p>","contentLength":1067,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Wails goroutine question","url":"https://www.reddit.com/r/golang/comments/1lkjzr3/wails_goroutine_question/","date":1750891602,"author":"/u/New_Okra5546","guid":311,"unread":true,"content":"<p><code>Wails is a lightweight and fast Electron/Tauri alternative for Go, and uses WebKit2</code></p><p><code>What makes Wails special is the following:</code></p><ul><li><code>Bind your Go code to the frontend so it can be called from JavaScript</code></li></ul><p>Now if you created lets say a new Wails + React project. It has a bound go method Greet, which you can call via JavaScript. I noticed, that the go methods like Greet are by default executed on another goroutine id. So I don't have to add goroutines myself. Of course, I don't want to hang my app while e.g. an api call is underway.</p><p>I've searched for \"go \" and \"go func\", but didn't see it. Thanks</p><p>Edit 1: In the frontend, this calls the bound go method:</p><p><code>window.WailsInvoke('C' + JSON.stringify(payload));</code></p><p>Then in the go side I think this receives the message, which starts with 'C' if not obfuscated:</p><p>and on Line 45 <code>registeredMethod.Call(args)</code></p><p>and on Line 72 , but I didn't see a go keyword yet, so I am still wondering where it goes into a different goroutine id to not block id 1. The go library 'reflect' is involved, but AI says \"The Go  package itself does not provide any functionality to run methods in a different goroutine \"secretly\" or automatically.\"</p><p>Am I wrong and I have to implement a goroutine myself in each bound go method to not block the wails app, that runs on id 1?</p>","contentLength":1273,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"What are your must have Go packages?","url":"https://www.reddit.com/r/golang/comments/1lkioqb/what_are_your_must_have_go_packages/","date":1750888287,"author":"/u/fenugurod","guid":315,"unread":true,"content":"<div><p>I've been using for many years and I tend to use the same stack all the time because it works and I know the packages well enough, but I'm wondering if there is anything new that it's worth exploring.</p><p>This is a very open question so feel free to answer whatever you want. For example this is what I need for my Go services:</p><ul><li>Tests: testify and testcontainers</li></ul></div>   submitted by   <a href=\"https://www.reddit.com/user/fenugurod\"> /u/fenugurod </a>","contentLength":387,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","go"]}