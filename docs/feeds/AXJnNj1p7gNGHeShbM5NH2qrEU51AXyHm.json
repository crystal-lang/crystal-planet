{"id":"AXJnNj1p7gNGHeShbM5NH2qrEU51AXyHm","title":"Julia Evans","displayTitle":"Dev - Julia Evans","url":"https://jvns.ca/atom.xml","feedLink":"https://jvns.ca/atom.xml","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":1,"items":[{"title":"Using `make` to compile C programs (for non-C-programmers)","url":"https://jvns.ca/blog/2025/06/10/how-to-compile-a-c-program/","date":1749513600,"author":"Julia Evans","guid":16,"unread":true,"content":"<p>I have never been a C programmer but every so often I need to compile a C/C++\nprogram from source. This has been kind of a struggle for me: for a\nlong time, my approach was basically “install the dependencies, run , if\nit doesn’t work, either try to find a binary someone has compiled or give up”.</p><p>“Hope someone else has compiled it” worked pretty well when I was running Linux\nbut since I’ve been using a Mac for the last couple of years I’ve been running\ninto more situations where I have to actually compile programs myself.</p><p>So let’s talk about what you might have to do to compile a C program! I’ll use\na couple of examples of specific C programs I’ve compiled and talk about a few\nthings that can go wrong. Here are three programs we’ll be talking about\ncompiling:</p><ul><li><a href=\"https://git.causal.agency/src/tree/bin/qf.c\">qf</a> (a pager you can run to quickly open files from a search with )</li></ul><p>This is pretty simple: on an Ubuntu system if I don’t already have a C compiler I’ll install one with:</p><pre><code>sudo apt-get install build-essential\n</code></pre><p>This installs , , and . The situation on a Mac is more\nconfusing but it’s something like “install xcode command line tools”.</p><h3>step 2: install the program’s dependencies</h3><p>Unlike some newer programming languages, C doesn’t have a dependency manager.\nSo if a program has any dependencies, you need to hunt them down yourself.\nThankfully because of this, C programmers usually keep their dependencies very\nminimal and often the dependencies will be available in whatever package manager you’re using.</p><p>There’s almost always a section explaining how to get the dependencies in the\nREADME, for example in <a href=\"https://mj.ucw.cz/sw/paperjam/\">paperjam</a>’s README, it\nsays:</p><blockquote><p>To compile PaperJam, you need the headers for the libqpdf and libpaper libraries (usually available as libqpdf-dev and libpaper-dev packages).</p></blockquote><blockquote><p>You may need  (found in <a href=\"http://www.methods.co.nz/asciidoc/a2x.1.html\">AsciiDoc</a>) for building manual pages.</p></blockquote><p>So on a Debian-based system you can install the dependencies like this.</p><pre><code>sudo apt install -y libqpdf-dev libpaper-dev\n</code></pre><p>If a README gives a name for a package (like ), I’d basically\nalways assume that they mean “in a Debian-based Linux distro”: if you’re on a\nMac  will not work. I still have not 100% gotten\nthe hang of developing on a Mac yet so I don’t have many tips there yet. I\nguess in this case it would be  if you’re using Homebrew.</p><h3>step 3: run  (if needed)</h3><p>Some C programs come with a  and some instead come with a script called\n. For example, if you download <a href=\"https://www.sqlite.org/download.html\">sqlite’s source code</a>, it has a  script in\nit instead of a Makefile.</p><p>My understanding of this  script is:</p><ol><li>You run it, it prints out a lot of somewhat inscrutable output, and then it\neither generates a  or fails because you’re missing some\ndependency</li><li>The  script is part of a system called\n<a href=\"https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html\">autotools</a>\nthat I have never needed to learn anything about beyond “run it to generate\na ”.</li></ol><p>I think there might be some options you can pass to get the \nscript to produce a different  but I have never done that.</p><p>The next step is to run  to try to build a program. Some notes about\n:</p><ul><li>Sometimes you can run  to parallelize the build and make it go\nfaster</li><li>It usually prints out a million compiler warnings when compiling the program.\nI always just ignore them. I didn’t write the software! The compiler warnings\nare not my problem.</li></ul><p>Here’s an error I got while compiling  on my Mac:</p><pre><code>/opt/homebrew/Cellar/qpdf/12.0.0/include/qpdf/InputSource.hh:85:19: error: function definition does not declare parameters\n   85 |     qpdf_offset_t last_offset{0};\n      |                   ^\n</code></pre><p>Over the years I’ve learned it’s usually best not to overthink problems like\nthis: if it’s talking about , there’s a good change it just means that\nI’ve done something wrong with how I’m including the  dependency.</p><p>Now let’s talk about some ways to get the  dependency included in the right way.</p><p>Before we talk about how to fix dependency problems: building C programs is split into 2\nsteps:</p><ol><li> the code into  (with  or )</li><li> those object files into a final binary (with )</li></ol><p>It’s important to know this when building a C program because sometimes you\nneed to pass the right flags to the compiler and linker to tell them where to\nfind the dependencies for the program you’re compiling.</p><p>If I run  on my Mac to install , I get this error:</p><pre><code>c++ -o paperjam paperjam.o pdf-tools.o parse.o cmds.o pdf.o -lqpdf -lpaper\nld: library 'qpdf' not found\n</code></pre><p>This is not because  is not installed on my system (it actually is!). But\nthe compiler and linker don’t know how to  the  library. To fix this, we need to:</p><ul><li>pass <code>\"-I/opt/homebrew/include\"</code> to the compiler (to tell it where to find the header files)</li><li>pass <code>\"-L/opt/homebrew/lib -liconv\"</code> to the linker (to tell it where to find library files and to link in )</li></ul><p>And we can get  to pass those extra parameters to the compiler and linker using environment variables!\nTo see how this works: inside ’s Makefile you can see a bunch of environment variables, like  here:</p><pre><code>paperjam: $(OBJS)\n\t$(LD) -o $@ $^ $(LDLIBS)\n</code></pre><p>Everything you put into the  environment variable gets passed to the\nlinker () as a command line argument.</p><h3>secret environment variable: </h3><p> sometimes define their own environment variables that they pass to\nthe compiler/linker, but  also has a bunch of “implicit” environment\nvariables which it will automatically pass to the C compiler and linker. There’s a <a href=\"https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html#index-CFLAGS0\">full list of implicit environment variables here</a>,\nbut one of them is , which gets automatically passed to the C compiler.</p><p>(technically it would be more normal to use  for this, but this\nparticular  hardcodes  so setting  was the only\nway I could find to set the compiler flags without editing the )</p><small>\nAs an aside: it took me a long time to realize how closely tied to C/C++ `make` is -- I used\nto think that `make` was just a general build system (and of course you can use it for\nanything!) but it has a lot of affordances for building C/C++ programs that it\ndoesn't have for building any other kind of program.\n</small><h3>two ways to pass environment variables to </h3><p>I learned thanks to <a href=\"https://www.owlfolio.org/\">@zwol</a> that there are actually two ways to pass environment variables to :</p><ol><li> (the usual way)</li></ol><p>The difference between them is that  will override the\nvalue of  set in the  but  won’t.</p><p>I’m not sure which way is the norm but I’m going to use the first way in this\npost.</p><p>Now that we’ve talked about how  and  get passed to the\ncompiler and linker, here’s the final incantation that I used to get the\nprogram to build successfully!</p><pre><code>CPPFLAGS=\"-I/opt/homebrew/include\" LDLIBS=\"-L/opt/homebrew/lib -liconv\" make paperjam\n</code></pre><p>This passes  to the compiler and <code>-L/opt/homebrew/lib -liconv</code> to the linker.</p><p>Also I don’t want to pretend that I “magically” knew that those were the right\narguments to pass, figuring them out involved a bunch of confused Googling that I\nskipped over in this post. I will say that:</p><ul><li>the  compiler flag tells the compiler which directory to find header files in, like <code>/opt/homebrew/include/qpdf/QPDF.hh</code></li><li>the  linker flag tells the linker which directory to find libraries in, like <code>/opt/homebrew/lib/libqpdf.a</code></li><li>the  linker flag tells the linker which libraries to link in, like  means “link in the  library”, or  means “link ”</li></ul><h3>tip: how to just build 1 specific file: </h3><p>Yesterday I discovered this cool tool called\n<a href=\"https://git.causal.agency/src/tree/bin/qf.c\">qf</a> which you can use to quickly\nopen files from the output of .</p><p> is in a big directory of various tools, but I only wanted to compile .\nSo I just compiled , like this:</p><p>Basically if you know (or can guess) the output filename of the file you’re\ntrying to build, you can tell  to just build that file by running </p><h3>tip: you don’t need a Makefile</h3><p>I sometimes write 5-line C programs with no dependencies, and I just learned\nthat if I have a file called , I can just compile it like this without creating a :</p><p>It gets automaticaly expanded to , which saves a bit of\ntyping. I have no idea if I’m going to remember this (I might just keep typing\n anyway) but it seems like a fun trick.</p><h3>tip: look at how other packaging systems built the same C program</h3><p>If you’re having trouble building a C program, maybe other people had problems building it\ntoo! Every Linux distribution has build files for every package that they\nbuild, so even if you can’t install packages from that distribution directly,\nmaybe you can get tips from that Linux distro for how to build the package.\nRealizing this (thanks to my friend Dave) was a huge ah-ha moment for me.</p><pre><code>  env.NIX_LDFLAGS = lib.optionalString stdenv.hostPlatform.isDarwin \"-liconv\";\n</code></pre><p>This is basically saying “pass the linker flag  to build this on a\nMac”, so that’s a clue we could use to build it.</p><p>That same file also says <code>  env.NIX_CFLAGS_COMPILE = \"-DPOINTERHOLDER_TRANSITION=1\";</code>. I’m not sure what this means, but when I try\nto build the  package I do get an error about something called a\n, so I guess that’s somehow related to the “PointerHolder\ntransition”.</p><h3>step 5: installing the binary</h3><p>Once you’ve managed to compile the program, probably you want to install it somewhere!\nSome s have an  target that let you install the tool on your\nsystem with . I’m always a bit scared of this (where is it going\nto put the files? what if I want to uninstall them later?), so if I’m compiling\na pretty simple program I’ll often just manually copy the binary to install it\ninstead, like this:</p><h3>step 6: maybe make your own package!</h3><p>Once I figured out how to do all of this, I realized that I could use my new\n knowledge to contribute a  package to Homebrew! Then I could\njust  on future systems.</p><p>The good thing is that even if the details of how all of the different\npackaging systems, they fundamentally all use C compilers and linkers.</p><h3>it can be useful to understand a little about C even if you’re not a C programmer</h3><p>I think all of this is an interesting example of how it can useful to\nunderstand some basics of how C programs work (like “they have header files”)\neven if you’re never planning to write a nontrivial C program if your life.</p><p>It feels good to have some ability to compile C/C++ programs myself, even\nthough I’m still not totally confident about all of the compiler and linker\nflags and I still plan to never learn anything about how autotools works other\nthan “you run  to generate the ”.</p><p>Two things I left out of this post:</p><ul><li><code>LD_LIBRARY_PATH / DYLD_LIBRARY_PATH</code> (which you use to tell the dynamic\nlinker at runtime where to find dynamically linked files) because I can’t\nremember the last time I ran into an  issue and couldn’t\nfind an example.</li><li>, which I think is important but I don’t understand yet</li></ul>","contentLength":10454,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}