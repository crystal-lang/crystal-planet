{"id":"82kPqoBYiySD8ih7nAXkFuDhjyLjtPi8jr6gSpxV4VMW","title":"The Go Blog","displayTitle":"Dev - Golang Blog","url":"http://blog.golang.org/feed.atom","feedLink":"http://blog.golang.org/feed.atom","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":1,"items":[{"title":"[ On | No ] syntactic support for error handling","url":"https://go.dev/blog/error-syntax","date":1748908800,"author":"Robert Griesemer","guid":195,"unread":true,"content":"<p>\n      Robert Griesemer\n      3 June 2025\n      </p><p>One of the oldest and most persistent complaints about Go concerns the verbosity of error handling.\nWe are all intimately (some may say painfully) familiar with this code pattern:</p><pre><code>x, err := call()\nif err != nil {\n        // handle err\n}\n</code></pre><p>The test  can be so pervasive that it drowns out the rest of the code.\nThis typically happens in programs that do a lot of API calls, and where handling errors\nis rudimentary and they are simply returned.\nSome programs end up with code that looks like this:</p><pre><code>func printSum(a, b string) error {\n    x, err := strconv.Atoi(a)\n    if err != nil {\n        return err\n    }\n    y, err := strconv.Atoi(b)\n    if err != nil {\n        return err\n    }\n    fmt.Println(\"result:\", x + y)\n    return nil\n}\n</code></pre><p>Of the ten lines of code in this function body, only four (the calls and the last two lines) appear to do real work.\nThe remaining six lines come across as noise.\nThe verbosity is real, and so it’s no wonder that complaints about error handling have topped\nour annual user surveys for years.\n(For a while, the lack of generics surpassed complaints about error handling, but now that\nGo supports generics, error handling is back on top.)</p><p>The Go team takes community feedback seriously, and so for many years now we have tried to\ncome up with a solution for this problem, together with input from the Go community.</p><p>The first explicit attempt by the Go team dates back to 2018, when Russ Cox\n<a href=\"https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md\" rel=\"noreferrer\" target=\"_blank\">formally described the problem</a>\nas part of what we called the Go 2 effort at that time.\nHe outlined a possible solution based on a\n<a href=\"https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling.md\" rel=\"noreferrer\" target=\"_blank\">draft design</a>\nby Marcel van Lohuizen.\nThe design was based on a  and  mechanism and was fairly comprehensive.\nThe draft includes a detailed analysis of alternative solutions, including comparisons with\napproaches taken by other languages.\nIf you’re wondering if your particular error handling idea was previously considered,\nread this document!</p><pre><code>// printSum implementation using the proposed check/handle mechanism.\nfunc printSum(a, b string) error {\n    handle err { return err }\n    x := check strconv.Atoi(a)\n    y := check strconv.Atoi(b)\n    fmt.Println(\"result:\", x + y)\n    return nil\n}\n</code></pre><p>The  and  approach was deemed too complicated and almost a year later, in 2019,\nwe followed up with the much simplified and by now\n<a href=\"https://go.dev/issue/32437#issuecomment-2278932700\">infamous</a><a href=\"https://go.googlesource.com/proposal/+/master/design/32437-try-builtin.md\" rel=\"noreferrer\" target=\"_blank\"> proposal</a>.\nIt was based on the ideas of  and , but the  pseudo-keyword became\nthe  built-in function and the  part was omitted.\nTo explore the impact of the  built-in, we wrote a simple tool\n(<a href=\"https://github.com/griesemer/tryhard\" rel=\"noreferrer\" target=\"_blank\">tryhard</a>)\nthat rewrites existing error handling code using .\nThe proposal was argued over intensively, approaching 900 comments on the <a href=\"https://go.dev/issue/32437\">GitHub issue</a>.</p><pre><code>// printSum implementation using the proposed try mechanism.\nfunc printSum(a, b string) error {\n    // use a defer statement to augment errors before returning\n    x := try(strconv.Atoi(a))\n    y := try(strconv.Atoi(b))\n    fmt.Println(\"result:\", x + y)\n    return nil\n}\n</code></pre><p>However,  affected control flow by returning from the enclosing function in case of an error,\nand did so from potentially deeply nested expressions, thus hiding this control flow from view.\nThis made the proposal unpalatable to many, and despite significant investment\ninto this proposal we decided to abandon this effort too.\nIn retrospect it might have been better to introduce a new keyword,\nsomething that we could do now since we have fine-grained control over the language version\nvia  files and file-specific directives.\nRestricting the use of  to assignments and statements might have alleviated some\nof the other concerns. A <a href=\"https://go.dev/issue/73376\">recent proposal</a> by Jimmy Frasche, which essentially\ngoes back to the original  and  design and addresses some of that design’s\nshortcomings, pursues that direction.</p><p>The repercussions of the  proposal led to much soul searching including a series of blog\nposts by Russ Cox: <a href=\"https://research.swtch.com/proposals-intro\" rel=\"noreferrer\" target=\"_blank\">“Thinking about the Go Proposal Process”</a>.\nOne conclusion was that we likely diminished our chances for a better outcome by presenting an almost\nfully baked proposal with little space for community feedback and a “threatening” implementation\ntimeline. Per <a href=\"https://research.swtch.com/proposals-large\" rel=\"noreferrer\" target=\"_blank\">“Go Proposal Process: Large Changes”</a>:\n“in retrospect,  was a large enough change that the new design we published […] should have\nbeen a second draft design, not a proposal with an implementation timeline”.\nBut irrespective of a possible process and communication failure in this case, the user sentiment towards\nthe proposal was very strongly not in favor.</p><p>We didn’t have a better solution at that time and didn’t pursue syntax changes for error handling for several years.\nPlenty of people in the community were inspired, though, and we received a steady trickle\nof error handling proposals, many very similar to each other, some interesting, some incomprehensible,\nand some infeasible.\nTo keep track of the expanding landscape, another year later, Ian Lance Taylor created an\n<a href=\"https://go.dev/issue/40432\">umbrella issue</a>\nwhich summarizes the current state of proposed changes for improved error handling.\nA <a href=\"https://go.dev/wiki/Go2ErrorHandlingFeedback\">Go Wiki</a> was created to collect related feedback, discussions, and articles.\nIndependently, other people have started tracking all the many error handling proposals\nover the years.\nIt’s amazing to see the sheer volume of them all, for instance in Sean K. H. Liao’s blog post on\n<a href=\"https://seankhliao.com/blog/12020-11-23-go-error-handling-proposals/\" rel=\"noreferrer\" target=\"_blank\">“go error handling proposals”</a>.</p><p>The complaints about the verbosity of error handling persisted\n(see <a href=\"https://go.dev/blog/survey2024-h1-results\">Go Developer Survey 2024 H1 Results</a>),\nand so, after a series of increasingly refined Go team internal proposals, Ian Lance Taylor published\n<a href=\"https://go.dev/issue/71203\">“reduce error handling boilerplate using ”</a> in 2024.\nThis time the idea was to borrow from a construct implemented in\n<a href=\"https://www.rust-lang.org/\" rel=\"noreferrer\" target=\"_blank\">Rust</a>, specifically the\n<a href=\"https://doc.rust-lang.org/std/result/index.html#the-question-mark-operator-\" rel=\"noreferrer\" target=\"_blank\"> operator</a>.\nThe hope was that by leaning on an existing mechanism using an established notation, and taking into\naccount what we had learned over the years, we should be able to finally make some progress.\nIn small informal user studies where programmers were shown Go code using , the vast majority\nof participants correctly guessed the meaning of the code, which further convinced us to give it another\nshot.\nTo be able to see the impact of the change, Ian wrote a tool that converts ordinary Go code\ninto code that uses the proposed new syntax, and we also prototyped the feature in the\ncompiler.</p><pre><code>// printSum implementation using the proposed \"?\" statements.\nfunc printSum(a, b string) error {\n    x := strconv.Atoi(a) ?\n    y := strconv.Atoi(b) ?\n    fmt.Println(\"result:\", x + y)\n    return nil\n}\n</code></pre><p>Unfortunately, as with the other error handling ideas, this new proposal was also quickly overrun\nwith comments and many suggestions for minor tweaks, often based on individual preferences.\nIan closed the proposal and moved the content into a <a href=\"https://go.dev/issue/71460\">discussion</a>\nto facilitate the conversation and to collect further feedback.\nA slightly modified version was received\n<a href=\"https://github.com/golang/go/discussions/71460#discussioncomment-12060294\" rel=\"noreferrer\" target=\"_blank\">a bit more positively</a>\nbut broad support remained elusive.</p><p>After so many years of trying, with three full-fledged proposals by the Go team and\nliterally <a href=\"https://go.dev/issues?q=+is%3Aissue+label%3Aerror-handling\">hundreds</a> (!)\nof community proposals, most of them variations on a theme,\nall of which failed to attract sufficient (let alone overwhelming) support,\nthe question we now face is: how to proceed? Should we proceed at all?</p><p>To be more precise, we should stop trying to solve the , at least for the foreseeable\nfuture.\nThe <a href=\"https://github.com/golang/proposal?tab=readme-ov-file#consensus-and-disagreement\" rel=\"noreferrer\" target=\"_blank\">proposal process</a>\nprovides justification for this decision:</p><blockquote><p>The goal of the proposal process is to reach general consensus about the outcome in a timely manner.\nIf proposal review cannot identify a general consensus in the discussion of the issue on the issue tracker,\nthe usual result is that the proposal is declined.</p></blockquote><blockquote><p>It can happen that proposal review may not identify a general consensus and yet it is clear that the\nproposal should not be outright declined.\n[…]\nIf the proposal review group cannot identify a consensus nor a next step for the proposal,\nthe decision about the path forward passes to the Go architects […], who review the discussion and\naim to reach a consensus among themselves.</p></blockquote><p>None of the error handling proposals reached anything close to a consensus,\nso they were all declined.\nEven the most senior members of the Go team at Google do not unanimously agree\non the best path forward  (perhaps that will change at some point).\nBut without a strong consensus we cannot reasonably move forward.</p><p>There are valid arguments in favor of the status quo:</p><ul><li><p>If Go had introduced specific syntactic sugar for error handling early on, few would argue over it today.\nBut we are 15 years down the road, the opportunity has passed, and Go has\na perfectly fine way to handle errors, even if it may seem verbose at times.</p></li><li><p>Looking from a different angle, let’s assume we came across the perfect solution today.\nIncorporating it into the language would simply lead from one unhappy group of users\n(the one that roots for the change) to another (the one that prefers the status quo).\nWe were in a similar situation when we decided to add generics to the language, albeit with an\nimportant difference:\ntoday nobody is forced to use generics, and good generic libraries are written such that users\ncan mostly ignore the fact that they are generic, thanks to type inference.\nOn the contrary, if a new syntactic construct for error handling gets added to the language,\nvirtually everybody will need to start using it, lest their code become unidiomatic.</p></li><li><p>Not adding extra syntax is in line with one of Go’s design rules:\ndo not provide multiple ways of doing the same thing.\nThere are exceptions to this rule in areas with high “foot traffic”: assignments come to mind.\nIronically, the ability to  a variable in\n<a href=\"https://go.dev/ref/spec#Short_variable_declarations\">short variable declarations</a> () was introduced to address a problem\nthat arose because of error handling:\nwithout redeclarations, sequences of error checks require a differently named  variable for\neach check (or additional separate variable declarations).\nAt that time, a better solution might have been to provide more syntactic support for error handling.\nThen, the redeclaration rule may not have been needed, and with it gone, so would be various\nassociated <a href=\"https://go.dev/issue/377\">complications</a>.</p></li><li><p>Going back to actual error handling code, verbosity fades into the background if errors are\nactually .\nGood error handling often requires additional information added to an error.\nFor instance, a recurring comment in user surveys is about the lack of stack traces associated\nwith an error.\nThis could be addressed with support functions that produce and return an augmented\nerror.\nIn this (admittedly contrived) example, the relative amount of boilerplate is much smaller:</p><pre><code>func printSum(a, b string) error {\n    x, err := strconv.Atoi(a)\n    if err != nil {\n        return fmt.Errorf(\"invalid integer: %q\", a)\n    }\n    y, err := strconv.Atoi(b)\n    if err != nil {\n        return fmt.Errorf(\"invalid integer: %q\", b)\n    }\n    fmt.Println(\"result:\", x + y)\n    return nil\n}\n</code></pre></li><li><p>New standard library functionality can help reduce error handling boilerplate as well,\nvery much in the vein of Rob Pike’s 2015 blog post\n<a href=\"https://go.dev/blog/errors-are-values\">“Errors are values”</a>.\nFor instance, in some cases <a href=\"https://go.dev/pkg/cmp#Or\"></a> may be used to deal with a\nseries of errors all at once:</p><pre><code>func printSum(a, b string) error {\n    x, err1 := strconv.Atoi(a)\n    y, err2 := strconv.Atoi(b)\n    if err := cmp.Or(err1, err2); err != nil {\n        return err\n    }\n    fmt.Println(\"result:\", x+y)\n    return nil\n}\n</code></pre></li><li><p>Writing, reading, and debugging code are all quite different activities.\nWriting repeated error checks can be tedious, but today’s IDEs provide powerful, even LLM-assisted\ncode completion.\nWriting basic error checks is straightforward for these tools.\nThe verbosity is most obvious when reading code, but tools might help here as well;\nfor instance an IDE with a Go language setting could provide a toggle switch to hide error handling\ncode.\nSuch switches already exist for other code sections such as function bodies.</p></li><li><p>When debugging error handling code, being able to quickly add a  or\nhave a dedicated line or source location for setting a breakpoint in a debugger is helpful.\nThis is easy when there is already a dedicated  statement.\nBut if all the error handling logic is hidden behind a , , or , the code may have to\nbe changed into an ordinary  statement first, which complicates debugging\nand may even introduce subtle bugs.</p></li><li><p>There are also practical considerations:\nComing up with a new syntax idea for error handling is cheap;\nhence the proliferation of a multitude of proposals from the community.\nComing up with a good solution that holds up to scrutiny: not so much.\nIt takes a concerted effort to properly design a language change and to actually implement it.\nThe real cost still comes afterwards:\nall the code that needs to be changed, the documentation that needs to be updated,\nthe tools that need to be adjusted.\nTaken all into account, language changes are very expensive, the Go team is relatively small,\nand there are a lot of other priorities to address.\n(These latter points may change: priorities can shift, team sizes can go up or down.)</p></li><li><p>On a final note, some of us recently had the opportunity to attend\n<a href=\"https://cloud.withgoogle.com/next/25\" rel=\"noreferrer\" target=\"_blank\">Google Cloud Next 2025</a>,\nwhere the Go team had a booth and where we also hosted a small Go Meetup.\nEvery single Go user we had a chance to ask was adamant that we should not change the\nlanguage for better error handling.\nMany mentioned that the lack of specific error handling support in Go is most apparent\nwhen coming freshly from another language that has that support.\nAs one becomes more fluent and writes more idiomatic Go code, the issue becomes much less important.\nThis is of course not a sufficiently large set of people to be representative,\nbut it may be a different set of people than we see on GitHub, and their feedback serves as yet another data point.</p></li></ul><p>Of course, there are also valid arguments in favor of change:</p><ul><li><p>Lack of better error handling support remains the top complaint in our user surveys.\nIf the Go team really does take user feedback seriously, we ought to do something about this eventually.\n(Although there does not seem to be\n<a href=\"https://github.com/golang/go/discussions/71460#discussioncomment-11977299\" rel=\"noreferrer\" target=\"_blank\">overwhelming support</a>\nfor a language change either.)</p></li><li><p>Perhaps the singular focus on reducing the character count is misguided.\nA better approach might be to make default error handling highly visible with a keyword\nwhile still removing boilerplate ().\nSuch an approach might make it easier for a reader (a code reviewer!) to see that an error\nis handled, without “looking twice”, resulting in improved code quality and safety.\nThis would bring us back to the beginnings of  and .</p></li><li><p>We don’t really know how much the issue is the straightforward syntactic verbosity of\nerror checking, versus the verbosity of good error handling:\nconstructing errors that are a useful part of an API and meaningful to developers and\nend-users alike.\nThis is something we’d like to study in greater depth.</p></li></ul><p>Still, no attempt to address error handling so far has gained sufficient traction.\nIf we are honestly taking stock of where we are, we can only admit that we\nneither have a shared understanding of the problem,\nnor do we all agree that there is a problem in the first place.\nWith this in mind, we are making the following pragmatic decision:</p><p><em>For the foreseeable future, the Go team will stop pursuing syntactic language changes\nfor error handling.\nWe will also close all open and incoming proposals that concern themselves primarily\nwith the syntax of error handling, without further investigation.</em></p><p>The community has put tremendous effort into exploring, discussing, and debating these issues.\nWhile this may not have resulted in any changes to error handling syntax, these efforts have\nresulted in many other improvements to the Go language and our processes.\nMaybe, at some point in the future, a clearer picture will emerge on error handling.\nUntil then, we look forward to focusing this incredible passion on new opportunities\nto make Go better for everyone.</p>","contentLength":15857,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","go"]}