{"id":"8VeqsBQ","title":"Blogs","displayTitle":"Blogs","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":5,"items":[{"title":"Crystal Prime Deluxe 18000 Box of 10","url":"https://dev.to/crystalprimedeluxe18000boxof10/crystal-prime-deluxe-18000-box-of-10-5gkf","date":1761667794,"author":"Crystal Prime Deluxe 18000 Box of 10","guid":64,"unread":true,"content":"<p>VapeZone  offers premium vape products at competitive prices, based in the UK. Explore our wide range of high-quality vapes and accessories.</p>","contentLength":140,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Notes on Building CLI and GUI tools with Crystal","url":"https://dev.to/kojix2/notes-on-building-cli-and-gui-tools-with-crystal-4pcd","date":1760498714,"author":"kojix2","guid":63,"unread":true,"content":"<p>This post is just me writing down some vague thoughts that are floating around in my head right now.</p><p>Sorry if you came here expecting a well-structured tutorial — but you know, if I try to organize everything perfectly, I’ll never publish anything.</p><p>Crystal originated from the Ruby community, so there are many people who want to build web applications with it.</p><p>However, the Crystal programming language itself can be described as “a statically compiled language with a Ruby-like syntax and a garbage collector, somewhat like C with GC and type inference.”</p><p>It’s not necessarily optimized for web applications.</p><p>Personally, I wanted to use Crystal for command-line tools and GUI apps.</p><p>For some reason, though, there don’t seem to be many people building CLI tools in Crystal.</p><p>The ecosystem for building and distributing binaries wasn’t very well developed for a long time.</p><p>That used to be a real pain, but after <a href=\"https://dev.to/kojix2/12-things-i-learned-writing-cli-tools-in-crystal-12if\">gradually solving those issues</a>, I think we’re now at the point where most CLI tools I want can be built and distributed in Crystal without much trouble.</p><p>On the GUI side, the situation is similar — there aren’t many libraries available.</p><p>But this isn’t unique to Crystal. GUI programming, in general, depends heavily on opaque, platform-specific APIs, which don’t always play nicely with open-source development.</p><p>Then I got curious about <a href=\"https://tauri.app/\" rel=\"noopener noreferrer\">Tauri</a> and <a href=\"https://www.electronjs.org\" rel=\"noopener noreferrer\">Electron</a> — the now-famous WebView-based app frameworks.</p><p>Personally, I can barely read JavaScript, so I had no real interest in those at first, but their popularity made me curious.</p><p>And as I mentioned earlier, web app development in the Crystal ecosystem is quite active.</p><p>So I decided to give it a try.</p><p>I learned that “WebView” isn’t a single library — each OS (Windows, Linux, macOS) provides its own.</p><p>Projects like <a href=\"https://github.com/webview/webview\" rel=\"noopener noreferrer\">webview/webview</a> and Tauri’s <a href=\"https://github.com/tauri-apps/wry\" rel=\"noopener noreferrer\">wry</a> act as unifying layers over these platform-specific APIs.</p><p>Tauri itself uses WebView under the hood while also providing a framework to handle security and integration with Rust backends.</p><p>Maybe it’s possible to use TypeScript and other frontend tools with Crystal too, but personally, I prefer the more old-fashioned approach — something like <a href=\"https://github.com/kemalcr/kemal\" rel=\"noopener noreferrer\">Kemal</a> + <a href=\"https://crystal-lang.org/api/ECR.html\" rel=\"noopener noreferrer\">ECR</a>, the “classic amateur” way.</p><p>When I actually started building an app with Crystal + WebView, I discovered a few things.</p><p>First, you need to pay attention to event loops and thread management.</p><p>The WebView itself runs in a separate process, and at the same time you need to run a Kemal server.</p><p>That means you often have to make it multithreaded and carefully manage your execution contexts or Fibers — otherwise, things simply won’t run correctly.</p><p>Then there’s the build, linking, and packaging pain.</p><p>I sent <a href=\"https://github.com/naqvis/webview/pulls?q=+author%3Akojix2\" rel=\"noopener noreferrer\">a few pull requests</a> to the Crystal WebView project, which helped a bit, but building on MinGW is still rough.</p><p>MSVC technically works, but it’s just too tedious to deal with, so I decided to stay away from it.</p><p>Bundling shared libraries is also tricky.</p><p>I’d prefer to lean toward static linking whenever possible, but depending on licensing and security update concerns, it’s sometimes better to link against system or bundled shared libraries.</p><p>I discovered tools like <a href=\"https://github.com/jordansissel/fpm\" rel=\"noopener noreferrer\">fpm</a>, which are really useful, but in the end, I still end up asking AI to help me write custom GitHub Actions YAML and shell scripts.</p><p>And then, once you finally have a working binary, Windows or macOS antivirus software will happily flag it as suspicious.</p><p>Maybe for people doing this professionally, all this doesn’t sound like a big deal, but as someone doing it for fun, it’s a lot of work.\nEven so, after all the pain, I’ve started to feel like — maybe, just maybe — this setup is actually pretty cool.</p><p>This post was translated from the original Japanese version using ChatGPT.<p>\nYou can read the original post </p><a href=\"https://qiita.com/kojix2/items/e9bb62e9ff9f966b36a4\" rel=\"noopener noreferrer\">here</a> [JA]</p>","contentLength":3784,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How a quartz crystal works in a microcontroller?","url":"https://dev.to/carolineee/how-a-quartz-crystal-works-in-a-microcontroller-4lhf","date":1760434663,"author":"Hedy","guid":62,"unread":true,"content":"<p>This is a fundamental concept in <a href=\"https://www.ampheo.com/c/microcontrollers\" rel=\"noopener noreferrer\">microcontroller</a> systems. Let's break down how a quartz <a href=\"https://www.onzuu.com/category/crystals\" rel=\"noopener noreferrer\">crystal</a> works in a microcontroller, from the basic physics to the practical circuit.</p><p><strong>The Core Concept: The Piezoelectric Effect</strong>\nAt the heart of a quartz crystal is a physical phenomenon called the Piezoelectric Effect.</p><ul><li>Mechanical → Electrical: When you apply a physical stress (squeeze or bend) to a quartz crystal, it generates a small electrical voltage across its surfaces.</li><li>Electrical → Mechanical: Conversely, when you apply an electrical voltage to a quartz crystal, it physically deforms (vibrates) slightly.</li></ul><p>This two-way street is the magic key.</p><p><strong>How It Creates a Clock Signal: Resonance</strong></p><ol><li><p>Natural Frequency: Every piece of quartz crystal has a natural resonant frequency—a specific frequency at which it \"likes\" to vibrate most efficiently. This frequency is determined primarily by its physical size, shape, and how it's cut. A thinner, smaller crystal vibrates at a higher frequency. This is why crystals for common microcontrollers (like 16 MHz, 20 MHz) are small, while crystals for real-time clocks (32.768 kHz) are larger and often cylindrical.</p></li><li><p>The <a href=\"https://www.onzuu.com/category/oscillators\" rel=\"noopener noreferrer\">Oscillator</a> Circuit: Inside the microcontroller, there is a specialized circuit called a Crystal Oscillator (often denoted as OSC1 and OSC2 pins). This circuit is designed to:</p></li></ol><ul><li>Apply a constantly alternating voltage to the crystal.</li><li>Listen to the tiny voltage generated by the crystal's vibration.</li><li>Amplify that signal and feed it back to the crystal.</li></ul><ol><li>The Self-Sustaining Loop (The \"How It Works\"):</li></ol><ul><li>When you power on the circuit, electrical noise provides a tiny, random voltage kick to the crystal.</li><li>The crystal vibrates in response, generating a tiny voltage at its natural resonant frequency.</li><li>The oscillator circuit in the microcontroller picks up this tiny signal, amplifies it, and feeds it back to the crystal.</li><li>This reinforced signal causes the crystal to vibrate more strongly.</li><li>Within a few milliseconds, this feedback loop builds up into a strong, continuous, and perfectly stable oscillation at the crystal's precise natural frequency.</li></ul><p>The result is a clean, square-wave clock signal that drives the entire microcontroller.</p><p><strong>The Complete Picture: The Practical Circuit</strong>\nOn your schematic and PCB, you don't just connect the crystal directly to the MCU. A typical crystal circuit looks like this:</p><div><pre><code>text\n\n         ---||---       ---||---\nOSC1 |---|     |---X---|     |---| OSC2\n     |    C1        |        C2   |\n     |              |             |\n     |-------------/ \\------------|\n                   Rf (Internal)\n</code></pre></div><p>Illustration of a typical crystal oscillator circuit</p><p><strong>Components and Their Roles:</strong></p><ol><li><p>Quartz Crystal (X): The resonant element that sets the frequency.</p></li><li><p>Load Capacitors (C1 and C2): These are absolutely critical.</p></li></ol><ul><li>Purpose: They, along with the crystal's own internal capacitance, form a capacitive load that helps the crystal oscillate at its specified frequency.</li><li>Value: The values (typically 10-22 pF for most MCUs) are chosen to match the crystal's specified load capacitance. Using the wrong values can make the oscillator unstable or cause the frequency to be slightly off.</li></ul><ol><li>Internal Oscillator Circuit (inside MCU): Contains the amplifier and a feedback resistor (Rf), which biases the amplifier into its linear region so it can start and maintain oscillation.</li></ol><p><strong>Why is the Clock Signal So Important?</strong>\nThe clock signal is the \"heartbeat\" of the microcontroller. It synchronizes every operation:</p><ul><li>Core Execution: The CPU executes instructions in time with the clock ticks (each tick is one clock cycle).</li><li>Peripheral Timing: Timers, PWM (Pulse Width Modulation), and communication interfaces like UART, SPI, and I2C all rely on the clock to generate precise baud rates and time intervals.</li><li>Bus Operations: Reading from Flash memory, writing to RAM, and accessing peripherals are all coordinated by the clock.</li></ul><p>A simple analogy: Imagine an orchestra without a conductor. It would be chaotic. The crystal-generated clock signal is the conductor, ensuring every part of the microcontroller works in perfect synchrony.</p><p><strong>The Special 32.768 kHz \"Watch Crystal\"</strong>\nYou often see a second, smaller crystal on boards (shaped like a tiny can). This is almost always a 32.768 kHz crystal.</p><ul><li>Why that number? 32,768 = 2¹⁵.</li><li>A simple 15-stage binary divider circuit can easily divide this frequency down to exactly 1 Hz (one pulse per second), which is perfect for driving a Real-Time Clock (RTC) to keep track of time, even when the main <a href=\"https://www.ampheoelec.de/c/microcontrollers\" rel=\"noopener noreferrer\">microcontroller</a> is in sleep mode.</li></ul><ul><li>It's a resonator: The quartz crystal doesn't create a frequency out of nothing; it <a href=\"https://www.onzuu.com/category/filters\" rel=\"noopener noreferrer\">filters</a> and stabilizes the oscillation to its precise natural frequency.</li><li>Piezoelectric Effect is key: The mechanical-electrical feedback loop is what makes it work.</li><li>It's a system: The crystal alone won't work. It needs the microcontroller's internal oscillator circuit and the external load capacitors to form a complete, functioning oscillator.</li><li>Precision and Stability: Compared to internal RC oscillators, crystals are vastly more accurate and stable over temperature and voltage changes, which is essential for timing-critical applications and communication protocols.</li></ul>","contentLength":5133,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Announcing Lustra: a Postgres ORM for Crystal","url":"https://dev.to/mamantoha/announcing-lustra-a-postgres-orm-for-crystal-2pdm","date":1759768792,"author":"Anton Maminov","guid":61,"unread":true,"content":"<p> Lustra started as a fork of <a href=\"https://github.com/anykeyh/clear\" rel=\"noopener noreferrer\">Clear</a> at version 0.8, and it is not compatible with later Clear releases. Over time it evolved into an independent project. To keep it compatible with newer Crystal versions, I continued development, added missing features, improved existing ones, and expanded test coverage. Today Lustra stands as its own project.</p><p>When I started building <a href=\"https://shards.info\" rel=\"noopener noreferrer\">shards.info</a>, I had to make an important choice: which ORM to use with Crystal. Coming from a , I was naturally looking for something similar to  — straightforward, feature-rich, and reliable. I reviewed several options available at the time: <a href=\"https://github.com/imdrasil/jennifer.cr\" rel=\"noopener noreferrer\">Jennifer</a>, <a href=\"https://github.com/Crecto/crecto\" rel=\"noopener noreferrer\">Crecto</a>, <a href=\"https://github.com/amberframework/granite\" rel=\"noopener noreferrer\">Granite</a>, and <a href=\"https://github.com/anykeyh/clear\" rel=\"noopener noreferrer\">Clear</a>. After evaluating them, I chose . At the time, it was the most advanced ORM in the Crystal ecosystem. Even though it has been limited to Postgres support, I didn’t plan to use other databases, so this limitation was never a drawback for me.</p><p>Clear later introduced a new major version with substantial API and behavior changes. Some of those changes (and a few bugs at the time) broke previously working code in my project. My system was already running smoothly, and I wasn’t ready to trade stability for churn.</p><p>To keep my project alive -  I forked it. That fork is now .</p><p> is an ORM built specifically for PostgreSQL in Crystal, maintained independently.\nIt aims to provide a stable, reliable, and Crystal-compatible ORM for Postgres database.</p><ul><li>: Associations, query builder, type safety - the same qualities that originally attracted me to Clear.</li><li>: I don’t plan to change the API in the future, so existing projects can rely on consistent behavior.</li><li>: I’ve ensured <strong>compatibility with new Crystal versions</strong>, added , and expanded .</li></ul><p>Why “Lustra”?\nBecause the word means  in several languages. To me, a chandelier looks like a database schema: a structured network of connections. It also carries the idea of  and .</p><p>Working on Lustra started as a practical need to keep my project running. Over time, it became an opportunity to explore Crystal and ORM internals more deeply. Lustra represents my preference for tools that are stable and predictable. Maintaining it has also shown me how consistent effort can turn a fork into an independent project.</p><p>Lustra will continue as a  for Crystal developers.</p><p>If you’re looking for a dependable ORM for your Crystal projects, give Lustra a try.</p>","contentLength":2333,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"libui and Garbage Collection - Challenges in Creating Ruby and Crystal Bindings","url":"https://dev.to/kojix2/libui-and-garbage-collection-challenges-in-creating-ruby-and-crystal-bindings-9m6","date":1758852946,"author":"kojix2","guid":60,"unread":true,"content":"<p>libui is a GUI library that supports the three major operating systems: Windows, macOS, and Linux (currently, the successor project is libui-ng). Internally, it contains three different libraries that call native APIs, unified under a single  header file to provide similar UI functionality across all operating systems. It can also be easily used from other languages through FFI (Foreign Function Interface). While development has slowed somewhat recently, there are few similar libraries available, and libui continues to maintain its unique value.</p><p>I have been creating <a href=\"https://github.com/kojix2/libui\" rel=\"noopener noreferrer\">Ruby bindings</a> and <a href=\"https://github.com/kojix2/uing\" rel=\"noopener noreferrer\">Crystal bindings</a> for libui. Through this process, I have come to realize how difficult it is to combine libui with garbage collection.</p><h2>\n  \n  \n  The Problem of Disappearing Controls and Callback Functions\n</h2><p>Creating Ruby or Crystal bindings for libui is not particularly difficult. The work of checking function signatures and writing matching low-level bindings can be done mechanically.</p><p>However, when you call these low-level APIs to create simple applications, the following problems occur with a certain probability:</p><ul><li>Controls disappear and memory access violations occur</li><li>Callbacks disappear and memory access violations occur</li></ul><p>Both Ruby and Crystal are languages that use garbage collection (GC), so memory that is determined to be unused gets reclaimed. As a result, pointers and callback functions that should be used in the future by the GUI main loop are mistakenly freed by the GC.</p><p>In GC languages, the timing of memory deallocation is controlled indirectly through references.</p><p>In Ruby, callback functions are unconditionally stored in a dedicated array. This effectively creates a memory leak (old callbacks remain in the array even after new ones are added), but since callback functions are usually finite in number in GUI applications, this is not a practical problem.</p><p>Crystal uses a more complex management approach. Each callback function is tied to the instance of its related control. For example, a callback function that fires when a button is pressed is owned by that button. Additionally, the nested relationships of controls themselves are reproduced as an ownership tree. For example, a Window contains a Box, and the Box holds a Label and Button.</p><p>By using this ownership tree, we can significantly reduce the problem of incorrect collection by the GC.</p><p>By the way, why does Crystal's GC collect pointers even though controls may be referenced later in the main loop? I don't have a clear understanding of this point, but it's possible that memory tracking becomes difficult when closures are boxed.</p><h2>\n  \n  \n  libui's Memory Management Rules\n</h2><p>libui is a C library designed for users to manage memory themselves. However, in practice, it introduces a mechanism where \"when a parent control is freed, the memory of child controls is also freed.\" The controls that can be parent controls are Window, Box, Grid, Group, Tab, and Form.</p><p>When you  these, child controls are freed first, then the parent itself is freed. Therefore, in actual operation, you often free child controls collectively by destroying the Window.</p><p>The problem is that on the Crystal side, we cannot detect such deallocation within native libraries. NULL checks might help us guess immediately after memory deallocation (libui sets pointers to NULL before deallocation), but this is unreliable.</p><p>Window deallocation can happen automatically. When the [x] button in the Window's title bar is clicked, a callback function is triggered by , and if the return value is true, the Window's destroy is automatically triggered.</p><p>In contrast,  triggered from the Quit option in the menu bar represents application termination, so it does not automatically trigger destroy for the window. The user must destroy the Window themselves and call uiQuit.</p><h2>\n  \n  \n  libui's Memory Leak Detection Mechanism\n</h2><p>libui has a built-in mechanism for detecting memory leaks. This is a very useful feature, but it often doesn't work well with GC languages. This is because in GC, the timing of memory deallocation is indefinite, and we cannot guarantee that all memory has been freed at the time of checking. Therefore, implementations that hook into GC's  to perform deallocation should be avoided.</p><h2>\n  \n  \n  Table Deallocation Procedure\n</h2><p>Table is based on Model-View architecture, with TableModel and Table separated. A TableModel can only be freed after all Tables using that model have been destroyed. Therefore, the deallocation procedure is as follows:</p><ol><li>Remove the Table from its parent control</li><li>Explicitly destroy the Table</li><li>Finally destroy the TableModel</li></ol><h2>\n  \n  \n  Area Deallocation Procedure\n</h2><p>Unlike Table, Area can be handled by simply destroying the control.</p><h2>\n  \n  \n  MultilineEntry Deallocation Procedure\n</h2><p>While detailed investigation of the cause is still in progress, on macOS there appear to be cases where problems occur unless you remove it from the parent control and destroy it individually, similar to Table.</p><p>When using libui (libui-ng), there are many important considerations regarding memory management, especially deallocation.</p><p>In languages that use garbage collection like Crystal and Ruby, you normally don't need to worry about memory. Even with C language bindings, manual memory management often becomes unnecessary by using deallocation callback functions like .</p><p>However, I learned that with libraries like GUI libraries that have interactive operations where timing and synchronization are important, there are cases where you cannot rely too much on GC and must manually free memory at appropriate times.</p><p>In such cases, Ruby and Crystal often provide APIs that use blocks based on RAII (Resource Acquisition Is Initialization) concepts. This can handle more than half of the cases.</p><p>There seem to be cases that are difficult to handle with this alone, but I am still learning and experimenting through trial and error.</p><p>Thank you for reading. This article was translated from Japanese to English by Claude Sonnet4.</p>","contentLength":5948,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["blog"]}