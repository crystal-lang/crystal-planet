{"id":"8VeqsBQ","title":"Blogs","displayTitle":"Blogs","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":3,"items":[{"title":"Applying the Presenter Pattern in Marten","url":"https://dev.to/treagod/applying-the-presenter-pattern-in-marten-37cf","date":1750690462,"author":"Marvin Ahlgrimm","guid":3,"unread":true,"content":"<p>I recently ran into a problem in one of my <a href=\"https://martenframework.com/\" rel=\"noopener noreferrer\">Marten</a> projects. My  model — originally quite simple — ended up bloated with methods like , , sidebar data prep and more. Nearly every view needed these calculations, so my model was being polluted with logic that didn’t belong there. </p><p>Marten templates doesn't allow complex calculations, so I had to do these calculations in my models and access it in my template. But this made the model huge and hard to maintain. It felt wrong to mix UI logic with data persistence.</p><p>I wanted to keep my models clean and focused on their primary role: representing data in the database. But I also needed a way to prepare data for my templates without cluttering the model with view-specific logic.</p><p>To solve this, I borrowed a pattern from Rails and other ecosystems: the . Instead of stuffing the  model, I moved view-specific logic into a  class. I then plugged that into my handlers so my templates could work cleanly with journey.</p><h2>\n  \n  \n  Extracting a Presenter for my  model\n</h2><p>My  model acts as a central wrapper — holding transports, accommodations, travelers, days, and so on. All my journey views show a sidebar with accumulated price, total traveler count, and other derived data. That made it a perfect candidate for moving presentation logic out of the model.</p><p>Initially I thought to use , but manually listing every method felt brittle.</p><p>Thankfully Crystal’s macro system allowed me to generate delegations compile-time. The result: a reusable  module that forwards all public, zero-argument methods from the model and mixes in <code>Marten::Template::Object::Auto</code>, making them accessible in Marten templates.</p><div><pre><code></code></pre></div><p>This modules macro  takes a class, which is used to create a initializer that takes an instance of the class we want to present. It also creates delegation functions for all public methods that take no arguments (in assumption they are getters).</p><p>: This could be extended to use a blacklist of methods to exclude.</p><p>The macro generates methods that delegate to the wrapped model, so I only need to call  instead of .</p><p>The present  call wraps up model attributes neatly and compile-time delegation avoids manual boilerplate.</p><div><pre><code></code></pre></div><p>: I wrap  inside a  block. Without deferring it, the compiler wouldn’t have fully resolved ’s methods yet — so delegation wouldn’t include them all.</p><p>All  fields are directly accessible, e.g.  or !</p><p>This presenter now handles formatting dates, accumulates prices and travelers, and provides ordered collections. Models stay lean, and templates stay expressive and focused.</p><h3>\n  \n  \n  Injecting the Journey Presenter into Handlers\n</h3><p>I wanted a quick way to make journey available in my templates, so I built this mix-in:</p><div><pre><code></code></pre></div><h2>\n  \n  \n  Using the Presenter in a Real Handler\n</h2><p>Here’s an example handler that includes the mix-in:</p><div><pre><code></code></pre></div><p>By including , this handler automatically injects a fully prepared  into the templates context.</p><ul><li>Models stay focused on persistence — no mix of UI logic</li><li>Templates call <code>{{ journey.travel_period }}</code> or <code>{{ journey.total_costs }}</code> directly</li><li>Presenter class is testable in isolation</li><li>Handlers are lean and declarative</li><li>Macros generate safe, compile-time delegations</li><li>No global state, no hidden context—everything is explicit</li></ul><p>Everything just works, and it’s easy to extend or test.</p>","contentLength":3246,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Writing Inline Assembly in the Crystal Programming Language","url":"https://dev.to/kojix2/writing-inline-assembly-in-the-crystal-programming-language-d9a","date":1750393024,"author":"kojix2","guid":2,"unread":true,"content":"<p>When you want to make your code run significantly faster, or just want to explore how computers work at a lower level, you might find yourself curious about writing instructions directly for the CPU. In Crystal, you can do this using .</p><p>Crystal is a programming language built on top of the LLVM compiler infrastructure. Thanks to this, it can access many of LLVM's powerful features. For low-level programming, Crystal provides both  functions and the  syntax.</p><p>Crystal supports writing inline assembly using the  keyword.</p><div><pre><code>asm(\"template\" : outputs : inputs : clobbers : flags)\n</code></pre></div><ul><li> — Assembly code using LLVM’s integrated assembler syntax</li><li> — Registers that may be modified</li><li> — Optional flags (e.g., )</li></ul><p>This colon-separated syntax is quite unusual in Crystal and comes from GCC's inline assembly syntax.</p><p>Let’s look at some examples.</p><h3>\n  \n  \n  Setting a Value Using an Output Operand\n</h3><div><pre><code></code></pre></div><p>Note that  is an immediate literal value, and  is a placeholder for the output operand.</p><p>Using  is optional; initializing with  works as well.</p><div><pre><code></code></pre></div><h3>\n  \n  \n  Using Multiple Input Operands\n</h3><div><pre><code></code></pre></div><h3>\n  \n  \n  Using Multiple Output Operands\n</h3><div><pre><code></code></pre></div><p>You can also use Intel-style syntax:</p><div><pre><code></code></pre></div><p>For relatively simple operations, LLVM provides . These functions are highly optimized, platform-independent, and often compatible with Crystal’s interpreter. However, for most basic operations, Crystal's standard library already provides efficient implementations, so using intrinsics does not always yield performance benefits.</p><p>Available intrinsics are defined in the <a href=\"https://crystal-lang.org/api/Intrinsics.html\" rel=\"noopener noreferrer\"></a> module.</p><h3>\n  \n  \n  Common Intrinsic Functions\n</h3><div><pre><code></code></pre></div><h4> — Move memory with overlap support\n</h4><div><pre><code></code></pre></div><h4> — Initialize memory\n</h4><div><pre><code></code></pre></div><h4> — Trigger debugger trap\n</h4><h4> — CPU pause (works on x86/x64 and AArch64)\n</h4><p>This is often used internally in Crystal’s  or  implementations.</p><h4> — Read the CPU cycle counter\n</h4><div><pre><code></code></pre></div><div><pre><code></code></pre></div><h3>\n  \n  \n  Bit Manipulation Intrinsics\n</h3><ul><li>, , , , </li></ul><div><pre><code></code></pre></div><ul><li>, , , </li></ul><div><pre><code></code></pre></div><ul><li>, , , , </li></ul><div><pre><code></code></pre></div><ul><li>, , , , </li></ul><div><pre><code></code></pre></div><ul><li>, , , , </li></ul><div><pre><code></code></pre></div><p>Crystal still lacks extensive documentation in many languages, but <a href=\"https://deepwiki.com/crystal-lang/crystal\" rel=\"noopener noreferrer\">DeepWiki</a> is a reliable source for answers to most questions. This article is based on what I’ve learned from DeepWiki, and all code examples have been tested to ensure they work correctly. I highly recommend it.</p><p>That’s all for now — happy hacking with Crystal!</p><p>This post was translated from Japanese to English by ChatGPT. \nClick <a href=\"https://qiita.com/kojix2/items/08c1a6a9d32f15f5a921\" rel=\"noopener noreferrer\">here</a> to see the original post.</p>","contentLength":2284,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"TRON Hits 2M Users—What’s Next for TRX Price?","url":"https://dev.to/crypto_sara/tron-hits-2m-users-whats-next-for-trx-price-272m","date":1750068666,"author":"crypto sara","guid":1,"unread":true,"content":"<p>TRON (TRX) continues to demonstrate resilience in a volatile crypto market. Despite minor price fluctuations, seasoned investors closely watch its on-chain activity and ecosystem strength. As of now, the TRON price stands at $0.2717, slightly down 0.28% over the past 24 hours. But beneath the surface, there's a story that could influence its  in the coming months.</p><h2>\n  \n  \n  On-Chain Strength and Network Utility\n</h2><p><a href=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fjmgl9xe6nipgtsy61may.png\"><img src=\"https://media2.dev.to/dynamic/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fjmgl9xe6nipgtsy61may.png\" alt=\"tron\" width=\"761\" height=\"213\"></a>\nTRON’s network remains one of the busiest in the blockchain space. It facilitates over $20 billion in daily transaction volume, largely due to its dominance in stablecoin activity—particularly USDT. With more than 50% of Tether’s circulating supply hosted on TRON, the network has carved out a strong position in DeFi and cross-border payments.</p><ul><li><p>: Over 2 million daily active users were recorded in Q2 2025, according to IntoTheBlock data.</p></li><li><p>: TRON boasts ultra-low fees and high-speed transactions, making it a preferred network for stablecoin movement.</p></li></ul><h2>\n  \n  \n  Moving Averages Offer a Technical Outlook\n</h2><p>TRON’s 50-day SMA sits at $0.2669, while its 200-day SMA is at $0.2514—both of which are acting as strong support indicators. This suggests long-term bullish strength, even if short-term corrections persist.</p><h2>\n  \n  \n  Regulatory Overhang: Tether's Freeze Raises Eyebrows\n</h2><p>The recent freeze of $12.3 million in USDT on the TRON blockchain by Tether reignites concerns around compliance and regulation. Though no official reason was provided, it's likely tied to anti-money laundering enforcement and OFAC sanctions monitoring.</p><ul><li><p> Tether also froze $27 million on the Russian exchange Garantex earlier this year.</p></li><li><p>: Despite such moves, over $15 million in Garantex-linked reserves remain active, per Global Ledger.</p></li></ul><p>While the regulatory actions raise caution, TRON’s fundamentals continue to strengthen. Investors may see temporary dips as buying opportunities, with a long-term price prediction leaning bullish if adoption and utility sustain momentum.</p>","contentLength":1967,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["blog"]}