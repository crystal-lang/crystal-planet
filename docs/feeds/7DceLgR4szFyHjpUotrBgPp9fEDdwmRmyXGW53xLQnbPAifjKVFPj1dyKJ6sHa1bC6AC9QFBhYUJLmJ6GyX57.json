{"id":"7DceLgR4szFyHjpUotrBgPp9fEDdwmRmyXGW53xLQnbPAifjKVFPj1dyKJ6sHa1bC6AC9QFBhYUJLmJ6GyX57","title":"top scoring links : linux","displayTitle":"Reddit - Linux","url":"https://www.reddit.com/r/linux/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/linux/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Firefox 141 Beta Lowering RAM Use On Linux But Still Benchmarking Behind Chrome","url":"https://www.phoronix.com/review/firefox-141-linux-ram","date":1750952151,"author":"/u/lebron8","guid":336,"unread":true,"content":"<p>Following this week's release of <a href=\"https://www.phoronix.com/news/Firefox-140\">Firefox 140</a>, Firefox 141 was promoted to beta. Most exciting for Linux users with next month's Firefox 141 release is finally lowering system RAM use! I've been running some benchmarks looking at the impact.</p><p>With this week's release of <a href=\"https://www.mozilla.org/en-US/firefox/141.0beta/releasenotes/\">Firefox 141 Beta</a>, it notes an exciting change for Linux users:</p><blockquote>\"On Linux Firefox uses less memory and no longer requires a forced restart after an update has been applied by a package manager.\"</blockquote><p>Less memory use by Firefox on Linux is certainly welcome as it's become quite bloated... I've grown frustrated myself with the direction of Firefox and the insane RAM use in recent times. While being a long time Firefox user since the Firebird days, I've contemplated switching to Chrome given the rampant memory use of Firefox on Linux with my 64GB RAM laptop triggering the OOM daemon routinely due to excessive memory use with Firefox.</p><p>Thus with the Firefox 141 Beta release, I was curious to run some benchmarks of Firefox 140 vs. Firefox 141 Beta on a test system for seeing the difference.</p><p>With this testing I was just looking at the single-tab/window impact for reproducibility while running various web browser benchmarks but that alone was enough to show a nice improvement over Firefox 140.</p><p>This round of benchmarks were done on an AMD Ryzen 9 9950X desktop running Ubuntu 25.04 with the Linux 6.15 kernel and NVIDIA graphics.</p>","contentLength":1393,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1ll390m/firefox_141_beta_lowering_ram_use_on_linux_but/"},{"title":"Over 80% of all Smartphones are powered by Linux","url":"https://linuxblog.io/80-percent-smartphones-linux/","date":1750944416,"author":"/u/modelop","guid":339,"unread":true,"content":"<p data-pm-slice=\"1 1 []\">Linux-powered smartphones are still the dominant force in the global smartphone market in 2025. While some may be surprised by this fact, <a href=\"https://linuxcommunity.io/\" target=\"_blank\" rel=\"noopener\">Linux enthusiasts</a> have every reason to be happy about the continued success and influence of Linux in the mobile world.</p><p data-pm-slice=\"1 1 []\">Read on for the latest stats, updated links and proof that Linux is still at the heart of the smartphone ecosystem. This is a follow-up to my previous articles in <a href=\"https://web.archive.org/web/20131216223204/https://haydenjames.io/81-percent-smartphones-powered-by-linux/\" target=\"_blank\" rel=\"noopener\">2013</a> and <a href=\"https://web.archive.org/web/20210315133957/https://haydenjames.io/85-of-all-smartphones-are-powered-by-linux/\" target=\"_blank\" rel=\"noopener\">2021</a>.</p><p>Google formalized their efforts to keep Android closer to upstream Linux by introducing the <a href=\"https://source.android.com/docs/core/architecture/kernel/generic-kernel-image\" target=\"_blank\" rel=\"noopener\">Generic Kernel Image (GKI)</a> project in 2019. Since then, the GKI project has matured a lot, with ongoing upstream kernel development focused on reducing fragmentation, upstreaming Android-specific features and establishing a stable <a href=\"https://source.android.com/docs/core/architecture/kernel/stable-kmi\" target=\"_blank\" rel=\"noopener\">Kernel Module Interface (KMI)</a>.</p><p>All of which has strengthened Android’s connection to the mainline Linux kernel and fostered closer collaboration between Google, device vendors, and the Linux community.</p><h2>Android and Chrome OS: Still Linux at the Core</h2><p><a href=\"https://www.android.com/\" target=\"_blank\" rel=\"nofollow noopener\">Google’s Android</a> and <a href=\"https://www.google.com/chromebook/chrome-os/\" target=\"_blank\" rel=\"nofollow noopener\">Chrome OS</a> are operating systems originally based on the <a href=\"https://linuxblog.io/best-linux-distro/\" target=\"_blank\" rel=\"nofollow noopener\">Linux kernel</a>. Android, in particular, has continued to evolve, now running on long-term support (LTS) Linux kernels, such as versions 4.19, 5.4, and more recently, 6.x series, with regular merges from the Linux mainline into the Android-common kernel tree.</p><h2>2025 Smartphone Market Share: Linux Still Leads</h2><p>Recent <a href=\"https://canalys.com/newsroom/worldwide-smartphone-market-q1-2025\" target=\"_blank\" rel=\"nofollow noopener\">Canalys (Omdia) research</a> shows that in Q1 2025, the global smartphone market shipped 296.9 million units, with Android-based devices continuing to dominate. Samsung led with 60.5 million units (20% market share), followed by Apple with 55.0 million units (19%). <a href=\"https://en.wikipedia.org/wiki/MIUI\" target=\"_blank\" rel=\"noopener\">Xiaomi</a>, <a href=\"https://en.wikipedia.org/wiki/Funtouch_OS\" target=\"_blank\" rel=\"noopener\">vivo</a>, and <a href=\"https://en.wikipedia.org/wiki/ColorOS\" target=\"_blank\" rel=\"noopener\">OPPO</a> rounded out the top five.</p><p><em><strong>Combining Android, Xiaomi, Vivo, OPPO, and other Android-based OSes,</strong></em><em><strong>Linux powers around 80% of the global smartphone market.</strong></em></p><p>Android’s share remains robust, with estimates consistently placing it at over 80% of global smartphone shipments. Yup, more than a decade after my first article on this, the vast majority of smartphones in use today are still powered by the Linux kernel.</p><h2>Alternative Linux Smartphones in 2025</h2><p>While Android dominates, several alternative Linux-based smartphones continue to attract enthusiasts and privacy-focused users:</p><ul><li> Purism’s security- and privacy-focused smartphone, running on Debian Linux, continues to receive updates and improvements. It remains a leading choice for those who value open-source hardware and software.</li><li> Pine64’s PinePhone and PinePhone Pro offer mainline Linux support and hardware kill switches, appealing to developers and tinkerers.</li><li> The Pro¹-X, an updated version of the original Pro1, features a physical keyboard and support for multiple Linux-based OS options, including LineageOS and Ubuntu Touch.</li><li> KDE’s Plasma Mobile continues to evolve, supporting a range of devices including the PinePhone and select Android handsets via postmarketOS.</li></ul><h2>Checking the Linux Kernel Version on Your Android</h2><p>To see which Linux kernel your Android device is running, open  and tap on  or .&nbsp;For rooted devices, you can use <a href=\"https://play.google.com/store/apps/details?id=com.termux\" target=\"_blank\" rel=\"nofollow noopener\">Termux</a> and run:</p><p>This command will display your device’s kernel version and build information.</p><h2>Conclusion: Linux’s Enduring Dominance</h2><p>Android’s open-source nature and the flexibility of the Linux kernel continue to drive innovation and user empowerment in the smartphone market. With Android holding steady at around 80% global market share in 2025, Linux’s influence is as strong as ever.</p><p>Smartphones powered by Linux continue to dominate the global smartphone market in 2025. While some may still be surprised by this fact, Linux enthusiasts have every reason to celebrate the ongoing success and influence of Linux in the mobile world.</p><p>With the fall of the Windows phone, almost 100% of all smartphones are powered by Unix and Unix-like systems. Meanwhile, alternative Linux and Android-based smartphones such as those listed above, offer exciting options for those seeking greater privacy, control, or experimentation.</p>","contentLength":3992,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1ll04eh/over_80_of_all_smartphones_are_powered_by_linux/"},{"title":"Blender 5.0 Introducing HDR Support On Linux With Vulkan + Wayland","url":"https://www.phoronix.com/news/Blender-5.0-HDR-Linux-Wayland","date":1750935019,"author":"/u/B3_Kind_R3wind_","guid":337,"unread":true,"content":"\nThe upcoming Blender 5.0 3D modeling software application is introducing High Dynamic Range (HDR) display support on Linux when making use of Wayland -- no X11 support for HDR -- and Vulkan graphics accelerator.\n<p>HDR support for Blender 5.0 on Linux is currently considered experimental. Enabling the HDR support on Linux for the Blender creator software requires having a High Dynamic Range display (of course) and be running on a Wayland desktop, enabling Vulkan API acceleration rather than OpenGL, and enabling the feature currently deemed experimental.\n</p><p>As the Blender HDR support on Linux has been tested with a limited number of configurations so far, it's currently being treated as experimental. Depending upon testing feedback it may be promoted beyond being an \"experiment\" feature or Blender 5.0, so we'll see. In my testing of the latest Blender 5.0 alpha build on Ubuntu Linux with </p><a href=\"https://www.phoronix.com/review/samsung-g8-g81sf\">Samsung Odyssey OLED G8 G81SF</a> and <a href=\"https://www.phoronix.com/review/linux-hdr-2025\">ASUS ROG Swift OLED PG27UCDM</a> displays, this experimental feature was working out fine in my basic tests.\nMore details on this initial HDR support for Blender 5.0 on Linux with Vulkan/Wayland can see <a href=\"https://devtalk.blender.org/t/vulkan-wayland-hdr-support/41214\">this Blender DevTalk thread</a> for all the details and to share your feedback on any testing.","contentLength":1218,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1lkx1kn/blender_50_introducing_hdr_support_on_linux_with/"},{"title":"lightning-image-viewer 0.2.0","url":"https://github.com/shatsky/lightning-image-viewer/releases/tag/v0.2.0","date":1750896610,"author":"/u/shatsky","guid":334,"unread":true,"content":"<div><p>Fast and lightweight desktop image viewer featuring minimalistic \"transparent fullscreen overlay\" UI/UX with controls similar to map apps. This is 1st release featuring pre-built binaries (for Ubuntu 25.04 and Windows, built on GitHub CI/CD) and web demo ( <a href=\"https://shatsky.github.io/lightning-image-viewer/\">https://shatsky.github.io/lightning-image-viewer/</a> )</p></div>   submitted by   <a href=\"https://www.reddit.com/user/shatsky\"> /u/shatsky </a>","contentLength":338,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1lkluyb/lightningimageviewer_020/"},{"title":"Stop talking about Fedora change proposals like they have already decided on it.","url":"https://www.reddit.com/r/linux/comments/1lkjj8l/stop_talking_about_fedora_change_proposals_like/","date":1750890433,"author":"/u/wowieniceusername","guid":338,"unread":true,"content":"<p>Seriously. Everytime some controversial change gets proposed on Fedora, someone reports on it without making it clear that it only  get through after enough thought and discussion, and the entire comment section devolves into people yelling about this and that even though literally anybody can propose a change over there. And alot of the time those proposals don't even get through.</p><p>I get that potential major change is big news and a good source for discussions but dear god in the past week alone I've seen two different news about a Fedora change proposal where people act like the developers have already decided on it and it has zero pushback and is going to happen soon (removing 32-bit support being one of them). I don't even use Fedora but it gets really annoying. Atleast make it clear.</p><p>With that said I realized that readers will probably just be stupid and will overreact regardless but I don't think it hurts to be as clear as possible.</p>","contentLength":949,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Coccinelle for Rust progress report","url":"https://www.collabora.com/news-and-blog/blog/2025/06/25/coccinelle-for-rust-progress-report/","date":1750879445,"author":"/u/mfilion","guid":335,"unread":true,"content":"<p><em>In collaboration with Inria (the French Institute for Research in Computer Science and Automation), Tathagata Roy shares the progress made over the past year on the CoccinelleForRust project, co-sponsored by Collabora.</em></p><p>Coccinelle is a tool for automatic program matching and transformation that was originally developed for making large-scale changes to the Linux kernel source code (i.e., C code). Matches and transformations are driven by user-specific transformation rules in the form of abstracted patches, referred to as . As the Linux kernel—and systems software more generally—is starting to adopt Rust, we are developing <a href=\"https://rust-for-linux.com/coccinelle-for-rust\" target=\"_blank\" rel=\"noopener\">Coccinelle for Rust</a> to make the power of Coccinelle available to Rust codebases.</p><p><a href=\"https://fuchsia.googlesource.com/third_party/rust/+/70e85d146fee03c09e28a02c9c18d56e74254f3c%5E2..70e85d146fee03c09e28a02c9c18d56e74254f3c/\" target=\"_blank\" rel=\"noopener\">This diff</a> illustrates a patch in which the  function was being called  confirming that the target item’s trait was implemented. A straightforward CfR-based fix is to find every expression of the form</p><p><code>\nexpression.type_of(impl_id)\n</code></p><p><code>\nexpression.type_of(impl_id).subst_identity()\n</code></p><p>There are roughly fifty occurrences of this pattern in the diff, so updating them all by hand would be quite tedious. The accompanying Semantic Patch to perform this transformation automatically is:</p><pre><code>@change_ty_of@\nexpression exp1, impl_id;\n@@\n\n-exp1.type_of(impl_id)\n+exp1.type_of(impl_id).subst_identity()\n</code></pre><p>While the above example could be achieved with a complicated and unreadable regex pattern, things can quickly become more complex.</p><p>The following patch changes a function signature and all the related calls.</p><pre><code>@change_sig@\nexpression x;\nidentifier fname, sname;\n@@\n\nimpl sname {\n    ...\n    pub(crate) fn fname(&amp;self,\n-       guard: &amp;RevocableGuard&lt;'_&gt;\n    ) -&gt; Result { ... }\n    ...\n}\n\n@modify_calls@\nexpression x, guard;\nidentifier change_sig.fname;\n@@\n\nx.fname(\n    ...\n-   guard\n)\n</code></pre><p>Rule  finds all the occurrences of functions which take a  of type  and removes that parameter. The rule  updates the calls to that method.</p><p>This semantic patch can be used on a whole code-base where once a  variable is no longer needed, it can be removed. It can also serve as an integration test to check that no such code is present in new pull requests.</p><h3>Developments (2024–Present)</h3><ol><li>Core pattern-matching engine using CTL.</li><li>Shared with C version, adapted for Rust’s expression-heavy syntax.</li><li>Performance optimized with s and hash tables.</li></ol><ol><li>SmPL includes Rust + custom syntax (, , , disjunctions).</li><li>Custom parser for SmPL constructs; uses Rust Analyzer for Rust code.</li></ol><ol><li>Define code transformations scoped to an environment.</li><li>Support for rule inheritance.</li><li>Rule dependencies not yet implemented.</li></ol><ol><li>Connects code segments within the same control flow.</li><li>Higher complexity due to Rust’s flexible syntax.</li></ol><p> not yet supported.</p><ol><li>Alternative code match options.</li><li>Can combine with ellipses for complex patterns.</li></ol><h3>Developments in detail: 2024–Present</h3><p>Computational Tree Logic (CTL) is the heart of Coccinelle, which takes semantic patches and generalizes them over Rust files. Prior to using this engine, CfR used an ad-hoc method for matching patterns of code. This engine is the same as the one used for Coccinelle for C, with a few minor changes. Most of the changes were idiomatic but to the same effect. More information on the engine and its language (CTL-VW) can be found in the <a href=\"https://coccinelle.gitlabpages.inria.fr/website/papers/popl09.pdf\" target=\"_blank\" rel=\"noopener\">POPL Paper</a>. With a standard engine, each step of the matching process can be logged, allowing us to learn and reuse the same design patterns from Coccinelle for C, including critical test cases.</p><p>The expression-dominated nature of Rust makes the matching and transformation process a bit different from that of C. For example, in the following semantic patch:</p><pre><code>@@\nexpression e\n@@\n\n-foo(e);\n</code></pre><p>for C,  would be guaranteed to be present as an immediate child of a block, i.e.:</p><pre><code>{           // &lt;- start of a block\n    foo(e); // &lt;- this statement\n}\n</code></pre><p>Blocks in C are present only in specific parts of the Abstract Syntax Tree, like in function definitions, loops, or conditional blocks. However, in Rust, blocks are expressions, which can appear anywhere an expression is allowed. For example:</p><pre><code>while { f(&amp;mut a); a &gt; 1 } {\n    //\n}\n</code></pre><p>This makes searching much more computationally intensive. Thus, several optimizations were implemented in CfR to address this problem, including replacing lists in the CTL engine with s and hash tables.</p><h4>Semantic Patch Language (SmPL)</h4><p>While developing the parser for SmPL, we decided not to reinvent the wheel by writing a parser for the Rust language from scratch. SmPL contains custom syntax such as dots (), disjunctions, and modifiers ( and ). In the latest version, we parse only these constructs ourselves and hand off the rest to Rust Analyzer.</p><p>A  refers to a set of changes given an environment. Multiple rules can inherit values from one another to transform code in different parts of a file.</p><p>Used in SmPL as , ellipses connect two blocks of code:</p><pre><code>@@\nexpression q;\n@@\n\ndrop_queue(q);\n...\npop(q);\n</code></pre><p>This is implemented in CTL using the  term.</p><p>Disjunctions allow for conditional matching:</p><pre><code>f1(10);\n(   // &lt;--- disjunction start\nfoo(1);\n|\nbar(10);\n)   // &lt;--- disjunction end\nf2();\n</code></pre><p>Transforming macros posed a problem because of their non-standard nature. For example, should the following semantic patch match</p><pre><code>@@\nexpression e;\n@@\n\nfoo!(\n- e\n+ 2\n);\n</code></pre><p>To avoid discrepancies, we support only macros which look like function calls. For example,  or .</p><ol><li>Pretty Printing has been improved. The transformed code is formatted using  and it is then compared with the formatting from the original code. This way only the transformed code is formatted without messing up the original file formatting.  Pretty printing is still a work-in-progress for rust macros as they are notoriously hard to deal with and  thus leaves them alone.</li><li>Better tests have been added.</li><li>A more robust UI has been implemented, with various debugging flags.</li></ol><p>Our current aim is to bring Coccinelle For Rust at par with Coccinelle For C in terms of basic functionalities. In the following months we are going on to work on:</p><ul><li>Rule Dependance - It lets a rule run only if a condition is satisfied by the rules before it.</li><li>Scripting - Lets the user run arbitrary code for each match, allowing them to perform more things that are out of scope for now. This includes counting instances, matching with regex and performing other arbitrary operations.</li></ul><p>If you want to try out CoccinelleForRust it is available on <a href=\"https://gitlab.inria.fr/coccinelle/coccinelleforrust\" target=\"_blank\" rel=\"noopener\">Gitlab</a>. Please feel free to reach out to us at the email addresses on our website <a href=\"https://rust-for-linux.com/coccinelle-for-rust\" target=\"_blank\" rel=\"noopener\">CoccinelleForRust</a>, we would be happy to answer your questions!</p>","contentLength":6439,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1lkeyev/coccinelle_for_rust_progress_report/"}],"tags":["dev","reddit"]}