<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Crystal News Planet</title><link>https://planet.crystal-lang.org/</link><description>Liveboat RSS Feed</description><item><title>Kemal now uses a LRU Cache for Faster Routing Performance</title><link>https://old.reddit.com/r/crystal_programming/comments/1olhfag/kemal_now_uses_a_lru_cache_for_faster_routing/</link><author>/u/sdogruyol</author><category>community</category><pubDate>Sat, 1 Nov 2025 07:04:05 +0000</pubDate><source url="https://old.reddit.com/r/crystal_programming/">r/crystal_programming</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Annother Spinoff Shard: ralsina/rate_limiter</title><link>https://forum.crystal-lang.org/t/annother-spinoff-shard-ralsina-rate-limiter/8525</link><author>ralsina</author><category>community</category><pubDate>Fri, 31 Oct 2025 22:19:19 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I am sorry, I know I create a lot of topics all at once, but it happens when I actually have some time to work on my projects Basically, it’s a generic in-memory sliding window composible rate limiter. Usage looks like this:# Per user rate limiting
user_limiter = RateLimiter.new(50, 3600)  # 50 requests per hour per user

# Per IP rate limiting
ip_limiter = RateLimiter.new(200, 3600)  # 200 requests per hour per IP

# Per endpoint rate limiting
endpoint_limiter = RateLimiter.new(20, 60)  # 20 requests per minute per endpoint

# Per user + endpoint rate limiting
user_endpoint_limiter = RateLimiter.new(10, 60)  # 10 requests per minute per user+endpoint

# Check request (example: user trying to access API)
username = "alice"
ip = "10.0.0.1"
endpoint = "/api/create_note"

# Check all applicable rate limits
limits = [
  user_limiter.allow?(username),
  ip_limiter.allow?(ip),
  endpoint_limiter.allow?(endpoint),
  user_endpoint_limiter.allow?("#{username}::#{endpoint}")
]

if limits.any?
  # Request is allowed by all rate limiters
  process_request(username, ip, endpoint)
else
  # Request exceeds at least one rate limit
  render_error("Rate limit exceeded")
end
]]></content:encoded></item><item><title>Some performance testing</title><link>https://forum.crystal-lang.org/t/some-performance-testing/8524</link><author>ralsina</author><category>community</category><pubDate>Fri, 31 Oct 2025 20:04:30 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[As I worked on ToCry I got curious about how well it performed.It was  built with performance as the main goal. In fact it’s sort of guaranteed not to be the fastest way to do things. It uses sepia as data storage, which is the opposite of efficient, and I implemented it .On the other hand, the best thing was to just write some scripts and measure things!Turns out … it’s pretty fast? It can have about 20 simultaneous users and 300 RPS on a Pi 4 with 4GB of RAM, and industry standard says that equates to about 200 users.200 users? On an old SBC! This is not scientific. What a “realistic” load is needs to be discovered by having actual users :-)]]></content:encoded></item><item><title>Second fiber does not complete</title><link>https://forum.crystal-lang.org/t/second-fiber-does-not-complete/8523</link><author>axd99</author><category>community</category><pubDate>Fri, 31 Oct 2025 16:49:59 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[Hi, I am experimenting with crystal’s fibers and to test with a buffered channel I wrote this:# generate a list of file names.
# This is the data source.
list = [] of String
(1..4).each do |i|
  list << "file#{i}"
end

# provides communication between the producing fiber and the
# consuming one.
ch = Channel(String).new(3)

# fiber1
# this fiber loads the data into the channel
# This is the producer.
spawn do
  puts "--- Entering fiber1"
  list.each do |val|
    puts "fiber1, before send #{val}"
    ch.send val
    puts "fiber1, after send #{val}"
  end
  puts "--- Exiting fiber1"
end

# fiber2
# this fiber empties the channel
# This is the consumer.
spawn do
  puts "---- Entering fiber 2"
  while val2 = ch.receive
    puts "Received: #{val2}"
  end
  puts "---------------------"   # The code does not get to here
  puts "---- Exiting fiber2"
  puts "---------------------"
end

puts "Starting...\n"

# Start the fibers
Fiber.yield

# When the control gets back here all data has been exhausted.
puts "Goodbye!!!"

# shouldn't either of these 2 restart fiber2?
Fiber.yield
ch.close 
p ch.closed?


Now, when I run the above, all data is produced and consumed as expected.
However the ‘---- Exiting Fiber 2’ never executed.$ crystal list-files.cr
Starting...
--- Entering fiber1
fiber1, before send file1
fiber1, after send file1
fiber1, before send file2
fiber1, after send file2
fiber1, before send file3
fiber1, after send file3
fiber1, before send file4
---- Entering fiber 2
Received: file1
Received: file2
Received: file3
Received: file4
fiber1, after send file4
--- Exiting fiber1
Goodbye!!!
true
Any pointer would be most welcome.
Many thanks.]]></content:encoded></item><item><title>Wanna do an MCP? Try this :-)</title><link>https://forum.crystal-lang.org/t/wanna-do-an-mcp-try-this/8520</link><author>ralsina</author><category>community</category><pubDate>Wed, 29 Oct 2025 19:46:53 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[MCP is a mechanism to expose things to AI agents.Turns out it’s super easy to do, and it gives you some amazing leverage for tools! For example, I gave my kanban board a MCP server and now I can just say “move the note “whatever” to done” and it works ;-)It supports stdio MCP servers (nice way to expose a CLI tool to AI agents) and web MCP servers (with kemal at least)Here is a FULL example of a MCP with a single tool, in stdio mode:require "mcp"

# A simple tool that returns the answer to any question
class AnswerTool < MCP::AbstractTool
  @@tool_name = "get_answer"
  @@tool_description = "Returns 42 as the answer to any question you ask"
  @@tool_input_schema = {
    "type"       => "object",
    "properties" => {
      "question" => {
        "type"        => "string",
        "description" => "The question you want answered",
      },
    },
    "required" => ["question"],
  }.to_json

  def invoke(params : Hash(String, JSON::Any), env : HTTP::Server::Context? = nil)
    question = params["question"]?.try(&.as_s) || "unknown question"
    {
      "answer"   => 42,
      "question" => question,
    }
  end
end

# Start the stdio server - that's it! One line and you have a complete MCP server.
MCP::StdioHandler.start_server
Have fun and let me know if something is not ergnomic, I am trying to make this as boilerplate-free as possible.11 posts - 5 participants]]></content:encoded></item><item><title>Airsailer - open source Cloud orchestrator in Crystal</title><link>https://forum.crystal-lang.org/t/airsailer-open-source-cloud-orchestrator-in-crystal/8516</link><author>paulocoghi</author><category>community</category><pubDate>Wed, 29 Oct 2025 09:45:44 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[Missed you all during my cancer treatment, and I’m finally cancer-free!I’m back full-time at my cloud computing startup, and going fully open source (MIT license) for the entire platform.LXC (Linux/system containers) for bare-metal performance, no VM overhead (PoC working)elastic bare-metal hardware resources that can be changed without rebootelastic LVM storage with thin-provisioning (manually handled today)routing for local networks + WireGuard for clusters (manually handled today)Homogeneous deployment as the strategy for automatic horizontal scaling and load-balancing (will be on a future release with PaaS automation)automatic proxy + SSL for apps, no need for 1 public IP per app (proxy lib temporarily made in JS because of acme-client lib) IaaS+PaaS with 20% of features that cover 80% of cloud demand.I’m refactoring and I will release soon at github.com/airsailer/airsailer. Since I sustain my family only through this work, I expect to release a new production version soon.Happy to talk to you again. ]]></content:encoded></item><item><title>Crystal Prime Deluxe 18000 Box of 10</title><link>https://dev.to/crystalprimedeluxe18000boxof10/crystal-prime-deluxe-18000-box-of-10-5gkf</link><author>Crystal Prime Deluxe 18000 Box of 10</author><category>blog</category><pubDate>Tue, 28 Oct 2025 16:09:54 +0000</pubDate><source url="https://dev.to/t/crystal">DEV Community: crystal</source><content:encoded><![CDATA[VapeZone  offers premium vape products at competitive prices, based in the UK. Explore our wide range of high-quality vapes and accessories.]]></content:encoded></item><item><title>Inside an Isotemp OCXO107-10 Oven Controlled Crystal Oscillator</title><link>https://tomverbeure.github.io/2025/10/26/Inside-an-Isotemp-OCXO107-10.html</link><author>zdw</author><category>HN</category><category>hn</category><pubDate>Mon, 27 Oct 2025 21:35:46 +0000</pubDate><source url="https://news.ycombinator.com/newest">Hacker News - Newest: &quot;Crystal&quot;</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Create parsor for simple if statements</title><link>https://forum.crystal-lang.org/t/create-parsor-for-simple-if-statements/8514</link><author>Fulgurance</author><category>community</category><pubDate>Mon, 27 Oct 2025 17:18:02 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[Hi guys, I am seeking help/advice to make a very simple parser that use just  statement (I mean not with  statement or )I did already a condition parser that work, but I don’t know how to manage if there is multiple if.Basically, when my parser read a configuration file, I would like when it parse it to read the if statements:if (condition)
    if (condition)
        (do this)
    end
    if (condition)
        (do this)
    end
end
How can I manage this ? I tried to put the problem on paper, find a way, but I actually don’t really find a solution. If someone have experience already with this, I will be gratefulIn my example, if you are in the last condition, how can I know if I am not under the previous one ?]]></content:encoded></item><item><title>Inside An Isotemp Oven Controlled Crystal Oscillator</title><link>https://tomverbeure.github.io/2025/10/26/Inside-an-Isotemp-OCXO107-10.html</link><author>thomasjb</author><category>HN</category><category>hn</category><pubDate>Mon, 27 Oct 2025 10:17:24 +0000</pubDate><source url="https://news.ycombinator.com/newest">Hacker News - Newest: &quot;Crystal&quot;</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Cml and choose - type problems</title><link>https://forum.crystal-lang.org/t/cml-and-choose-type-problems/8509</link><author>dsisnero</author><category>community</category><pubDate>Sun, 26 Oct 2025 08:13:37 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[# =============================================================================
# Concurrent ML `choose` type inference problem in Crystal
# =============================================================================
#
# This document describes a real-world type inference limitation encountered
# when porting John Reppy’s Concurrent ML (CML) design to Crystal language.
#
# The CML model centers on *events* (values of type `Event(T)`), which represent
# potential synchronous communications or computations.  Multiple events can
# be combined using `choose_evt` (nondeterministic choice), and only one branch
# “commits” when synchronized via `sync(evt)`.
#
# The core invariant:  `choose` is purely a combinator; it doesn’t perform
# until `sync` is called.  This design works well in SML because its type
# inference engine easily unifies all branch result types, and events such as
# `timeout_evt` or `never_evt` can safely coexist in a single choice.
#
# In Crystal, we’re very close — but there’s a key *type inference barrier*:
#
# -----------------------------------------------------------------------------
# Problem Summary
# -----------------------------------------------------------------------------
#
# When combining heterogeneous `Event(T)` types in an `Array`, Crystal’s type
# inference produces a union of the *concrete generic instantiations* rather
# than a single polymorphic supertype.  This breaks overload resolution for a
# method like:
#
#     def self.choose(evts : Array(Event(T))) : Event(T) forall T
#
# Example:
#
#     ch = CML::Chan(Int32).new
#
#     choice = CML.choose([
#       CML.wrap(ch.recv_evt) { |_| :recv },              # Event(Symbol)
#       CML.wrap(CML.timeout(0.1.seconds)) { |_| :timeout }, # Event(Symbol)
#     ])
#
#     # ❌ Compiler error:
#     # expected Array(Event(Symbol)), not Array(Event(Symbol) | TimeoutEvt)
#
# Even though all branches *conceptually* yield `Symbol`, Crystal’s invariance
# and separate generic instantiations mean it cannot unify them automatically.
#
# In SML, this works because type inference is polymorphic by default:
#    val e1 : ’a event
#    val e2 : unit event
#    val choice = choose [wrap e1 (fn _ => #recv), wrap timeout_event (fn _ => #timeout)]
#
# -----------------------------------------------------------------------------
# Why `never` and `timeout` amplify the issue
# -----------------------------------------------------------------------------
#
# - `never_evt` is typed as `Event(T)` but never produces a value — it’s inert.
#   In ML, this freely unifies with anything (like `’a event`).
# - `timeout_evt` naturally yields a `Symbol` (`:timeout`) or unit.
#   In practice, most real `choose` calls race real events against a timeout.
#
# In Crystal, these must share a single `T` type parameter in
# `Array(Event(T))`, but the compiler cannot infer it when generics differ.
#
# -----------------------------------------------------------------------------
# Workarounds tried
# -----------------------------------------------------------------------------
#
# 1. Manual casting:
#
#        typed_never = CML.wrap(CML.never(Int32)) { |_| :never } as CML::Event(Symbol)
#        choice = CML.choose([typed_never,
#                             CML.wrap(ch.recv_evt) { |_| :recv },
#                             CML.wrap(CML.timeout(0.1.seconds)) { |_| :timeout }])
#
#    ✅ Works, but ugly and non-obvious for library users.
#
# 2. Force the array literal type explicitly:
#
#        choice = CML.choose([
#          CML.wrap(CML.never(Int32)) { |_| :never },
#          CML.wrap(ch.recv_evt) { |_| :recv },
#          CML.wrap(CML.timeout(0.1.seconds)) { |_| :timeout },
#        ] of CML::Event(Symbol))
#
#    ✅ Works, but verbose and not ergonomic.
#
# 3. A dynamic fallback (library side):
#
#        def self.choose_any(evts : Array(Event) | Tuple)
#          unified = evts.map do |e|
#            CML.wrap(e.as(Event)) { |x| x.as(Symbol | Nil | Int32 | String) }
#          end
#          ChooseEvt(Symbol | Nil | Int32 | String).new(unified)
#        end
#
#    ✅ Works, allows mixing `TimeoutEvt` and others.
#    ⚠️ Loses static type guarantees, since all results are widened into a big union.
#
# -----------------------------------------------------------------------------
# Desired behavior
# -----------------------------------------------------------------------------
#
# Ideally, Crystal could unify the type variable `T` across generic parameters
# of `Event(T)` when placed in an array, producing something like:
#
#     Array(Event(Symbol))  ← rather than  Array(Event(Symbol) | TimeoutEvt)
#
# That would allow:
#
#     choice = CML.choose([
#       CML.wrap(ch.recv_evt) { |_| :recv },
#       CML.wrap(CML.timeout(0.1.seconds)) { |_| :timeout },
#       CML.never(Int32)
#     ])
#     result = CML.sync(choice)
#
# to compile cleanly.
#
# -----------------------------------------------------------------------------
# Minimal Repro
# -----------------------------------------------------------------------------
#
# ```crystal
# module CML
#   abstract class Event(T); end
#
#   class TimeoutEvt < Event(Symbol); end
#   class RecvEvt(T) < Event(T); end
#
#   def self.choose(evts : Array(Event(T))) : Event(T) forall T
#     # no-op
#     evts.first
#   end
# end
#
# ch = CML::RecvEvt(Int32).new
# choice = CML.choose([ch, CML::TimeoutEvt.new])
# ```
#
# ❌ Error: expected argument #1 to 'choose' to be Array(Event(Int32)), not Array(Event(Int32) | CML::TimeoutEvt)
#
# -----------------------------------------------------------------------------
# Discussion questions for Crystal core / type system developers
# -----------------------------------------------------------------------------
#
# 1. Could Crystal’s generic unification rules be relaxed to allow
#    `Array(Event(Int32) | Event(Symbol))` to unify as `Array(Event(Int32 | Symbol))`
#    when the same generic base type is used?
#
# 2. Is there a way for a library to express a “variance-like” constraint
#    on generic parameters for this pattern — e.g., `Event` being covariant in `T`?
#
# 3. Would a macro-level solution (`macro choose_evt(*evts)`) be able to
#    introspect and compute a common union type of the block return values,
#    producing an `Array(Event(common_union_type))` automatically?
#
# 4. Is there any pattern or compiler hint (`.splat`, `typeof(...)`) that can
#    achieve this statically today without resorting to a huge union wrapper?
#
# -----------------------------------------------------------------------------
# The goal
# -----------------------------------------------------------------------------
#
# Bring Crystal’s ergonomics for typed event combinators closer to the
# Concurrent ML model:
#
#     choose [timeout_evt, recv_evt, never_evt] |> sync
#
# should “just work” without any explicit type coercion,
# while retaining static safety and type inference fidelity.
#
# -----------------------------------------------------------------------------
# Thank you!
# -----------------------------------------------------------------------------
#
# Any insight or future direction for generic covariance, inference improvements,
# or macro-based workarounds would be incredibly valuable for Crystal libraries
# that implement higher-level concurrency abstractions like Concurrent ML.
#
# -- Dominic Sisneros (dsisnero)
# -----------------------------------------------------------------------------

]]></content:encoded></item><item><title>Equivalent of Ruby&apos;s `self.class::Subclass`</title><link>https://forum.crystal-lang.org/t/equivalent-of-rubys-self-class-subclass/8508</link><author>Cristian</author><category>community</category><pubDate>Sat, 25 Oct 2025 21:08:32 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I would like to convert this Ruby code to Crystal:# Ruby code

class P
  class Sub
    def m
      "from P::Sub"
    end
  end
  
  def sub_m
    self.class::Sub.new.m
  end
end


class C < P
  class Sub
    def m
      "from C::Sub"
    end
  end
end


puts C.new.sub_m # => "from C::Sub"

By using ,  returns “from C::Sub” instead of “from P::Sub”, but this syntax is not valid in Crystal: Error: unexpected token: "::"17 posts - 7 participants]]></content:encoded></item><item><title>How can I force the type of a nested literal from the outside in?</title><link>https://forum.crystal-lang.org/t/how-can-i-force-the-type-of-a-nested-literal-from-the-outside-in/8507</link><author>Carlos</author><category>community</category><pubDate>Fri, 24 Oct 2025 18:58:28 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I want an array of , buticr:1> typeof([["str"], [:sym], ["str", :sym]])
 => Array(Array(String | Symbol) | Array(String) | Array(Symbol))
I can force the type of the inner arraysicr:2> typeof([["str"] of String | Symbol, [:sym] of String | Symbol, ["str", :sym]])
 => Array(Array(String | Symbol))
but I’d rather not do that, because that’s a lot of typing. I’d rather doicr:3> typeof([["str"], [:sym], ["str", :sym]] of Array(String | Symbol))
error in line 1
Error: instantiating 'Pointer(Array(String | Symbol))#[]=(Int32, Array(String))'


In C:\Users\carlo\scoop\apps\crystal\current\src\pointer.cr:146:29

 146 | (self + offset).value = value
                               ^----
Error: type must be Array(String | Symbol), not Array(String)
Shouldn’t the compiler propagate the type specification, not only from the inside out, but also from the outside in?]]></content:encoded></item><item><title>Feasibility of multi-executable architecture for a large application using Crystal</title><link>https://forum.crystal-lang.org/t/feasibility-of-multi-executable-architecture-for-a-large-application-using-crystal/8505</link><author>gauravshah89</author><category>community</category><pubDate>Thu, 23 Oct 2025 10:32:33 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[Crystal is my most-loved language  and I have been using it for small personal projects on and off. I am now starting a new project that may not remain personal in the long-run and should eventually grow on to become a large and complex desktop app. Run time performance will be a key requirement for this application.Since crystal has higher compile times compared to other languages, what is the best way to create very large and performant applications using crystal without getting bogged down by compile times?My Strategy  => Split the application into smaller  built from shared libraries rather than one monolithic Crystal binary. Rough proposed file structure given below: will be a standalone Crystal app/lib  () that compile quickly and will be linked to each other.common/
shard.yml         # shared library (types, utils)api/
shard.yml         # depends on ../commonworker/
shard.yml         # depends on ../commoncli/
shard.yml         # minimal dependenciesIs this a scalable approach for developing and maintaining serious production applications in Crystal? If this does not work out, I will have to use Rust which I don’t prefer.Thanks for reading this long question. ]]></content:encoded></item><item><title>A Closer Look at Piezoelectric Crystal</title><link>https://www.samaterials.com/content/a-closer-look-at-stressed-piezo-crystals.html</link><author>pillars</author><category>HN</category><category>hn</category><pubDate>Wed, 22 Oct 2025 16:12:16 +0000</pubDate><source url="https://news.ycombinator.com/newest">Hacker News - Newest: &quot;Crystal&quot;</source><content:encoded><![CDATA[
                        Last updated on {{lastDate}}                    ²]]></content:encoded></item><item><title>We&apos;re reaching for the stars! 🚀✨</title><link>https://fosstodon.org/@CrystalLanguage/115418209673688930</link><author></author><category>official</category><enclosure url="https://cdn.fosstodon.org/media_attachments/files/115/418/195/353/117/484/original/d2be7cb66f9956a5.png" length="" type="text/plain"/><pubDate>Wed, 22 Oct 2025 14:08:35 +0000</pubDate><source url="https://fosstodon.org/@CrystalLanguage">@CrystalLanguage</source><content:encoded><![CDATA[We're reaching for the stars! 🚀✨Just as 1.18 is released, over 20k users have starred the Crystal repo on GitHub 🌟]]></content:encoded></item><item><title>Crystal 1.18.2 is released!</title><link>https://forum.crystal-lang.org/t/crystal-1-18-2-is-released/8504</link><author>Crys</author><category>community</category><pubDate>Tue, 21 Oct 2025 20:20:55 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[We are announcing a new Crystal release 1.18.2 with two regressions fixed.]]></content:encoded></item><item><title>LSP implementation for Crystal on Windows</title><link>https://forum.crystal-lang.org/t/lsp-implementation-for-crystal-on-windows/8502</link><author>god</author><category>community</category><pubDate>Tue, 21 Oct 2025 12:02:42 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[The tooling for Crystal on Windows is not good. I am working on a language server and VSCode extension that leverages the existing CLI tools available and incorporates them into an instant-response context so as to achieve features such as autocomplete, real-time error detection, etc… on Windows, since Crystalline and Scry seem to be for POSIX platforms only.Demo of its current capabilities can be observed hereSource code is here, you can build the vsix for the vscode extension with “npm run package”, and the server itself with “shards build”.]]></content:encoded></item><item><title>Crystal 1.18.2 is released!</title><link>https://crystal-lang.org/2025/10/21/1.18.2-released/</link><author>Johannes Müller</author><category>releases</category><pubDate>Tue, 21 Oct 2025 00:00:00 +0000</pubDate><source url="https://crystal-lang.org/">Releases</source><content:encoded><![CDATA[We are announcing a new Crystal release 1.18.2 with two regressions fixed.This release includes 3 changes since
1.18.1
by 3 contributors.  We thank all the contributors for all the effort put into
improving the language! ❤️This patch release fixes a regression in the type restrictions of
 (#16231), and a bug in
Fiber::ExecutionContext.default_workers_count (#16227) - both errors were
introduced in 1.18.0.We have been able to do all of this thanks to the continued support of
 84codes and every other sponsor.  To
 maintain and increase the development pace, donations and sponsorships are
 essential.  OpenCollective is
 available for that.Reach out to crystal@manas.tech if you’d like to
 become a direct sponsor or find other ways to support Crystal. We thank you in
 advance!Contribute]]></content:encoded></item><item><title>Optimization for nillable var check and code</title><link>https://forum.crystal-lang.org/t/optimization-for-nillable-var-check-and-code/8501</link><author>AlexR</author><category>community</category><pubDate>Mon, 20 Oct 2025 22:57:22 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[Is there something terser than this:getter tex : LibSDL::Texture*?

def render
  tex = @tex
  return unless tex
  LibSDL.set_texture_alpha_mod(tex, 255)
  ...
end
Original code, rejected by the compiler, being :getter tex : LibSDL::Texture*?

def render
  LibSDL.set_texture_alpha_mod(@tex.as(LibSDL::texture*), 255) if @tex
  ...
end

# compilation error
# Error: can't cast (Pointer(LibSDL::Texture) | Nil) to Pointer(LibSDL::Texture)
]]></content:encoded></item><item><title>Crystal 1.18.1 is Released!</title><link>https://old.reddit.com/r/crystal_programming/comments/1obocwx/crystal_1181_is_released/</link><author>/u/Meatack</author><category>community</category><pubDate>Mon, 20 Oct 2025 17:32:54 +0000</pubDate><source url="https://old.reddit.com/r/crystal_programming/">r/crystal_programming</source><content:encoded><![CDATA[   submitted by    /u/Meatack ]]></content:encoded></item><item><title>From Raw Crystal to Crystal Oscillator – Crystals Go to War in 1943</title><link>https://www.youtube.com/watch?v=duZlWWwxIPQ</link><author>akshatjiwan</author><category>HN</category><category>hn</category><pubDate>Mon, 20 Oct 2025 17:05:02 +0000</pubDate><source url="https://news.ycombinator.com/newest">Hacker News - Newest: &quot;Crystal&quot;</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Check if an array index exist</title><link>https://forum.crystal-lang.org/t/check-if-an-array-index-exist/8500</link><author>Fulgurance</author><category>community</category><pubDate>Sun, 19 Oct 2025 20:19:25 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[Hi guys, I am actually coding a parser, and in my program I need to check if an index exist or not in the array. I did this, but when I try to run the code, crystal raise an error that my condition have  an index out of bound, why ?elsif Parser::ElseFilter.matches?(strippedLine)
    if !elsePresence[currentIfLevel-1].nil? && elsePresence[currentIfLevel-1] || elsePresence[currentIfLevel-1].nil?
        puts elsePresence.inspect
        puts currentIfLevel-1
        raise("Line #{index+1}\nFile: #{path}\nExtra else: #{line}\nAn extra \"else\" was declared.")
    end
Normally because I check if it is nil, I should not have problem with my condition no ?]]></content:encoded></item><item><title>Ruby controversy - Crystal opportunity</title><link>https://forum.crystal-lang.org/t/ruby-controversy-crystal-opportunity/8498</link><author>dsisnero</author><category>community</category><pubDate>Sat, 18 Oct 2025 17:41:06 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[@jgaskins With the recent controversy happening in ruby over Ruby Central and also DHH, it might be an opportunity for the more followed Crystal enthusiasts to re-introduce Crystal to the ruby world.10 posts - 6 participants]]></content:encoded></item><item><title>Creating a compiler package for Tumbleweed’s main repository (and potentially bootstrapping the compiler)</title><link>https://forum.crystal-lang.org/t/creating-a-compiler-package-for-tumbleweed-s-main-repository-and-potentially-bootstrapping-the-compiler/8497</link><author>expeehaa</author><category>community</category><pubDate>Sat, 18 Oct 2025 16:12:01 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I have been using openSUSE Tumbleweed for a few years now and am maintaining a small number of packages for that distribution. A few months ago I went the (probably) common route from Ruby to Crystal and have been quite happy with it. I thought about getting a Crystal compiler package into Tumbleweed’s main repository, which would have the great benefit of enabling getting packages of other programs written in Crystal into the main repository as well, apart from making the compiler install process easier.
I found the packages at https://build.opensuse.org/project/show/devel:languages:crystal but unfortunately they just extract a prebuilt binary, which, as far as I know, is not acceptable for Tumbleweed. Additionally, even though it is on the same build service and the name looks like it, it is not a devel project for Tumbleweed (which it would need to be to submit a package).Effectively, this means the following:Each compiler version package must be built from source.Either devel:languages:crystal needs to become a devel project for Tumbleweed, or a new project needs to be created. (The naming conflict would need to be solved, potentially together with the Tumbleweed maintainers.)The first point is especially interesting because, if I understand correctly, up until 1.0, each compiler version needs the previous version to compile. I see 2 solutions for this problem:Bootstrap a recent compiler from the old Ruby implementation.
Use a prebuilt binary to compile a recent compiler in the package build process, and base packages for the following versions on that.How this has to be handled depends on the Tumbleweed maintainers. Unfortunately, I haven’t received an answer through the appropriate Matrix and Discord channels, so I guess I have to try the mailing list next.For the second point, as per the openSUSE Wiki, it may be as easy as writing an email to a specific mailing list. One requirement is that the  group would become a maintainer of the project. (I don’t see this as an issue, just wanted to point it out in case someone else does.)I am not sure how both points would affect the package builds for other distributions. DPKG-based distributions could be completely unaffected, but RPM-based ones seem tricky. Their packages could also be built from source, but if that is not realistically possible for even a single one, the source-compiling Tumbleweed packages may need to be separate.
If it needs to be separate, I think a new subproject devel:languages:crystal:Factory would be most fitting, to not bother users of the existing project.I would be willing and (probably) able to do most if not all of the packaging work (apart from what I have no permissions for). With this post I want to get the thoughts of you Crystal compiler people on that topic in general, and specifically for the following questions:What do you think about having the Crystal compiler in Tumbleweed’s main repository?Is there a preference for changing existing package build instructions vs. having a new subproject specifically for Tumbleweed (with the option of building for openSUSE Leap as well)?If the compiler needs to be bootstrapped, would someone be able to support me a bit in debugging? (Outside of this thread, of course.)]]></content:encoded></item><item><title>We&apos;ve just released Crystal 1.18.1 - a small bugfix version that solves two regressions.</title><link>https://fosstodon.org/@CrystalLanguage/115391082654527812</link><author></author><category>official</category><pubDate>Fri, 17 Oct 2025 19:09:49 +0000</pubDate><source url="https://fosstodon.org/@CrystalLanguage">@CrystalLanguage</source><content:encoded><![CDATA[We've just released Crystal 1.18.1 - a small bugfix version that solves two regressions.]]></content:encoded></item><item><title>Crystal 1.18.1 is released!</title><link>https://forum.crystal-lang.org/t/crystal-1-18-1-is-released/8495</link><author>Crys</author><category>community</category><pubDate>Fri, 17 Oct 2025 18:53:57 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[We are announcing a new Crystal release 1.18.1 with two regressions fixed.]]></content:encoded></item><item><title>Crystal 1.18.1 is released!</title><link>https://crystal-lang.org/2025/10/17/1.18.1-released/</link><author>Matias Garcia Isaia</author><category>releases</category><pubDate>Fri, 17 Oct 2025 00:00:00 +0000</pubDate><source url="https://crystal-lang.org/">Releases</source><content:encoded><![CDATA[We are announcing a new Crystal release 1.18.1 with two regressions fixed.This release includes 2 changes since
1.18.0
by 1 contributor.  We thank all the contributors for all the effort put into
improving the language! ❤️This patch release fixes a regression in the  def parsing (#16217), and
overly strict type restrictions in  (#16218) - both introduced
in 1.18.0.We have been able to do all of this thanks to the continued support of
 84codes and every other sponsor.  To
 maintain and increase the development pace, donations and sponsorships are
 essential.  OpenCollective is
 available for that.Reach out to crystal@manas.tech if you’d like to
 become a direct sponsor or find other ways to support Crystal. We thank you in
 advance!Contribute]]></content:encoded></item><item><title>Reactions on issues and PRs</title><link>https://forum.crystal-lang.org/t/reactions-on-issues-and-prs/8490</link><author>straight-shoota</author><category>community</category><pubDate>Thu, 16 Oct 2025 20:31:29 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[Reactions on issues and PRs are helpful to gauge their importance.For example, the list of issues sorted by  reactions shows which issues people find relevant.
While that’s not the only metric to determine acceptance and prioritization of a change, it can help move important stuff further ahead.On the nix repository, I found this little detail: All PRs have a footer that encourages people to leave a reaction to show their interest in the topic.It’s not super important. Reactions work just fine without this encouragement.
But it’s less organized and can be messy considering there are a number of different reactions with different meanings.Maybe such a note could be useful. It reminds readers about leaving a reaction. And it points out the  reaction as a single metric.]]></content:encoded></item><item><title>Incremental static typechecking</title><link>https://forum.crystal-lang.org/t/incremental-static-typechecking/8485</link><author>boulme</author><category>community</category><pubDate>Thu, 16 Oct 2025 09:33:48 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I am quite a newbie to Crystal. On many aspects, I find that its design is very smart. But one thing really hurts me: its type-checking is not compositional. Let me detail this on the following example:def demo(c : Class) : Nil
  a = c.new()
  puts("demo on #{a.class}")
  (1..10).each {|x| a.push(x*x)}
  puts(a)
end

demo(Array(Int32))
demo(Array(Float64))
This program is well-typed. But, if we add the following line, it becomes ill-typed.And the type-checker declares an issue in the definition of  and not on the call with the issue.4 | (1..10).each {|x| a.push(x*x)}
^ to ‘Array(Bool)’ to be Bool, not Int32In all other strongly-type language that I know, type interfaces of methods/functions are contracts: their validity is checked on function definitions - and only the type interface is used for typing function calls : this makes type-checking compositional.This is not the case for Crystal. Type restrictions are not contract: they only restrict call contexts (and they are used as guards for multiple dispatch).Having a non-compositional type checking has huge consequences: this makes debugging harder, this makes incremental compilation impossible, which has itself other consequences, such as very slow compilation times, and poor interactions with LSP-server.It seems difficult to make Crystal type-checking compositional without loosing too much expressiveness. For example, on the above example we would need to make  a generic method over a type , such that  and . Including such constraints in the language and its type-checking seems really challenging. Such complex constraints might not be inferred and should be instead provided by programmers.Moreover, backward compatibility would be broken (which can be mitigated with a flag on the compiler). But, the benefits may worth the price of these difficulties ?14 posts - 6 participants]]></content:encoded></item><item><title>TIL: crystal-pg low performance with SSL</title><link>https://forum.crystal-lang.org/t/til-crystal-pg-low-performance-with-ssl/8484</link><author>sdogruyol</author><category>community</category><pubDate>Wed, 15 Oct 2025 14:43:26 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I wanted to share a recent experience I had with  that might be helpful for others.I’ve been benchmarking Crystal against Go and noticed that my Crystal implementation was performing 5-10 times slower than the Go version when running the same SQL query.My initial tests with SQLite showed comparable performance to Go, so the bottleneck was clearly with PostgreSQL. I spent a lot of time tweaking connection parameters (, , , etc.) and even tried compiling with , but nothing seemed to close the significant performance gap.On a whim, I added  to my connection string, and the results were instantaneous and dramatic. The performance shot up, bringing it nearly on par with the Go implementation.I haven’t had the chance to dig into why enabling SSL has such a massive performance impact with , but the difference is night and day.If you’re running into similar performance issues with PostgreSQL, I highly recommend giving this a try. It might just be the solution you’re looking for. I’d be curious to hear if anyone else has encountered this or has any insights into the cause.11 posts - 7 participants]]></content:encoded></item><item><title>Crystal 1.18.0 Is Released</title><link>https://crystal-lang.org/2025/10/14/1.18.0-released/</link><author>sdogruyol</author><category>HN</category><category>hn</category><pubDate>Wed, 15 Oct 2025 14:30:44 +0000</pubDate><source url="https://news.ycombinator.com/newest">Hacker News - Newest: &quot;Crystal&quot;</source><content:encoded><![CDATA[We are announcing a new Crystal release 1.18.0 with several new features and bug
fixes.This release includes 172 changes since
1.17.1
by 31 contributors. We thank all the contributors for all the effort put into
improving the language! ❤️Below we list the most remarkable changes in the language, compiler and stdlib.
For more details, visit the full
changelog.We do not expect any breaking changes in existing code. If you notice any
unexpected issues, please let us know in the issue tracker or forum.Execution contexts from RFC 0002 continue as a preview feature with opt-in
with compiler flags -Dpreview_mt -Dexecution_context. It might move out of
preview in the next release.The preview of synchronization primitives in  has seen some
improvements as well.Deprecation warnings are now available on types and aliases (#15962) as well
as individual method parameters (#15999).
Deprecated types only trigger warnings when they are actually  (e.g.
calling a class method), not when they’re just part of a type restriction, for
example.
Deprecated parameters only trigger a warning when the particular parameter is
used in a call. Calls without this parameter are unaffected.The format of  has been adjusted slightly to align with the Internet
Extended Date/Time Format (IXDTF) defined in RFC 9557 (#16039).Changes from the previous format:Replace  location by  offsetSkip zero nanoseconds entirely even when  is true (see https://github.com/crystal-lang/crystal/pull/16039#discussion_r2250863021)Remove whitespace between time and offsetWrap location in square brackets to indicate an IXDTF time-zone suffixSome examples show the differences:The local Windows system time zone now uses the canonical IANA name (#15967).The output of  got a wrapper to indicate
the  type and differentiate from the wrapped type (#15979).
The equivalent for  is still pending.The private constructors of  moved into the 
hook (#16147). They’re now defined on the including types which is more robust
in terms of  overload ordering. This also allows referring generic
type variables inside converters. now uses scoped ANSI reset codes which only reset the respective
property, instead of resetting  (#16052).We added type restrictions to many API methods. This improves the documentation.
This is a semi-automatic effort, assisted by a tool that automatically extracts
typing information from the semantic analysis of a program (#15682).Multi-line strings containing source code in compiler specs have had two
different formats: Some of them were using regular string literals, others used
heredocs. The latter was usually preferred in new code additions because
line numbers and indents are more sensible. And with an appropriate heredoc
identifier to denote the language, we even get nested syntax highlighting.
In this release we’ve converted all compiler specs to use heredocs
(#11291).With the help of , we’ve enabled and applied a couple more linter rules:
 (#16010),  (#16011), and
 (#16014).The compiler can dump type information to a JSON file when the environment
variable  is set (#16027).Resolve types when guessing return type from class method overloads (#16118).In the following snippet, the compiler is able to infer ’s type to be , since both overloads of  have a return type of :Guess instance variable types from global method calls (#16119).This allows the following to compile:The call needs to be global; other than that, type guessing for top-level methods has the same limitations as for class methods.Hash literals are evaluated from left to right, fixing a regression from 1.6.0 (#16124).Temporary variables are now grouped by file name in order to increase the chance
of reusing previous macro expansions (#16122).Fully exit the process on  from REPL (#16171)Fixed interpreter hanging on the signal pipe (#16167)Support for LLVM 21.1 and 22.0 (#16062)Update Unicode to 17.0.0 (#16160)We have been able to do all of this thanks to the continued support of
 84codes and every other sponsor.  To
 maintain and increase the development pace, donations and sponsorships are
 essential.  OpenCollective is
 available for that.Reach out to crystal@manas.tech if you’d like to
 become a direct sponsor or find other ways to support Crystal. We thank you in
 advance!Contribute]]></content:encoded></item><item><title>Crystal 1.18.0 is released!</title><link>https://old.reddit.com/r/crystal_programming/comments/1o7ckdv/crystal_1180_is_released/</link><author>/u/sdogruyol</author><category>community</category><pubDate>Wed, 15 Oct 2025 14:29:46 +0000</pubDate><source url="https://old.reddit.com/r/crystal_programming/">r/crystal_programming</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Division by Zero</title><link>https://forum.crystal-lang.org/t/division-by-zero/8483</link><author>Joerg</author><category>community</category><pubDate>Wed, 15 Oct 2025 12:16:50 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[def div
begin
rescue
pp "Division durch NULL ! "
endI have this little Program. I don’t understand why the rescue don’t work.Output for 20 / 0 is Infinity but not the pp “…”]]></content:encoded></item><item><title>Notes on Building CLI and GUI tools with Crystal</title><link>https://dev.to/kojix2/notes-on-building-cli-and-gui-tools-with-crystal-4pcd</link><author>kojix2</author><category>blog</category><pubDate>Wed, 15 Oct 2025 03:25:14 +0000</pubDate><source url="https://dev.to/t/crystal">DEV Community: crystal</source><content:encoded><![CDATA[This post is just me writing down some vague thoughts that are floating around in my head right now.Sorry if you came here expecting a well-structured tutorial — but you know, if I try to organize everything perfectly, I’ll never publish anything.Crystal originated from the Ruby community, so there are many people who want to build web applications with it.However, the Crystal programming language itself can be described as “a statically compiled language with a Ruby-like syntax and a garbage collector, somewhat like C with GC and type inference.”It’s not necessarily optimized for web applications.Personally, I wanted to use Crystal for command-line tools and GUI apps.For some reason, though, there don’t seem to be many people building CLI tools in Crystal.The ecosystem for building and distributing binaries wasn’t very well developed for a long time.That used to be a real pain, but after gradually solving those issues, I think we’re now at the point where most CLI tools I want can be built and distributed in Crystal without much trouble.On the GUI side, the situation is similar — there aren’t many libraries available.But this isn’t unique to Crystal. GUI programming, in general, depends heavily on opaque, platform-specific APIs, which don’t always play nicely with open-source development.Then I got curious about Tauri and Electron — the now-famous WebView-based app frameworks.Personally, I can barely read JavaScript, so I had no real interest in those at first, but their popularity made me curious.And as I mentioned earlier, web app development in the Crystal ecosystem is quite active.So I decided to give it a try.I learned that “WebView” isn’t a single library — each OS (Windows, Linux, macOS) provides its own.Projects like webview/webview and Tauri’s wry act as unifying layers over these platform-specific APIs.Tauri itself uses WebView under the hood while also providing a framework to handle security and integration with Rust backends.Maybe it’s possible to use TypeScript and other frontend tools with Crystal too, but personally, I prefer the more old-fashioned approach — something like Kemal + ECR, the “classic amateur” way.When I actually started building an app with Crystal + WebView, I discovered a few things.First, you need to pay attention to event loops and thread management.The WebView itself runs in a separate process, and at the same time you need to run a Kemal server.That means you often have to make it multithreaded and carefully manage your execution contexts or Fibers — otherwise, things simply won’t run correctly.Then there’s the build, linking, and packaging pain.I sent a few pull requests to the Crystal WebView project, which helped a bit, but building on MinGW is still rough.MSVC technically works, but it’s just too tedious to deal with, so I decided to stay away from it.Bundling shared libraries is also tricky.I’d prefer to lean toward static linking whenever possible, but depending on licensing and security update concerns, it’s sometimes better to link against system or bundled shared libraries.I discovered tools like fpm, which are really useful, but in the end, I still end up asking AI to help me write custom GitHub Actions YAML and shell scripts.And then, once you finally have a working binary, Windows or macOS antivirus software will happily flag it as suspicious.Maybe for people doing this professionally, all this doesn’t sound like a big deal, but as someone doing it for fun, it’s a lot of work.
Even so, after all the pain, I’ve started to feel like — maybe, just maybe — this setup is actually pretty cool.This post was translated from the original Japanese version using ChatGPT.
You can read the original post here [JA]]]></content:encoded></item><item><title>Extra, extra - Crystal 1.18.0 is out now!</title><link>https://fosstodon.org/@CrystalLanguage/115374378935720511</link><author></author><category>official</category><pubDate>Tue, 14 Oct 2025 20:21:51 +0000</pubDate><source url="https://fosstodon.org/@CrystalLanguage">@CrystalLanguage</source><content:encoded><![CDATA[Extra, extra - Crystal 1.18.0 is out now!]]></content:encoded></item><item><title>Crystal 1.18.0 is released!</title><link>https://forum.crystal-lang.org/t/crystal-1-18-0-is-released/8478</link><author>Crys</author><category>community</category><pubDate>Tue, 14 Oct 2025 20:10:46 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[We are announcing a new Crystal release 1.18.0 with several new features and bug
fixes.]]></content:encoded></item><item><title>How a quartz crystal works in a microcontroller?</title><link>https://dev.to/carolineee/how-a-quartz-crystal-works-in-a-microcontroller-4lhf</link><author>Hedy</author><category>blog</category><pubDate>Tue, 14 Oct 2025 09:37:43 +0000</pubDate><source url="https://dev.to/t/crystal">DEV Community: crystal</source><content:encoded><![CDATA[This is a fundamental concept in microcontroller systems. Let's break down how a quartz crystal works in a microcontroller, from the basic physics to the practical circuit.The Core Concept: The Piezoelectric Effect
At the heart of a quartz crystal is a physical phenomenon called the Piezoelectric Effect.Mechanical → Electrical: When you apply a physical stress (squeeze or bend) to a quartz crystal, it generates a small electrical voltage across its surfaces.Electrical → Mechanical: Conversely, when you apply an electrical voltage to a quartz crystal, it physically deforms (vibrates) slightly.This two-way street is the magic key.How It Creates a Clock Signal: ResonanceNatural Frequency: Every piece of quartz crystal has a natural resonant frequency—a specific frequency at which it "likes" to vibrate most efficiently. This frequency is determined primarily by its physical size, shape, and how it's cut. A thinner, smaller crystal vibrates at a higher frequency. This is why crystals for common microcontrollers (like 16 MHz, 20 MHz) are small, while crystals for real-time clocks (32.768 kHz) are larger and often cylindrical.The Oscillator Circuit: Inside the microcontroller, there is a specialized circuit called a Crystal Oscillator (often denoted as OSC1 and OSC2 pins). This circuit is designed to:Apply a constantly alternating voltage to the crystal.Listen to the tiny voltage generated by the crystal's vibration.Amplify that signal and feed it back to the crystal.The Self-Sustaining Loop (The "How It Works"):When you power on the circuit, electrical noise provides a tiny, random voltage kick to the crystal.The crystal vibrates in response, generating a tiny voltage at its natural resonant frequency.The oscillator circuit in the microcontroller picks up this tiny signal, amplifies it, and feeds it back to the crystal.This reinforced signal causes the crystal to vibrate more strongly.Within a few milliseconds, this feedback loop builds up into a strong, continuous, and perfectly stable oscillation at the crystal's precise natural frequency.The result is a clean, square-wave clock signal that drives the entire microcontroller.The Complete Picture: The Practical Circuit
On your schematic and PCB, you don't just connect the crystal directly to the MCU. A typical crystal circuit looks like this:text

         ---||---       ---||---
OSC1 |---|     |---X---|     |---| OSC2
     |    C1        |        C2   |
     |              |             |
     |-------------/ \------------|
                   Rf (Internal)
Illustration of a typical crystal oscillator circuitComponents and Their Roles:Quartz Crystal (X): The resonant element that sets the frequency.Load Capacitors (C1 and C2): These are absolutely critical.Purpose: They, along with the crystal's own internal capacitance, form a capacitive load that helps the crystal oscillate at its specified frequency.Value: The values (typically 10-22 pF for most MCUs) are chosen to match the crystal's specified load capacitance. Using the wrong values can make the oscillator unstable or cause the frequency to be slightly off.Internal Oscillator Circuit (inside MCU): Contains the amplifier and a feedback resistor (Rf), which biases the amplifier into its linear region so it can start and maintain oscillation.Why is the Clock Signal So Important?
The clock signal is the "heartbeat" of the microcontroller. It synchronizes every operation:Core Execution: The CPU executes instructions in time with the clock ticks (each tick is one clock cycle).Peripheral Timing: Timers, PWM (Pulse Width Modulation), and communication interfaces like UART, SPI, and I2C all rely on the clock to generate precise baud rates and time intervals.Bus Operations: Reading from Flash memory, writing to RAM, and accessing peripherals are all coordinated by the clock.A simple analogy: Imagine an orchestra without a conductor. It would be chaotic. The crystal-generated clock signal is the conductor, ensuring every part of the microcontroller works in perfect synchrony.The Special 32.768 kHz "Watch Crystal"
You often see a second, smaller crystal on boards (shaped like a tiny can). This is almost always a 32.768 kHz crystal.Why that number? 32,768 = 2¹⁵.A simple 15-stage binary divider circuit can easily divide this frequency down to exactly 1 Hz (one pulse per second), which is perfect for driving a Real-Time Clock (RTC) to keep track of time, even when the main microcontroller is in sleep mode.It's a resonator: The quartz crystal doesn't create a frequency out of nothing; it filters and stabilizes the oscillation to its precise natural frequency.Piezoelectric Effect is key: The mechanical-electrical feedback loop is what makes it work.It's a system: The crystal alone won't work. It needs the microcontroller's internal oscillator circuit and the external load capacitors to form a complete, functioning oscillator.Precision and Stability: Compared to internal RC oscillators, crystals are vastly more accurate and stable over temperature and voltage changes, which is essential for timing-critical applications and communication protocols.]]></content:encoded></item><item><title>Add value in empty array at specific index</title><link>https://forum.crystal-lang.org/t/add-value-in-empty-array-at-specific-index/8477</link><author>Fulgurance</author><category>community</category><pubDate>Tue, 14 Oct 2025 09:23:45 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[Hi guys, I have a special request. I would like basically to add a value in an  array at a specific index, and if this index is out of bound (because it is empty), instead of having an error, fill up the array with empty values.BUT if I the array is not empty, don’t overwrite the existing values, just fill the gap with empty values. Let me know if it is not clear.This is an example of what I would like:array is an empty array of string
We add "hello" to the index 2

=> ["","","hello"]

Now we change the value of index 1 with "bye"

=> ["","bye","hello"]

Now we had again another value at index 5, with value "good"

=> ["","bye","hello","","","good"]
Basically this example show the behavior I would like.Is there any method for this ?]]></content:encoded></item><item><title>Crystal 1.18.0 is released!</title><link>https://crystal-lang.org/2025/10/14/1.18.0-released/</link><author>Johannes Müller</author><category>releases</category><pubDate>Tue, 14 Oct 2025 00:00:00 +0000</pubDate><source url="https://crystal-lang.org/">Releases</source><content:encoded><![CDATA[We are announcing a new Crystal release 1.18.0 with several new features and bug
fixes.This release includes 172 changes since
1.17.1
by 31 contributors. We thank all the contributors for all the effort put into
improving the language! ❤️Below we list the most remarkable changes in the language, compiler and stdlib.
For more details, visit the full
changelog.We do not expect any breaking changes in existing code. If you notice any
unexpected issues, please let us know in the issue tracker or forum.Execution contexts from RFC 0002 continue as a preview feature with opt-in
with compiler flags -Dpreview_mt -Dexecution_context. It might move out of
preview in the next release.The preview of synchronization primitives in  has seen some
improvements as well.Deprecation warnings are now available on types and aliases (#15962) as well
as individual method parameters (#15999).
Deprecated types only trigger warnings when they are actually  (e.g.
calling a class method), not when they’re just part of a type restriction, for
example.
Deprecated parameters only trigger a warning when the particular parameter is
used in a call. Calls without this parameter are unaffected.The format of  has been adjusted slightly to align with the Internet
Extended Date/Time Format (IXDTF) defined in RFC 9557 (#16039).Changes from the previous format:Replace  location by  offsetSkip zero nanoseconds entirely even when  is true (see https://github.com/crystal-lang/crystal/pull/16039#discussion_r2250863021)Remove whitespace between time and offsetWrap location in square brackets to indicate an IXDTF time-zone suffixSome examples show the differences:The local Windows system time zone now uses the canonical IANA name (#15967).The output of  got a wrapper to indicate
the  type and differentiate from the wrapped type (#15979).
The equivalent for  is still pending.The private constructors of  moved into the 
hook (#16147). They’re now defined on the including types which is more robust
in terms of  overload ordering. This also allows referring generic
type variables inside converters. now uses scoped ANSI reset codes which only reset the respective
property, instead of resetting  (#16052).We added type restrictions to many API methods. This improves the documentation.
This is a semi-automatic effort, assisted by a tool that automatically extracts
typing information from the semantic analysis of a program (#15682).Multi-line strings containing source code in compiler specs have had two
different formats: Some of them were using regular string literals, others used
heredocs. The latter was usually preferred in new code additions because
line numbers and indents are more sensible. And with an appropriate heredoc
identifier to denote the language, we even get nested syntax highlighting.
In this release we’ve converted all compiler specs to use heredocs
(#11291).With the help of , we’ve enabled and applied a couple more linter rules:
 (#16010),  (#16011), and
 (#16014).The compiler can dump type information to a JSON file when the environment
variable  is set (#16027).Resolve types when guessing return type from class method overloads (#16118).In the following snippet, the compiler is able to infer ’s type to be , since both overloads of  have a return type of :Guess instance variable types from global method calls (#16119).This allows the following to compile:The call needs to be global; other than that, type guessing for top-level methods has the same limitations as for class methods.Hash literals are evaluated from left to right, fixing a regression from 1.6.0 (#16124).Temporary variables are now grouped by file name in order to increase the chance
of reusing previous macro expansions (#16122).Fully exit the process on  from REPL (#16171)Fixed interpreter hanging on the signal pipe (#16167)Support for LLVM 21.1 and 22.0 (#16062)Update Unicode to 17.0.0 (#16160)We have been able to do all of this thanks to the continued support of
 84codes and every other sponsor.  To
 maintain and increase the development pace, donations and sponsorships are
 essential.  OpenCollective is
 available for that.Reach out to crystal@manas.tech if you’d like to
 become a direct sponsor or find other ways to support Crystal. We thank you in
 advance!Contribute]]></content:encoded></item><item><title>Assignments to structs fields in array are not working</title><link>https://forum.crystal-lang.org/t/assignments-to-structs-fields-in-array-are-not-working/8476</link><author>mentalblood</author><category>community</category><pubDate>Sun, 12 Oct 2025 15:56:27 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[require "spec"

struct S
  property x : Int32

  def initialize(@x)
  end
end

begin
  s = S.new 0
  s.x = 1
  s.x.should eq 1 # OK
end

begin
  a = [] of S
  a << S.new 0

  a[0].x = 1
  a[0].x.should eq 1 # still 0
end
]]></content:encoded></item><item><title>Passing method as Proc to other class constuctor?</title><link>https://forum.crystal-lang.org/t/passing-method-as-proc-to-other-class-constuctor/8469</link><author>AlexR</author><category>community</category><pubDate>Sat, 11 Oct 2025 05:34:17 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[This works but is ->(w : Widget) { upd_lighttable(w) } (in ) idiomatic?abstract class Widget
  abstract def update
  abstract def render
end

abstract class UI
  def initialize()
    @widgets = Array(Widget).new
    assemble
  end

  abstract def assemble

  def update()
    @widgets.each do |w|
      w.update
    end
  end

  def render()
    @widgets.each do |w|
      w.render
    end
  end
end

class LabelWidget < Widget
  def initialize(@text : String, @x : Int32, @y : Int32, @handler : Proc(Widget, Nil))
  end

  def update()
    @handler.call(self)
  end

  def render()
    puts "todo: #{@text} LabelWidget.render"
  end
end

class MyAppUI < UI
  def assemble()
    @widgets.push(LabelWidget.new(" L ", 5,  5, ->(w : Widget) { upd_lighttable(w) }))
    @widgets.push(LabelWidget.new(" P ", 5, 50, ->(w : Widget) { upd_play_from_previous(w) }))
  end

  def upd_lighttable(w : Widget)
    puts "todo: upd_lighttable"
  end

  def upd_play_from_previous(w : Widget)
    puts "todo: upd_play_from_previous"
  end
end




ui = MyAppUI.new
ui.update
ui.render
# =>
# todo: upd_lighttable
# todo: upd_play_from_previous
# todo:  L  LabelWidget.render
# todo:  P  LabelWidget.render

]]></content:encoded></item><item><title>Seeking a reference to an object property</title><link>https://forum.crystal-lang.org/t/seeking-a-reference-to-an-object-property/8468</link><author>AlexR</author><category>community</category><pubDate>Fri, 10 Oct 2025 23:03:10 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[How do you, in an instance method, parametrize a reference to the property of an instance of some other class (as opposed to its value) ? The question came as I wrote the code below (putting Observer pattern into place but am having declaration issues;  needs fixing, obviously) and I can’t quite put my finger on the idiomatic way to do this.class A
  include Observable
  getter some_prop : Bool = false
end

class B
  include Observer
  def observe(prop : Pointer(T))
    # todo
  end
end

a = A.new
b = B.new
b.observe(pointerof(a.some_prop))
]]></content:encoded></item><item><title>Problem when splitting string with regex</title><link>https://forum.crystal-lang.org/t/problem-when-splitting-string-with-regex/8467</link><author>Fulgurance</author><category>community</category><pubDate>Fri, 10 Oct 2025 12:00:57 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[Hi guys, I am facing a problem when I try to split a string with a regex. Basically I would like to split everytime the regex meet: “ && “, “ || “ or “if “.I did this example but the result is not as expected:string = "if adad = 2 && adada = 3 || 2 = 3"
array = string.split(/((if\s+)|(\s+\|\|\s+)|(\s+\&\&\s+))/)

puts array.inspect
["", "if ", "if ", "adad = 2", " && ", " && ", "adada = 3", " || ", " || ", "2 = 3"]
["adad = 2", "adada = 3", "2 = 3"]
I have a second question too: is it possible to split a string without deleting the chaine that split ?]]></content:encoded></item><item><title>Trouble running multiple infinite loops (GTK + X11 + Signal listener) in parallel in Crystal</title><link>https://forum.crystal-lang.org/t/trouble-running-multiple-infinite-loops-gtk-x11-signal-listener-in-parallel-in-crystal/8466</link><author>VC365</author><category>community</category><pubDate>Fri, 10 Oct 2025 06:06:06 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I have an applet originally written in C, and after learning Crystal I decided to rewrite it.
Everything went fine until I reached the part that needs multiple infinite loops running in parallel.In the original C version I had three concurrent loops:A signal listener ()When I tried to do the same in Crystal, the program either froze, lagged, or crashed depending on which threading method I used.def keys
  Xlib.call do
    xInitThreads()
    dpy = xOpenDisplay(nil)
    unless dpy
      STDERR.puts("Cannot open display")
      return
    end
    root = xRootWindow(dpy, 0)

    xGrabKey(dpy, xKeysymToKeycode(dpy, X11::XF86XK_AudioLowerVolume),
             X11::AnyModifier, root, 1, X11::GrabModeAsync, X11::GrabModeAsync)
    xGrabKey(dpy, xKeysymToKeycode(dpy, X11::XF86XK_AudioRaiseVolume),
             X11::AnyModifier, root, 1, X11::GrabModeAsync, X11::GrabModeAsync)
    xGrabKey(dpy, xKeysymToKeycode(dpy, X11::XF86XK_AudioMute),
             X11::AnyModifier, root, 1, X11::GrabModeAsync, X11::GrabModeAsync)

    xSelectInput(dpy, root, X11::KeyPressMask)
    ev = uninitialized LRoot::XEvent

    loop do
      xNextEvent(dpy, pointerof(ev))
      if ev.type == X11::KeyPress
        keysym = xKeycodeToKeysym(dpy, ev.key.keycode, 0)
        case keysym
        when X11::XF86XK_AudioRaiseVolume
          Volume.volume_up
          Volume.update_safe(true)
        when X11::XF86XK_AudioLowerVolume
          Volume.volume_down
          Volume.update_safe(true)
        when X11::XF86XK_AudioMute
          Volume.volume_mute
          Volume.update_safe(false)
        end
      end
    end
  end
end
private def pid; "/tmp/volume-pulse.pid"; end

def signal_root
  File.write(pid, "#{Process.pid}")
  Signal::USR1.trap { Volume.update_safe(true) }
  sleep
end

def signal_update
  return unless File.exists?(pid)
  Process.signal(Signal::USR1, File.read(pid).to_i)
end
Xlib.call do
  notify("Volume Pulse") if ConfigVariables.use_notifications
  fcInit()
  gtk2_init(nil, nil)

  icon_tray = gtk2_status_new()
  Volume.icon_statusX do |volume|
    Xlib.call do
      if Volume.get_mute
        gtk2_status_icon_tooltip_text(icon_tray, "Volume: Muted")
        gtk2_status_set_icon_name(icon_tray, "audio-volume-muted")
      else
        gtk2_status_icon_tooltip_text(icon_tray, "Volume: #{volume}")
        case volume
        when 0
          gtk2_status_set_icon_name(icon_tray, "audio-volume-muted")
        when 1..30
          gtk2_status_set_icon_name(icon_tray, "audio-volume-low")
        when 31..70
          gtk2_status_set_icon_name(icon_tray, "audio-volume-medium")
        else
          gtk2_status_set_icon_name(icon_tray, "audio-volume-high")
        end
      end
    end
  end

  Volume.update

  g_signal_connect(icon_tray.as(LRoot::GObject*), "scroll-event", Event.scroll.as(LRoot::GCallback*), nil)
  g_signal_connect(icon_tray.as(LRoot::GObject*), "button-press-event", Event.button.as(LRoot::GCallback*), nil)
  g_signal_connect(icon_tray.as(LRoot::GObject*), "popup-menu", GUI.menu.as(LRoot::GCallback*), nil)

  gtk2_main()
  notify_uninit() if ConfigVariables.use_notifications
end
 and  — both cause freezing or crashes and  (with ) — sometimes only part of the signals are received, or it crashes after a short time, or one of the loops stops running completelyIf I remove the GTK loop, everything works fine.
But as soon as I call , all other threads or fibers stop responding.Is there a reliable way to run multiple native event loops (GTK, X11, signal listener) in true parallel execution in Crystal?
Or should I move one of these loops (for example the X11 listener) into a small C helper process instead? Crystal 1.17.1 (2025-07-22) Artix Linux (Openrc) 20.1.8 x86_64-pc-linux-gnu]]></content:encoded></item><item><title>Channels</title><link>https://forum.crystal-lang.org/t/channels/8465</link><author>jgaskins</author><category>community</category><pubDate>Thu, 9 Oct 2025 14:26:28 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I’ve been thinking lately about how the Crystal and Go ecosystems use channels as I work with things in Crystal that are commonly done with Go (such as infrastructure and NATS). One thing that I find surprising is that channels are often part of the interface for a Go API but, from what I can tell, Crystal s tend to be implementation details that aren’t exposed.Does that match anyone else’s observations?18 posts - 6 participants]]></content:encoded></item><item><title>Crystal docs - crystal src errors</title><link>https://forum.crystal-lang.org/t/crystal-docs-crystal-src-errors/8463</link><author>dsisnero</author><category>community</category><pubDate>Thu, 9 Oct 2025 07:48:40 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[when I try to run crystal docs from crystal src directory it errors]]></content:encoded></item><item><title>Announcing Lustra: a Postgres ORM for Crystal</title><link>https://dev.to/mamantoha/announcing-lustra-a-postgres-orm-for-crystal-2pdm</link><author>Anton Maminov</author><category>blog</category><pubDate>Mon, 6 Oct 2025 16:39:52 +0000</pubDate><source url="https://dev.to/t/crystal">DEV Community: crystal</source><content:encoded><![CDATA[ Lustra started as a fork of Clear at version 0.8, and it is not compatible with later Clear releases. Over time it evolved into an independent project. To keep it compatible with newer Crystal versions, I continued development, added missing features, improved existing ones, and expanded test coverage. Today Lustra stands as its own project.When I started building shards.info, I had to make an important choice: which ORM to use with Crystal. Coming from a , I was naturally looking for something similar to  — straightforward, feature-rich, and reliable. I reviewed several options available at the time: Jennifer, Crecto, Granite, and Clear. After evaluating them, I chose . At the time, it was the most advanced ORM in the Crystal ecosystem. Even though it has been limited to Postgres support, I didn’t plan to use other databases, so this limitation was never a drawback for me.Clear later introduced a new major version with substantial API and behavior changes. Some of those changes (and a few bugs at the time) broke previously working code in my project. My system was already running smoothly, and I wasn’t ready to trade stability for churn.To keep my project alive -  I forked it. That fork is now . is an ORM built specifically for PostgreSQL in Crystal, maintained independently.
It aims to provide a stable, reliable, and Crystal-compatible ORM for Postgres database.: Associations, query builder, type safety - the same qualities that originally attracted me to Clear.: I don’t plan to change the API in the future, so existing projects can rely on consistent behavior.: I’ve ensured compatibility with new Crystal versions, added , and expanded .Why “Lustra”?
Because the word means  in several languages. To me, a chandelier looks like a database schema: a structured network of connections. It also carries the idea of  and .Working on Lustra started as a practical need to keep my project running. Over time, it became an opportunity to explore Crystal and ORM internals more deeply. Lustra represents my preference for tools that are stable and predictable. Maintaining it has also shown me how consistent effort can turn a fork into an independent project.Lustra will continue as a  for Crystal developers.If you’re looking for a dependable ORM for your Crystal projects, give Lustra a try.]]></content:encoded></item><item><title>Wind of change (or maybe not) [Crystal&apos;s change of leadership]</title><link>https://old.reddit.com/r/crystal_programming/comments/1nu4z5m/wind_of_change_or_maybe_not_crystals_change_of/</link><author>/u/stanbright</author><category>community</category><pubDate>Tue, 30 Sep 2025 05:35:02 +0000</pubDate><source url="https://old.reddit.com/r/crystal_programming/">r/crystal_programming</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Wind of change (or maybe not)</title><link>https://crystal-lang.org/2025/09/29/wind-of-change/</link><author>Beta Ziliani</author><category>official</category><pubDate>Mon, 29 Sep 2025 00:00:00 +0000</pubDate><source url="https://crystal-lang.org/">Crystal Blog</source><content:encoded><![CDATA[My time at Manas is coming to an end, though I will remain a Core Team member and continue to help develop the project from that seat. Johannes (@straight-shoota) will be taking on the leading role of the project. Please join me in congratulating him on his new position!While this might sound like a big change, in reality it isn’t: over the past year I’ve already been a bit distant from the project due to Manas’ own dynamics. Yet, Johannes and Julien have kept this tight ship on course, with just a bit of extra help. In essence, Johannes has already been a de facto leader.As for myself, I will be leading the Theory of Computation group at ORT University, returning to my other passions: teaching and research. Who knows, maybe I will finally get to do some cool research in Crystal!This change marks the end of an amazing journey that began four years ago, leading an equally amazing group of people; building this amazing language we all love. I’m deeply grateful to Manas, the Core Team, and the Crystal community at large. The learnings that I gather will accompany me for the rest of my life. You’re wonderful!]]></content:encoded></item><item><title>libui and Garbage Collection - Challenges in Creating Ruby and Crystal Bindings</title><link>https://dev.to/kojix2/libui-and-garbage-collection-challenges-in-creating-ruby-and-crystal-bindings-9m6</link><author>kojix2</author><category>blog</category><pubDate>Fri, 26 Sep 2025 02:15:46 +0000</pubDate><source url="https://dev.to/t/crystal">DEV Community: crystal</source><content:encoded><![CDATA[libui is a GUI library that supports the three major operating systems: Windows, macOS, and Linux (currently, the successor project is libui-ng). Internally, it contains three different libraries that call native APIs, unified under a single  header file to provide similar UI functionality across all operating systems. It can also be easily used from other languages through FFI (Foreign Function Interface). While development has slowed somewhat recently, there are few similar libraries available, and libui continues to maintain its unique value.I have been creating Ruby bindings and Crystal bindings for libui. Through this process, I have come to realize how difficult it is to combine libui with garbage collection.
  
  
  The Problem of Disappearing Controls and Callback Functions
Creating Ruby or Crystal bindings for libui is not particularly difficult. The work of checking function signatures and writing matching low-level bindings can be done mechanically.However, when you call these low-level APIs to create simple applications, the following problems occur with a certain probability:Controls disappear and memory access violations occurCallbacks disappear and memory access violations occurBoth Ruby and Crystal are languages that use garbage collection (GC), so memory that is determined to be unused gets reclaimed. As a result, pointers and callback functions that should be used in the future by the GUI main loop are mistakenly freed by the GC.In GC languages, the timing of memory deallocation is controlled indirectly through references.In Ruby, callback functions are unconditionally stored in a dedicated array. This effectively creates a memory leak (old callbacks remain in the array even after new ones are added), but since callback functions are usually finite in number in GUI applications, this is not a practical problem.Crystal uses a more complex management approach. Each callback function is tied to the instance of its related control. For example, a callback function that fires when a button is pressed is owned by that button. Additionally, the nested relationships of controls themselves are reproduced as an ownership tree. For example, a Window contains a Box, and the Box holds a Label and Button.By using this ownership tree, we can significantly reduce the problem of incorrect collection by the GC.By the way, why does Crystal's GC collect pointers even though controls may be referenced later in the main loop? I don't have a clear understanding of this point, but it's possible that memory tracking becomes difficult when closures are boxed.
  
  
  libui's Memory Management Rules
libui is a C library designed for users to manage memory themselves. However, in practice, it introduces a mechanism where "when a parent control is freed, the memory of child controls is also freed." The controls that can be parent controls are Window, Box, Grid, Group, Tab, and Form.When you  these, child controls are freed first, then the parent itself is freed. Therefore, in actual operation, you often free child controls collectively by destroying the Window.The problem is that on the Crystal side, we cannot detect such deallocation within native libraries. NULL checks might help us guess immediately after memory deallocation (libui sets pointers to NULL before deallocation), but this is unreliable.Window deallocation can happen automatically. When the [x] button in the Window's title bar is clicked, a callback function is triggered by , and if the return value is true, the Window's destroy is automatically triggered.In contrast,  triggered from the Quit option in the menu bar represents application termination, so it does not automatically trigger destroy for the window. The user must destroy the Window themselves and call uiQuit.
  
  
  libui's Memory Leak Detection Mechanism
libui has a built-in mechanism for detecting memory leaks. This is a very useful feature, but it often doesn't work well with GC languages. This is because in GC, the timing of memory deallocation is indefinite, and we cannot guarantee that all memory has been freed at the time of checking. Therefore, implementations that hook into GC's  to perform deallocation should be avoided.
  
  
  Table Deallocation Procedure
Table is based on Model-View architecture, with TableModel and Table separated. A TableModel can only be freed after all Tables using that model have been destroyed. Therefore, the deallocation procedure is as follows:Remove the Table from its parent controlExplicitly destroy the TableFinally destroy the TableModel
  
  
  Area Deallocation Procedure
Unlike Table, Area can be handled by simply destroying the control.
  
  
  MultilineEntry Deallocation Procedure
While detailed investigation of the cause is still in progress, on macOS there appear to be cases where problems occur unless you remove it from the parent control and destroy it individually, similar to Table.When using libui (libui-ng), there are many important considerations regarding memory management, especially deallocation.In languages that use garbage collection like Crystal and Ruby, you normally don't need to worry about memory. Even with C language bindings, manual memory management often becomes unnecessary by using deallocation callback functions like .However, I learned that with libraries like GUI libraries that have interactive operations where timing and synchronization are important, there are cases where you cannot rely too much on GC and must manually free memory at appropriate times.In such cases, Ruby and Crystal often provide APIs that use blocks based on RAII (Resource Acquisition Is Initialization) concepts. This can handle more than half of the cases.There seem to be cases that are difficult to handle with this alone, but I am still learning and experimenting through trial and error.Thank you for reading. This article was translated from Japanese to English by Claude Sonnet4.]]></content:encoded></item></channel></rss>