<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Dev News</title><link>https://konrad.website/liveboat-github-runner/</link><description></description><item><title>Gateway Api without real ip in the logs</title><link>https://www.reddit.com/r/kubernetes/comments/1ll6v5n/gateway_api_without_real_ip_in_the_logs/</link><author>/u/Jeremymr2</author><category>dev</category><category>reddit</category><category>k8s</category><pubDate>Thu, 26 Jun 2025 17:55:22 +0000</pubDate><source url="https://www.reddit.com/r/kubernetes/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Kubernetes</source><content:encoded><![CDATA[Hello, kubernetes community! I am starting this adventure in the world of kubernetes, and I am currently building a cluster where it will be the future testing environment if everything goes well. Currently, I have backend and frontend set up as service clusterip. I have the metallb that exposes a Trafik Gatewayapi. I managed to connect everything satisfactorily, but the problem that arose was that the Trafik logs showed the IP from '10.244.1.1' and not the real IP of the user who was entering the service. Does anyone know how I could fix this? Isn't there a way to do it? ]]></content:encoded></item><item><title>Introducing Gemma 3n</title><link>https://developers.googleblog.com/en/introducing-gemma-3n-developer-guide/</link><author>bundie</author><category>dev</category><category>hn</category><pubDate>Thu, 26 Jun 2025 17:03:43 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[The first Gemma model launched early last year and has since grown into a thriving Gemmaverse of over 160 million collective downloads. This ecosystem includes our family of over a dozen specialized models for everything from safeguarding to medical applications and, most inspiringly, the countless innovations from the community. From innovators like Roboflow building enterprise computer vision to the Institute of Science Tokyo creating highly-capable Japanese Gemma variants, your work has shown us the path forward.Building on this incredible momentum, we're excited to announce the full release of Gemma 3n. While last month's preview offered a glimpse, today unlocks the full power of this mobile-first architecture. Gemma 3n is designed for the developer community that helped shape Gemma. Itâ€™s supported by your favorite tools including Hugging Face Transformers, llama.cpp, Google AI Edge, Ollama, MLX, and many others, enabling you to fine-tune and deploy for your specific on-device applications with ease. This post is the developer deep dive: we'll explore some of the innovations behind Gemma 3n, share new benchmark results, and show you how to start building today.Gemma 3n represents a major advancement for on-device AI, bringing powerful multimodal capabilities to edge devices with performance previously only seen in last year's cloud-based frontier models. Gemma 3n natively supports image, audio, video, and text inputs and text outputs. Engineered with a focus on efficiency, Gemma 3n models are available in two sizes based on  parameters: E2B and E4B. While their raw parameter count is 5B and 8B respectively, architectural innovations allow them to run with a memory footprint comparable to traditional 2B and 4B models, operating with as little as 2GB (E2B) and 3GB (E4B) of memory.Groundbreaking architecture: At its core, Gemma 3n features novel components like the MatFormer architecture for compute flexibility, Per Layer Embeddings (PLE) for memory efficiency, and new audio and MobileNet-v5 based vision encoders optimized for on-device use cases. Gemma 3n delivers quality improvements across multilinguality (supporting 140 languages for text and multimodal understanding of 35 languages), math, coding, and reasoning. The E4B version achieves an LMArena score over 1300, making it the first model under 10 billion parameters to reach this benchmark.Achieving this leap in on-device performance required rethinking the model from the ground up. The foundation is Gemma 3nâ€™s unique mobile-first architecture, and it all starts with MatFormer.At the core of Gemma 3n is the  (ðŸª†Matryoshka Transformer), a novel nested transformer built for elastic inference. Think of it like Matryoshka dolls: a larger model contains smaller, fully functional versions of itself. This approach extends the concept of Matryoshka Representation Learning from just embeddings to all transformer components.During the MatFormer training of the 4B effective parameter (E4B) model, a 2B effective parameter (E2B) sub-model is simultaneously optimized within it, as shown in the figure above. This provides developers two powerful capabilities and use cases today:1: You can directly download and use either the main E4B model for the highest capabilities, or the standalone E2B sub-model which we have already extracted for you, offering up to 2x faster inference.2: Custom sizes with Mix-n-Match: For more granular control tailored to specific hardware constraints, you can create a spectrum of custom-sized models between E2B and E4B using a method we call Mix-n-Match. This technique allows you to precisely slice the E4B model's parameters, primarily by adjusting the feed forward network hidden dimension per layer (from 8192 to 16384) and selectively skipping some layers. We are releasing the MatFormer Lab, a tool that shows how to retrieve these optimal models, which were identified by evaluating various settings on benchmarks like MMLU.Looking ahead, the MatFormer architecture also paves the way for. While not part of todayâ€™s launched implementations, this capability allows a single deployed E4B model to dynamically switch between E4B and E2B inference paths on the fly, enabling real-time optimization of performance and memory usage based on the current task and device load.Per-Layer Embeddings (PLE): Unlocking more memory efficiencyGemma 3n models incorporate Per-Layer Embeddings (PLE). This innovation is tailored for on-device deployment as it dramatically improves model quality without increasing the high-speed memory footprint required on your device's accelerator (GPU/TPU).While the Gemma 3n E2B and E4B models have a total parameter count of 5B and 8B respectively, PLE allows a significant portion of these parameters (the embeddings associated with each layer) to be loaded and computed efficiently on the CPU. This means only the core transformer weights (approximately 2B for E2B and 4B for E4B) need to sit in the typically more constrained accelerator memory (VRAM).KV Cache sharing: Faster long-context processingProcessing long inputs, such as the sequences derived from audio and video streams, is essential for many advanced on-device multimodal applications. Gemma 3n introduces KV Cache Sharing, a feature designed to significantly accelerate time-to-first-token for streaming response applications.KV Cache Sharing optimizes how the model handles the initial input processing stage (often called the "prefill" phase). The keys and values of the middle layer from local and global attention are directly shared with all the top layers, delivering a notable 2x improvement on prefill performance compared to Gemma 3 4B. This means the model can ingest and understand lengthy prompt sequences much faster than before.Audio understanding: Introducing speech to text and translationGemma 3n uses an advanced audio encoder based on the Universal Speech Model (USM). The encoder generates a token for every 160ms of audio (about 6 tokens per second), which are then integrated as input to the language model, providing a granular representation of the sound context.This integrated audio capability unlocks key features for on-device development, including:Automatic Speech Recognition (ASR): Enable high-quality speech-to-text transcription directly on the device.Automatic Speech Translation (AST): Translate spoken language into text in another language.We've observed particularly strong AST results for translation between English and Spanish, French, Italian, and Portuguese, offering great potential for developers targeting applications in these languages. For tasks like speech translation, leveraging Chain-of-Thought prompting can significantly enhance results. Hereâ€™s an example:<bos><start_of_turn>user
Transcribe the following speech segment in Spanish, then translate it into English: 
<start_of_audio><end_of_turn>
<start_of_turn>modelAt launch time, the Gemma 3n encoder is implemented to process audio clips up to 30 seconds. However, this is not a fundamental limitation. The underlying audio encoder is a streaming encoder, capable of processing arbitrarily long audios with additional long form audio training. Follow-up implementations will unlock low-latency, long streaming applications.MobileNet-V5: New state-of-the-art vision encoderAlongside its integrated audio capabilities, Gemma 3n features a new, highly efficient vision encoder, , delivering state-of-the-art performance for multimodal tasks on edge devices.Designed for flexibility and power on constrained hardware, MobileNet-V5 gives developers:Multiple input resolutions: Natively supports resolutions of 256x256, 512x512, and 768x768 pixels, allowing you to balance performance and detail for your specific applications.Broad visual understanding: Co-trained on extensive multimodal datasets, it excels at a wide range of image and video comprehension tasks.: Processes up to 60 frames per second on a Google Pixel, enabling real-time, on-device video analysis and interactive experiences.This level of performance is achieved with multiple architectural innovations, including:An advanced foundation of MobileNet-V4 blocks (including Universal Inverted Bottlenecks and Mobile MQA).A significantly scaled up architecture, featuring a hybrid, deep pyramid model that is 10x larger than the biggest MobileNet-V4 variant.A novel Multi-Scale Fusion VLM adapter that enhances the quality of tokens for better accuracy and efficiency.Benefiting from novel architectural designs and advanced distillation techniques, MobileNet-V5-300M substantially outperforms the baseline SoViT in Gemma 3 (trained with SigLip, no distillation). On a Google Pixel Edge TPU, it delivers a 13x speedup with quantization (6.5x without), requires 46% fewer parameters, and has a 4x smaller memory footprint, all while providing significantly higher accuracy on vision-language tasksWeâ€™re excited to share more about the work behind this model. Look out for our upcoming MobileNet-V5 technical report, which will deep dive into the model architecture, data scaling strategies, and advanced distillation techniques.Making Gemma 3n accessible from day one has been a priority. We're proud to partner with many incredible open source developers to ensure broad support across popular tools and platforms, including contributions from teams behind AMD, Axolotl, Docker, Hugging Face, llama.cpp, LMStudio, MLX, NVIDIA, Ollama, RedHat, SGLang, Unsloth, and vLLM.But this ecosystem is just the beginning. The true power of this technology is in what you will build with it. Thatâ€™s why weâ€™re launching the Gemma 3n Impact Challenge. Your mission: use Gemma 3n's unique on-device, offline, and multimodal capabilities to build a product for a better world. With $150,000 in prizes, we're looking for a compelling video story and a "wow" factor demo that shows real-world impact. Join the challenge and help build a better future.Get started with Gemma 3n todayReady to explore the potential of Gemma 3n today? Here's how: Use Google AI Studio to try Gemma 3n in just a couple of clicks. Gemma models can also be deployed directly to Cloud Run from AI Studio. Dive into our comprehensive documentation to quickly integrate Gemma into your projects or start with our inference and fine-tuning guides.]]></content:encoded></item><item><title>Rust in Production at 1Password: 500k lines of Rust, 600 crates, 100 engineers - How they secure millions of passwords</title><link>https://corrode.dev/podcast/s04e06-1password/</link><author>/u/mre__</author><category>dev</category><category>reddit</category><category>rust</category><pubDate>Thu, 26 Jun 2025 16:11:56 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[Handling secrets is extremely hard.
You have to keep them safe (obviously), while at the same time you need to integrate with a ton of different systems and always provide a great user-experience, because otherwise people will just find a way around your system.
When talking to peers, a lot of people mention 1Password as a company that nailed this balance.In todayâ€™s episode, I talk to Andrew about how 1Password uses Rust to build critical systems that must never fail, how Rust helps them handle secrets for millions of users, and the lessons they learned when adopting Rust in their stack.
    CodeCrafters helps you become proficient in Rust by building real-world,
    production-grade projects. Learn hands-on by creating your own shell, HTTP
    server, Redis, Kafka, Git, SQLite, or DNS service from scratch.
  
    Start for free today and enjoy 40% off any paid plan by using
    this link.
  1Password is a password manager that helps users securely store and manage their passwords, credit card information, and other sensitive data. It provides a user-friendly interface and strong security features to protect usersâ€™ secrets across multiple devices.Andrew is a Senior Rust Developer at 1Password in the Product Foundations org, on the Frameworks team and specifically on the Core Platform squad handling the asynchronous frameworks other developers use to build features (i.e. requests into the Rust core from the Native clients, data sync, etc.).
He specifically specialized in that synchronization process, getting data federated from cloud to clients to native apps and back.typeshare - Generate types for multiple languages from Rust codezeroizing-alloc - 1Passwordâ€™s minimal secure heap zero-on-free implementation for Rustarboard - Cross-platform clipboard manager written in Rustpasskey-rs - Pure Rust implementation of the WebAuthn Passkey specificationtokio - The de facto standard async runtime for RustClippy - A collection of lints to catch common mistakes in Rustcargo-deny - Cargo plugin for linting dependencies, licenses, and security advisoriesNix - Purely functional package manager for reproducible buildsNix Flakes - Experimental feature for hermetic, reproducible Nix buildsdirenv - Load and unload environment variables based on current directoryaxum - Ergonomic and modular web framework built on tokio and towertower - Library for building robust networking clients and serverstracing - Application-level tracing framework for async-aware diagnosticsrusqlite - Ergonomic wrapper for SQLite in Rustmockall - Powerful mock object library for Rustneon - Library for writing native Node.js modules in Rustnom-supreme - Parser combinator additions and utilities for nomcrane - Nix library for building Cargo projectsRustlings - Small exercises to get you used to reading and writing Rust code]]></content:encoded></item><item><title>Is it just me or is eBPF configuration becoming a total shitshow?</title><link>https://www.reddit.com/r/kubernetes/comments/1ll3bwq/is_it_just_me_or_is_ebpf_configuration_becoming_a/</link><author>/u/Tiny_Habit5745</author><category>dev</category><category>reddit</category><category>k8s</category><pubDate>Thu, 26 Jun 2025 15:39:03 +0000</pubDate><source url="https://www.reddit.com/r/kubernetes/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Kubernetes</source><content:encoded><![CDATA[Seriously, what's happening with eBPF configs lately? Getting PRs with random eBPF programs copy-pasted from Medium articles, zero comments, and when I ask "what does this actually do?" I get "it's for observability" like that explains anything. Had someone deploy a Falco rule monitoring every syscall on the cluster. Performance tanked, took 3 hours to debug, and their response was "but the tutorial said it was best practice." Another team just deployed some Cilium eBPF config into prod because "it worked in kind." Now we have packet drops and nobody knows why because nobody actually understands what they deployed. When did everyone become an eBPF expert? Last month half these people didn't know what a syscall was. Starting to think we need to treat eBPF like Helm charts - proper review, testing, docs. But apparently I'm an asshole for suggesting we shouldn't just YOLO kernel-level code into production. Anyone else dealing with this? How do you stop people from cargo-culting eBPF configs? Feels like early Kubernetes when people deployed random YAML from Stack Overflow.]]></content:encoded></item><item><title>Firefox 141 Beta Lowering RAM Use On Linux But Still Benchmarking Behind Chrome</title><link>https://www.phoronix.com/review/firefox-141-linux-ram</link><author>/u/lebron8</author><category>dev</category><category>reddit</category><pubDate>Thu, 26 Jun 2025 15:35:51 +0000</pubDate><source url="https://www.reddit.com/r/linux/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Linux</source><content:encoded><![CDATA[Following this week's release of Firefox 140, Firefox 141 was promoted to beta. Most exciting for Linux users with next month's Firefox 141 release is finally lowering system RAM use! I've been running some benchmarks looking at the impact.With this week's release of Firefox 141 Beta, it notes an exciting change for Linux users:"On Linux Firefox uses less memory and no longer requires a forced restart after an update has been applied by a package manager."Less memory use by Firefox on Linux is certainly welcome as it's become quite bloated... I've grown frustrated myself with the direction of Firefox and the insane RAM use in recent times. While being a long time Firefox user since the Firebird days, I've contemplated switching to Chrome given the rampant memory use of Firefox on Linux with my 64GB RAM laptop triggering the OOM daemon routinely due to excessive memory use with Firefox.Thus with the Firefox 141 Beta release, I was curious to run some benchmarks of Firefox 140 vs. Firefox 141 Beta on a test system for seeing the difference.With this testing I was just looking at the single-tab/window impact for reproducibility while running various web browser benchmarks but that alone was enough to show a nice improvement over Firefox 140.This round of benchmarks were done on an AMD Ryzen 9 9950X desktop running Ubuntu 25.04 with the Linux 6.15 kernel and NVIDIA graphics.]]></content:encoded></item><item><title>FLUX.1 Kontext [Dev] â€“ Open Weights for Image Editing</title><link>https://bfl.ai/announcements/flux-1-kontext-dev</link><author>minimaxir</author><category>dev</category><category>hn</category><pubDate>Thu, 26 Jun 2025 15:31:58 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[Up until today, all capable generative image editing models were only available as proprietary tools. Today, that changes. We release FLUX.1 Kontext [dev], our developer version of , which delivers proprietary-level image editing performance in a 12B parameter model that can run on consumer hardware.Making model weights openly accessible is fundamental to technological innovation.  is now available as an open-weight model under the FLUX.1 Non-Commercial License, providing free access for research and non-commercial use. FLUX.1 Kontext [dev] is compatible with the existing FLUX.1 [dev] inference code and comes with day-0 support for popular inference frameworks like ComfyUI, HuggingFace Diffusers and TensorRT.The technical report is available .Setting New Standards in Open Image EditingFLUX.1 Kontext [dev] focuses exclusively on editing tasks. The model enables iterative editing, excels at character preservation across a diverse set of scenes and environments, and allows both precise local and global edits.At Black Forest Labs, we remain committed to providing researchers and developers with best-in-class open tools that are competitive with existing proprietary solutions. To validate the performance of FLUX.1 Kontext [dev], we conducted extensive evaluation across multiple image editing benchmarks.Human preference evaluations on , our newly released image editing benchmark, demonstrate that FLUX.1 Kontext [dev] outperforms existing open image editing models, (Bytedance Bagel, HiDream-E1-Full) and closed models (Google's Gemini-Flash Image) across many categories. Independent evaluations run by  confirm these findings.Optimized for NVIDIA Blackwell ArchitectureWe have collaborated with NVIDIA to build optimized TensorRT weights specifically designed for the new  architecture which brings greatly improved inference speed and reduces memory usage while maintaining high-quality image editing performance.Additionally to the original FLUX.1 Kontext [dev] weights, weâ€™re making available these BF16, FP8 and FP4 TensorRT variants in our , giving developers the flexibility to balance speed, efficiency, and quality tailored to their use case. These optimized weights ensure that FLUX.1 Kontext [dev] can take full advantage of the latest hardware capabilities.Streamlined Commercial Access: The BFL Self-Serve PortalWe are releasing a  with transparent terms and standardized commercials for simplifying commercial access to all of our open weights models. This includes the novel FLUX.1 Kontext [dev] as well as the FLUX.1 Tools [dev] and the popular text-to-image model FLUX.1 [dev].Our self-serve portal provides transparent licensing terms that enable businesses to confidently integrate FLUX.1 models into their commercial products and services. Commercial Licenses to our open weights models can now be purchased with only a few clicks, accelerating the path from development to deployment. More information on self-serve licensing can be found at the . We edited the definition of â€œNon-Commercial Purposeâ€ to better clarify what constitutes Non-Commercial Purposes under the FLUX.1 [dev] Non-Commercial License. To prevent the creation and dissemination of unlawful or infringing content, the FLUX.1 [dev] Non-Commercial License requires content filters or manual review to be used with the FLUX.1 [dev] models. Weâ€™ve also made corresponding adjustments to the indemnification of the license.Users of FLUX.1 [dev] Models under a FLUX.1 [dev] Non-Commercial License must follow applicable law for content provenance under the license. We made some clarifications on what are not permitted uses of FLUX.1 [dev] Models under a FLUX.1 [dev] Non-Commercial License.We're just getting started. If you want to join us on our mission, we are actively hiring talented individuals across multiple roles. Apply ]]></content:encoded></item><item><title>Learn open source machine learning with Skolar</title><link>https://www.youtube.com/watch?v=70_ZuhDBvac</link><author>probabl</author><category>dev</category><category>ml</category><enclosure url="https://www.youtube.com/v/70_ZuhDBvac?version=3" length="" type=""/><pubDate>Thu, 26 Jun 2025 15:00:06 +0000</pubDate><source url="https://www.youtube.com/channel/UCIat2Cdg661wF5DQDWTQAmg">Dev - Probabl</source><content:encoded><![CDATA[Train_test your skills in open-source ML ðŸ’¥ Skolar is the FREE learning platform by the makers of scikit-learn. Learn real-world machine learning, prep for certification, and go from zero to hero â€” the open-source way.
Go to skolar.probabl.ai
#probabl #datascience #machinelearning #scikitlearn #sklearn #ai]]></content:encoded></item><item><title>Show HN: I built an AI dataset generator</title><link>https://github.com/metabase/dataset-generator</link><author>matthewhefferon</author><category>dev</category><category>hn</category><pubDate>Thu, 26 Jun 2025 14:58:32 +0000</pubDate><source url="https://news.ycombinator.com/shownew">HN Show</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Launch HN: Issen (YC F24) â€“ Personal AI language tutor</title><link>https://news.ycombinator.com/item?id=44387828</link><author>mariano54</author><category>dev</category><category>hn</category><pubDate>Thu, 26 Jun 2025 14:32:28 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[Hey HN, we're Mariano and Anton from ISSEN (https://issen.com), a foreign language voice tutor app that adapts to your interests, goals, and needs.We started this company after struggling to find great tools to practice speaking Japanese and French. Having a tutor can be awesome, but there are downsides: they can be expensive (since you pay by the hour), difficult to schedule, and have a high upfront cost (finding a tutor you like often forces you to cycle through a few that you donâ€™t).We wanted something that would talk with us â€” realistically, in full conversations â€” and actually help us improve. So we built it ourselves.
The app relies on a custom voice AI pipeline combining STT (speech-to-text), TTS (text-to-speech), LLMs, long term memory, interruptions, turn-taking, etc. Getting speech-to-text to work well for learners was one of the hardest parts â€” especially with accents, multi-lingual sentences, and noisy environments. We now combine Gemini Flash, Whisper, Scribe, and GPT-4o-transcribe to minimize errors and keep the conversation flowing.We didnâ€™t want to focus too much on gamification. In our experience, that leads to users performing well in the app, achieving long streaks and so on, without actually getting fluent in the language you're wanting to learn.With ISSEN you instantly speak and immerse yourself in the language, which, while not easy, is a much more efficient way to learn.We combine this with a word bank and SRS flashcards for new words learned in the AI voice chats, which allows very rapid improvement in both vocabulary and speaking skills. We also create custom curriculums for each student based on goals, interests, and preferences, and fully customizable settings like speed, turn taking, formality, etc.App: https://issen.com (works on web, iOS, Android)
Pricing: 20 min free trial, $20â€“29/month (depending on duration and specific geography)Weâ€™d love your feedback â€” on the tech, the UX, or what youâ€™d wish from a tool like this. Thanks!]]></content:encoded></item><item><title>So Long, Image Layouts: Simplifying Vulkan Synchronisation</title><link>https://www.khronos.org/blog/so-long-image-layouts-simplifying-vulkan-synchronisation</link><author>/u/GamerY7</author><category>dev</category><category>reddit</category><pubDate>Thu, 26 Jun 2025 14:28:12 +0000</pubDate><source url="https://www.reddit.com/r/programming/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Programming</source><content:encoded><![CDATA[Synchronization in VulkanÂ® has long been one of its most notorious challenges, something developers havenâ€™t been shy about reminding us. The KhronosÂ® Vulkan Working Group has been steadily working to make Vulkan a joy to use, and simplifying the synchronization model has been high on our priority list. One of the most frequent developer frustrations has been the complexity of managing image layouts, a pain point weâ€™re tackling head-on with the new VK_KHR_unified_image_layouts extension, which aims to eliminate the need for most layout transitions entirely.Itâ€™s been over a decade since Vulkanâ€™s synchronization model was first designed. At the time, the graphics development community strongly favored explicit control over synchronization, and the Vulkan Working Group responded with an API that prioritized performance on the hardware of that era, delivering maximum flexibility and control to application developers.In hindsightâ€”and perhaps unsurprisinglyâ€”synchronization has turned out to be one of Vulkanâ€™s most challenging aspects, tripping up both new and seasoned developers. The synchronization model is complex enough that many applications struggle to issue synchronization commands that are efficient or even correct. The  extension introduced several incremental improvements while largely preserving the foundational principles of Vulkan 1.0â€™s original approach.Since then, modern GPUs have evolved significantly, including how they handle synchronization, making many of Vulkanâ€™s original design constraints increasingly outdated. Recognizing this, the Vulkan Working Group is now actively working to streamline synchronization, aiming to improve usability and make high-performance graphics development more accessible. The newly released VK_KHR_unified_image_layouts extension is a major milestone on that path.Vulkan 1.0 introduced several image layouts, with later extensions adding a few more. In practice, though, these layouts typically map to just a handful of actual physical layouts or compression formats. One notable exception is VK_IMAGE_LAYOUT_UNDEFINED, which isnâ€™t a physical layout at all but instead serves to initialize internal metadata for newly created images.Image layout transitions in Vulkan exist primarily for three reasons: â€“ Transitions from VK_IMAGE_LAYOUT_UNDEFINED serve as image initialization operations. â€“ When transferring ownership to or from external queue families or presenting images to the display, transitions may be required to ensure compatibility with external components that donâ€™t support Vulkanâ€™s internal compression schemes. â€“ Even within the same Vulkan device, some subsystems may not understand the framebuffer compression used by others. For instance, using depth/stencil or multisampled color attachments outside of a render pass may require decompression on certain hardware.With VK_KHR_unified_image_layouts, the Vulkan Working Group recognizes that the third caseâ€” internal incompatibilityâ€”is no longer relevant for most modern GPUs. This extension allows developers to bypass the majority of layout transitions, significantly simplifying synchronization and reducing boilerplate. Better yet, nearly all GPU vendors are ready to support this extension on current-generation hardware. Itâ€™s already on the Vulkan roadmap, with the goal of including it in the core API.At its heart, VK_KHR_unified_image_layouts is a simple but powerful from the driver to the application: it guarantees that  can be used efficiently in nearly all cases. Aside from a few specific scenarios, such as image initialization or presentation, developers no longer need to use layout transitions at all, just use!Validation layer support is expected in the July Vulkan SDK. As alwaysâ€”and especially with this extensionâ€”we strongly recommend enabling Synchronization Validation in the Vulkan validation layers. Several common synchronization errors are caught by mismatched image layouts, but standard validation will no longer be able to detect these if the layout is set to . Vulkanâ€™s core principlesâ€”explicit control and low-level access to modern GPU featuresâ€”arenâ€™t going anywhere. But the Vulkan Working Group is placing greater emphasis on developer experience. Instead of just building new features, weâ€™re revisiting older ones to make them easier to use. VK_KHR_unified_image_layouts is the latest example, and more improvements are on the way.Weâ€™re excited about a future where synchronization is no longer a source of frustration. But we canâ€™t get there without your valuable feedback. Join the conversation on the Vulkan Discord, or leave a comment below. Let us know how this extension is working for you, what challenges youâ€™re facing, and which pain points youâ€™d like us to tackle next!]]></content:encoded></item><item><title>Google DeepMind Releases AlphaGenome</title><link>https://deepmind.google/discover/blog/alphagenome-ai-for-better-understanding-the-genome/</link><author>i_love_limes</author><category>dev</category><category>hn</category><pubDate>Thu, 26 Jun 2025 14:16:00 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[Introducing a new, unifying DNA sequence model that advances regulatory variant-effect prediction and promises to shed new light on genome function â€” now available via API.The genome is our cellular instruction manual. Itâ€™s the complete set of DNA which guides nearly every part of a living organism, from appearance and function to growth and reproduction. Small variations in a genomeâ€™s DNA sequence can alter an organismâ€™s response to its environment or its susceptibility to disease. But deciphering how the genomeâ€™s instructions are read at the molecular level â€” and what happens when a small DNA variation occurs â€” is still one of biologyâ€™s greatest mysteries.Today, we introduce AlphaGenome, a new artificial intelligence (AI) tool that more comprehensively and accurately predicts how single variants or mutations in human DNA sequences impact a wide range of biological processes regulating genes. This was enabled, among other factors, by technical advances allowing the model to process long DNA sequences and output high-resolution predictions.To advance scientific research, weâ€™re making AlphaGenome available in preview via our AlphaGenome API for non-commercial research, and planning to release the model in the future.We believe AlphaGenome can be a valuable resource for the scientific community, helping scientists better understand genome function, disease biology, and ultimately, drive new biological discoveries and the development of new treatments.Our AlphaGenome model takes a long DNA sequence as input â€” up to 1 million letters, also known as base-pairs â€” and predicts thousands of molecular properties characterising its regulatory activity. It can also score the effects of genetic variants or mutations by comparing predictions of mutated sequences with unmutated ones.Predicted properties include where genes start and where they end in different cell types and tissues, where they get spliced, the amount of RNA being produced, and also which DNA bases are accessible, close to one another, or bound by certain proteins. Training data was sourced from large public consortia including ENCODE, GTEx, 4D Nucleome and FANTOM5, which experimentally measured these properties covering important modalities of gene regulation across hundreds of human and mouse cell types and tissues.The AlphaGenome architecture uses convolutional layers to initially detect short patterns in the genome sequence, transformers to communicate information across all positions in the sequence, and a final series of layers to turn the detected patterns into predictions for different modalities. During training, this computation is distributed across multiple interconnected Tensor Processing Units (TPUs) for a single sequence.This model builds on our previous genomics model, Enformer and is complementary to AlphaMissense, which specializes in categorizing the effects of variants within protein-coding regions. These regions cover 2% of the genome. The remaining 98%, called non-coding regions, are crucial for orchestrating gene activity and contain many variants linked to diseases. AlphaGenome offers a new perspective for interpreting these expansive sequences and the variants within them.AlphaGenomeâ€™s distinctive featuresAlphaGenome offers several distinctive features compared to existing DNA sequence models:Long sequence-context at high resolutionOur model analyzes up to 1 million DNA letters and makes predictions at the resolution of individual letters. Long sequence context is important for covering regions regulating genes from far away and base-resolution is important for capturing fine-grained biological details.Previous models had to trade off sequence length and resolution, which limited the range of modalities they could jointly model and accurately predict. Our technical advances address this limitation without significantly increasing the training resources â€” training a single AlphaGenome model (without distillation) took four hours and required half of the compute budget used to train our original Enformer model.Comprehensive multimodal predictionBy unlocking high resolution prediction for long input sequences, AlphaGenome can predict the most diverse range of modalities. In doing so, AlphaGenome provides scientists with more comprehensive information about the complex steps of gene regulation.Efficient variant scoringIn addition to predicting a diverse range of molecular properties, AlphaGenome can efficiently score the impact of a genetic variant on all of these properties in a second. It does this by contrasting predictions of mutated sequences with unmutated ones, and efficiently summarising that contrast using different approaches for different modalities.Novel splice-junction modelingMany rare genetic diseases, such as spinal muscular atrophy and some forms of cystic fibrosis, can be caused by errors in RNA splicing â€” a process where parts of the RNA molecule are removed, or â€œspliced outâ€, and the remaining ends rejoined. For the first time, AlphaGenome can explicitly model the location and expression level of these junctions directly from sequence, offering deeper insights about the consequences of genetic variants on RNA splicing.State-of-the-art performance across benchmarksAlphaGenome achieves state-of-the-art performance across a wide range of genomic prediction benchmarks, such as predicting which parts of the DNA molecule will be in close proximity, whether a genetic variant will increase or decrease expression of a gene, or whether it will change the geneâ€™s splicing pattern.When producing predictions for single DNA sequences, AlphaGenome outperformed the best external models on 22 out of 24 evaluations. And when predicting the regulatory effect of a variant, it matched or exceeded the top-performing external models on 24 out of 26 evaluations.This comparison included models specialized for individual tasks. AlphaGenome was the only model that could jointly predict all of the assessed modalities, highlighting its generality. Read more in our preprint.The benefits of a unifying modelAlphaGenomeâ€™s generality allows scientists to simultaneously explore a variant's impact on a number of modalities with a single API call. This means that scientists can generate and test hypotheses more rapidly, without having to use multiple models to investigate different modalities.Moreover AlphaGenomeâ€™s strong performance indicates it has learned a relatively general representation of DNA sequence in the context of gene regulation. This makes it a strong foundation for the wider community to build upon. Once the model is fully released, scientists will be able to adapt and fine-tune it on their own datasets to better tackle their unique research questions.Finally, this approach provides a flexible and scalable architecture for the future. By extending the training data, AlphaGenomeâ€™s capabilities could be extended to yield better performance, cover more species, or include additional modalities to make the model even more comprehensive.Itâ€™s a milestone for the field. For the first time, we have a single model that unifies long-range context, base-level precision and state-of-the-art performance across a whole spectrum of genomic tasks.Dr. Caleb Lareau, Memorial Sloan Kettering Cancer CenterAlphaGenome's predictive capabilities could help several research avenues: By more accurately predicting genetic disruptions, AlphaGenome could help researchers pinpoint the potential causes of disease more precisely, and better interpret the functional impact of variants linked to certain traits, potentially uncovering new therapeutic targets. We think the model is especially suitable for studying rare variants with potentially large effects, such as those causing rare Mendelian disorders. Its predictions could be used to guide the design of synthetic DNA with specific regulatory function â€” for example, only activating a gene in nerve cells but not muscle cells. It could accelerate our understanding of the genome by assisting in mapping its crucial functional elements and defining their roles, identifying the most essential DNA instructions for regulating a specific cell type's function.For example, we used AlphaGenome to investigate the potential mechanism of a cancer-associated mutation. In an existing study of patients with T-cell acute lymphoblastic leukemia (T-ALL), researchers observed mutations at particular locations in the genome. Using AlphaGenome, we predicted that the mutations would activate a nearby gene called TAL1 by introducing a MYB DNA binding motif, which replicated the known disease mechanism and highlighted AlphaGenomeâ€™s ability to link specific non-coding variants to disease genes.AlphaGenome will be a powerful tool for the field. Determining the relevance of different non-coding variants can be extremely challenging, particularly to do at scale. This tool will provide a crucial piece of the puzzle, allowing us to make better connections to understand diseases like cancer.Professor Marc Mansour, University College LondonAlphaGenome marks a significant step forward, but it's important to acknowledge its current limitations.Like other sequence-based models, accurately capturing the influence of very distant regulatory elements, like those over 100,000 DNA letters away, is still an ongoing challenge. Another priority for future work is further increasing the modelâ€™s ability to capture cell- and tissue-specific patterns.We haven't designed or validated AlphaGenome for personal genome prediction, a known challenge for AI models. Instead, we focused more on characterising the performance on individual genetic variants. And while AlphaGenome can predict molecular outcomes, it doesn't give the full picture of how genetic variations lead to complex traits or diseases. These often involve broader biological processes, like developmental and environmental factors, that are beyond the direct scope of our model.Weâ€™re continuing to improve our models and gathering feedback to help us address these gaps.Enabling the community to unlock AlphaGenome's potentialAlphaGenome is now available for non-commercial use via our AlphaGenome API. Please note that our modelâ€™s predictions are intended only for research use and havenâ€™t been designed or validated for direct clinical purposes.Researchers worldwide are invited to get in touch with potential use-cases for AlphaGenome and to ask questions or share feedback through the community forum.We hope AlphaGenome will be an important tool for better understanding the genome and weâ€™re committed to working alongside external experts across academia, industry, and government organizations to ensure AlphaGenome benefits as many people as possible.Together with the collective efforts of the wider scientific community, we hope it will deepen our understanding of the complex cellular processes encoded in the DNA sequence and the effects of variants, and drive exciting new discoveries in genomics and healthcare.We would like to thank Juanita Bawagan, Arielle Bier, Stephanie Booth, Irina Andronic, Armin Senoner, Dhavanthi Hariharan, Rob Ashley, Agata Laydon and Kathryn Tunyasuvunakool for their help with the text and figures.This work was done thanks to the contributions of the AlphaGenome co-authors: Å½iga Avsec, Natasha Latysheva, Jun Cheng, Guido Novati, Kyle R. Taylor, Tom Ward, Clare Bycroft, Lauren Nicolaisen, Eirini Arvaniti, Joshua Pan, Raina Thomas, Vincent Dutordoir, Matteo Perino, Soham De, Alexander Karollus, Adam Gayoso, Toby Sargeant, Anne Mottram, Lai Hong Wong, Pavol DrotÃ¡r, Adam Kosiorek, Andrew Senior, Richard Tanburn, Taylor Applebaum, Souradeep Basu, Demis Hassabis and Pushmeet Kohli.We would also like to thank Dhavanthi Hariharan, Charlie Taylor, Ottavia Bertolli, Yannis Assael, Alex Botev, Anna Trostanetski, Lucas TenÃ³rio, Victoria Johnston, Richard Green, Kathryn Tunyasuvunakool, Molly Beck, Uchechi Okereke, Rachael Tremlett, Sarah Chakera, Ibrahim I. Taskiran, Andreea-Alexandra MuÅŸat, Raiyan Khan, Ren Yi and the greater Google DeepMind team for their support, help and feedback.]]></content:encoded></item><item><title>Helm chart testing</title><link>https://www.reddit.com/r/kubernetes/comments/1ll0ame/helm_chart_testing/</link><author>/u/calm-machine-beater</author><category>dev</category><category>reddit</category><category>k8s</category><pubDate>Thu, 26 Jun 2025 13:34:34 +0000</pubDate><source url="https://www.reddit.com/r/kubernetes/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Kubernetes</source><content:encoded><![CDATA[For all the Helm users here: are you using some kind of testing framework to perform unit testing on your helm charts? If so, do you deem it reliable?]]></content:encoded></item><item><title>Over 80% of all Smartphones are powered by Linux</title><link>https://linuxblog.io/80-percent-smartphones-linux/</link><author>/u/modelop</author><category>dev</category><category>reddit</category><pubDate>Thu, 26 Jun 2025 13:26:56 +0000</pubDate><source url="https://www.reddit.com/r/linux/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Linux</source><content:encoded><![CDATA[Linux-powered smartphones are still the dominant force in the global smartphone market in 2025. While some may be surprised by this fact, Linux enthusiasts have every reason to be happy about the continued success and influence of Linux in the mobile world.Read on for the latest stats, updated links and proof that Linux is still at the heart of the smartphone ecosystem. This is a follow-up to my previous articles in 2013 and 2021.Google formalized their efforts to keep Android closer to upstream Linux by introducing the Generic Kernel Image (GKI) project in 2019. Since then, the GKI project has matured a lot, with ongoing upstream kernel development focused on reducing fragmentation, upstreaming Android-specific features and establishing a stable Kernel Module Interface (KMI).All of which has strengthened Androidâ€™s connection to the mainline Linux kernel and fostered closer collaboration between Google, device vendors, and the Linux community.Android and Chrome OS: Still Linux at the CoreGoogleâ€™s Android and Chrome OS are operating systems originally based on the Linux kernel. Android, in particular, has continued to evolve, now running on long-term support (LTS) Linux kernels, such as versions 4.19, 5.4, and more recently, 6.x series, with regular merges from the Linux mainline into the Android-common kernel tree.2025 Smartphone Market Share: Linux Still LeadsRecent Canalys (Omdia) research shows that in Q1 2025, the global smartphone market shipped 296.9 million units, with Android-based devices continuing to dominate. Samsung led with 60.5 million units (20% market share), followed by Apple with 55.0 million units (19%). Xiaomi, vivo, and OPPO rounded out the top five.Combining Android, Xiaomi, Vivo, OPPO, and other Android-based OSes,Linux powers around 80% of the global smartphone market.Androidâ€™s share remains robust, with estimates consistently placing it at over 80% of global smartphone shipments. Yup, more than a decade after my first article on this, the vast majority of smartphones in use today are still powered by the Linux kernel.Alternative Linux Smartphones in 2025While Android dominates, several alternative Linux-based smartphones continue to attract enthusiasts and privacy-focused users: Purismâ€™s security- and privacy-focused smartphone, running on Debian Linux, continues to receive updates and improvements. It remains a leading choice for those who value open-source hardware and software. Pine64â€™s PinePhone and PinePhone Pro offer mainline Linux support and hardware kill switches, appealing to developers and tinkerers. The ProÂ¹-X, an updated version of the original Pro1, features a physical keyboard and support for multiple Linux-based OS options, including LineageOS and Ubuntu Touch. KDEâ€™s Plasma Mobile continues to evolve, supporting a range of devices including the PinePhone and select Android handsets via postmarketOS.Checking the Linux Kernel Version on Your AndroidTo see which Linux kernel your Android device is running, open  and tap on  or .Â For rooted devices, you can use Termux and run:This command will display your deviceâ€™s kernel version and build information.Conclusion: Linuxâ€™s Enduring DominanceAndroidâ€™s open-source nature and the flexibility of the Linux kernel continue to drive innovation and user empowerment in the smartphone market. With Android holding steady at around 80% global market share in 2025, Linuxâ€™s influence is as strong as ever.Smartphones powered by Linux continue to dominate the global smartphone market in 2025. While some may still be surprised by this fact, Linux enthusiasts have every reason to celebrate the ongoing success and influence of Linux in the mobile world.With the fall of the Windows phone, almost 100% of all smartphones are powered by Unix and Unix-like systems. Meanwhile, alternative Linux and Android-based smartphones such as those listed above, offer exciting options for those seeking greater privacy, control, or experimentation.]]></content:encoded></item><item><title>Learnings from building AI agents</title><link>https://www.cubic.dev/blog/learnings-from-building-ai-agents</link><author>pomarie</author><category>dev</category><category>hn</category><pubDate>Thu, 26 Jun 2025 12:45:04 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[Iâ€™m Paul, cofounder ofÂ cubicâ€”an "AI-native GitHub." One of our core features is an AI code review agent that performs an initial review pass, catching bugs, anti-patterns, duplicated code, and similar issues in pull requests.When we first released this agent back in April, the main feedback we got was straightforward: it was too noisy.Even small PRs often ended up flooded with multiple low-value comments, nitpicks, or outright false positives. Rather than helping reviewers, it cluttered discussions and obscured genuinely valuable feedback.We decided to take a step back and thoroughly investigate why this was happening.After three major architecture revisions and extensive offline testing, we managed to reduce false positives by  without sacrificing recall.Many of these lessons turned out to be broadly usefulâ€”not just for code review agents but for designing effective AI systems in general.1. The Faceâ€‘Palm Phase: A Single, Doâ€‘Everything AgentOur initial architecture was straightforward but problematic:
â†“

â†“
It looked clean in theory but quickly fell apart in practice:Excessive false positives: The agent often mistook style issues for critical bugs, flagged resolved issues, and repeated suggestions our linters had already addressed.Users lost trust: Developers quickly learned to ignore the comments altogether. When half the comments feel irrelevant, the truly important ones get missed.Opaque reasoning: Understanding why the agent made specific calls was practically impossible. Even explicit prompts like "ignore minor style issues" had minimal effect.We tried standard solutionsâ€”longer prompts, adjusting the model's temperature, experimenting with samplingâ€”but saw little meaningful improvement.After extensive trial-and-error, we developed an architecture that significantly improved results and proved effective in real-world repositories. These solutions underpin the 51% reduction in false positives currently running in production.2.1 Explicit Reasoning LogsWe required the AI to explicitly state its reasoning before providing any feedback:This approach provided critical benefits:Enabled us to clearly trace the AIâ€™s decision-making process. If reasoning was flawed, we could quickly identify and exclude the pattern in future iterations.Encouraged structured thinking by forcing the AI to justify its findings first, significantly reducing arbitrary conclusions.Created a foundation to diagnose and resolve root causes behind other issues we faced.Initially, the agent had extensive toolingâ€”Language Server Protocol (LSP), static analysis, test runners, and more. However, explicit reasoning logs revealed most analyses relied on a few core tools, with extra complexity causing confusion and mistakes.We streamlined the toolkit to essential components onlyâ€”a simplified LSP and a basic terminal.With fewer distractions, the agent spent more energy confirming genuine issues, significantly improving precision.2.3 Specialized Micro-Agents Over Generalized RulesInitially, our instinct was to continuously add more rules into a single large prompt to handle edge cases:â€œIgnore unused variables in .test.ts files.â€â€œSkip import checks in Pythonâ€™s .py.â€â€œDon't lint markdown files.â€This rapidly became unsustainable and was largely ineffective as the AI frequently overlooked many rules.Our breakthrough came from employing specialized micro-agents, each handling a narrowly-defined scope:: Quickly assesses changes and identifies necessary checks.: Detects vulnerabilities such as injection or insecure authentication.: Flags repeated or copied code.: Handles typos and documentation consistency.Specializing allowed each agent to maintain a focused context, keeping token usage efficient and precision high. The main trade-off was increased token consumption due to overlapping context, managed through effective caching strategies.These architecture and prompt improvements led to meaningful results across hundreds of real pull requests from active open-source and private repositories. Specifically, over the past six weeks:51% fewer false positives, directly increasing developer trust and usability.Median comments per pull request cut by half, helping teams concentrate on genuinely important issues.Teams reported notably smoother review processes, spending less time managing irrelevant comments and more time effectively merging changes.Additionally, the reduced noise significantly improved developer confidence and engagement, making reviews faster and more impactful.Explicit reasoning improves clarity. Require your AI to clearly explain its rationale firstâ€”this boosts accuracy and simplifies debugging.Simplify the toolset. Regularly evaluate your agent's toolkit and remove tools rarely used (less than 10% of tasks).Specialize with micro-agents. Keep each AI agent tightly focused on a single task, reducing cognitive overload and enhancing precision.]]></content:encoded></item><item><title>Malicious npm eslint-config-airbnb-compat Package Hides Detection with Payload Splitting</title><link>https://safedep.io/digging-into-dynamic-malware-analysis-signals/</link><author>/u/Ok_Possibility1445</author><category>dev</category><category>reddit</category><pubDate>Thu, 26 Jun 2025 12:38:26 +0000</pubDate><source url="https://www.reddit.com/r/programming/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Programming</source><content:encoded><![CDATA[In our previous blog, we discussed building a large scale Dynamic Analysis System for malicious open source package identification. Dynamic analysis help in observing actual runtime behaviors and activities for a package, installed in a sandbox environment. It complements our Static Analysis system and helps:To verify and correlate static analysis findings with actual runtime behaviorTo overcome the limitations of static analysis which may have false positives and negativesTo observe how packages actually behave when executed in a controlled environmentTo identify malicious packages that might evade static code analysisTo reduce the need for human intervention (manual analysis) over timeThe goal of this blog is to share our learnings and approach for identifying malicious packages based on dynamic analysis signals. This is a step towards having a sound and reliable baseline for package installation analysis so that it can be used to identify outliers and anomalies.We tracked nearly  events generated from our Dynamic Analysis System, analyzing more than  packages since we started operating this infrastructure. As events are generated, we needed a way to find  activities and potential malicious packages that can be subjected to manual review. This can only be found using heuristics and patterns, not manual review of all events generated by all packages.As a first step, we decided to aggregate following information from the events:Network Connection, IP AggregatorBinary execution on installThe rationale for these metrics are:Irrespective of specific TTP,  payload will eventually be executed by a malicious packageThe payload will either make a network call or execute a command (eg. ) in an unusual wayThis hypothesis can be substantiated by our past observations where we observed multiple malicious packages eventually downloads a 2nd-stage payload from a remote C2 server or uploads data to a remote server (exfiltration).Any package installation process always triggers network connections, especially to the source registries such as , ,  etc. We cannot only detect network connections, we have to identify  in the distribution of these connections. To identify outliers, we log every  for these connections and analyze the distribution of these . The following chart shows the distribution of  for network connections:Looking at the data, we can spot some interesting patterns. A few IP addresses are  in the distribution. From a security perspective, these rare connections raise red flags since legitimate package installations typically connect to well known, frequently accessed endpoints. The chart below highlights some of these suspicious one-off connections that may be suitable candidates for further investigation:For example, looking up IP  on VirusTotal shows it has been classified as malicious by multiple security vendors.Next, we performed  to identify the hostnames of these IP addresses. Below are some of the IP addresses that were resolved to a hostname.Looking at the hostnames, domains like , , , and mail.sms-system-alert.com are known malicious domains. In particular,  (Out-of-band Application Security Testing) domains are commonly used for malicious purposes like data exfiltration and command & control. We have seen this in our previous post Burp Collaborator used in Malicious npm Packages.Abnormal Binary ExecutionPackages introducing pre-compiled binaries during installation is a common observation. For example, top binaries shipped with  and  packages or expected to be present in the system are , , , , ,  and more. They are executed for legitimate purposes, but can be used to harm the system as soon as the package is installed. The following chart shows the distribution of these binaries:Looking at the distribution, we can spot suspicious binaries like , , and  that appear infrequently. These unknown executables pose potential security risks, as they can execute malicious code immediately upon package installation, potentially compromising the system before any security controls can detect and prevent the threat.While the system is at an early research stage, we present a case study of a real malicious package that was identified using the approach described above. This package is eslint-config-airbnb-compat and was not detected as malicious by our static analysis system. Following are the high level chain of events that led to the identification of this package:Suspicious IP address  was detected in the network connection logs.Events were correlated with the package eslint-config-airbnb-compat for which our static analysis report was blindManual analysis did not conclusively identify root cause of this network activityDependency graph analysis identified  as a transitive dependency with stage-2 loader codeManual analysis tied the two packages together and confirmed the malicious intentFor this analysis, the trigger was a low key IP address  that appeared in the network connection logs. The reverse DNS lookup revealed the hostname mail.sms-system-alert.com that was flagged as malicious by VirusTotal. This gave us enough confidence to investigate the package further.We backtrack the package which is associated with this event, making connection to this  IP (whoâ€™s host was mail.sms-system-alert.com), and found eslint-config-airbnb-compat. This package appears to impersonate legitimate eslint-config-airbnb possibly with the goal of starjacking and spoofing its origin to automated security tools.We found, eslint-config-airbnb-compat contains a post install script declared in  to execute . This is not totally unusual for a large number of  packages, although it does raise security concerns.However, manual analysis revealed multiple unusual behavior. Likely to avoid identification, the  does not have any malicious code. It simply does the following:Copy the embedded  to The  file contains the following The host  resolves to our target IP address Execute  if  directory is not presentAt this point, we were fairly confident that this package is malicious. However, we needed to identify the root cause of this malicious behavior. We started by analyzing the dependency graph of this package and found  as a transitive dependency with stage-2 loader code. The package  in turn has a post install script:The  in  contains interesting code:When introduced through eslint-config-airbnb-compat, it will have proxy=https://proxy.eslint-proxy.site in the  call above. The above fetch call is expected to fail to trigger  function with  provided error message.The remote server at https://proxy.eslint-proxy.site can return a  message such as {"error": "<JS Payload>"} which in turn will be passed to  as an Error object.The error handler in turn does the following:Decode the message as  stringConstructs a function from the decoded stringFinally executes the remote codeThis pretty much confirm the malicious behavior of the entire attack chain. It implements a multi-stage remote code execution attack using a transitive dependency to hide the malicious code.Dynamic analysis provides a complementary approach for detecting malicious open source packages that might evade static analysis. By monitoring network connections and binary executions during package installation, we can identify suspicious behaviors that indicate potential threats. The multi-stage attack discovered in the eslint-config-airbnb-compat package demonstrates how sophisticated these attacks can be, using transitive dependencies and obfuscation techniques to hide malicious code.As attackers continue to develop increasingly complex methods to compromise the open source software supply chains, combining static and dynamic analysis approaches is essential for effective detection. By focusing on abnormal signals and patterns during runtime, we can better protect our software supply chains against evolving threats and maintain the integrity of the open source ecosystems.]]></content:encoded></item><item><title>Rust 1.88: &apos;If-Let Chain&apos; syntax stabilized</title><link>https://releases.rs/docs/1.88.0/</link><author>/u/thurn2</author><category>dev</category><category>reddit</category><category>rust</category><pubDate>Thu, 26 Jun 2025 11:57:46 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[Released on: Branched from master on: These previously stable APIs are now stable in const contexts:]]></content:encoded></item><item><title>Command Pattern as an API Architecture Style</title><link>https://ymz-ncnk.medium.com/command-pattern-as-an-api-architecture-style-be9ac25d6d94</link><author>/u/ymz-ncnk</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Thu, 26 Jun 2025 11:48:07 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[Would you like a fast and flexible interaction with your API? To achieve this goal, it is necessary to:Decide on the API architectural style.Choose the serialization format.Use efficient implementations of both.Itâ€™s always better to solve a general problem by breaking it down into smaller parts, so letâ€™s take a closer look at each.We already have numerous API architectural styles, such as REST, RPC, and SOAP, to name a few. I would like to add our old friend to them â€” the Command Pattern, or more precisely, the Command Pattern over the network. Offering the following advantages, it can be a good candidate for this role:Provides a way to model transactions. Commands share a common interface and can perform multiple actions at a time, making them ideal for this purpose.Allows to save user actions as a list of Commands, which can be useful for logging user activities, replaying operations, or implementing auditing mechanisms.Provides Undo/Redo functionality.Follows the open/closed principle. New Commands can be added easily without modifying existing code.Enhances testability, as Commands can be tested in isolation.Letâ€™s compare it with RPC.Why RPC? Because they are similar â€” both approaches involve performing an arbitrary action on the server.The most obvious difference is that the Command Pattern operates with Commands, whereas RPC relies on functions.II. Similar RepresentationDespite that, they look the same when transmitted over the network:Thatâ€™s quite unexpected, isnâ€™t it?III. Number of Actions at a TimeUnlike the Command Pattern, RPC can perform only one action at a time, which is not very convenient. Letâ€™s look at the following function composition:RPC suggests to make two requests or have a function like , to reduce the number of round trips. The latter option, by the way, is not ideal. The desire to get rid of latency problems will affect the communication interface â€” it will become more broad and complex. This is, actually, what the guys from Capâ€™n Proto say. Offering own solution they describe this problem in more detail.On the other hand, function composition is not an issue for the Command Pattern:In general it allows to perform an unlimited number of actions with a single request, without adding interface complexity or compromising performance.IV. Commands Inside FunctionsRPC can actually be implemented using the Command Pattern. In this case, functions can simply send Commands to the server:Thus, all we need to know is how to deal with Commands. This knowledge is more versatile and allows to improve even existing RPC systems.Command Pattern ChallengesWhile offering a more flexible and general abstraction, the Command Pattern also introduces some challenges:Server should somehow distinguish one Command from another. : Before each Command, send its type.Commands must return results, and each Command can have its own. : Instead of returning, the Command itself can be responsible for sending one or more results back.During execution, a Command may encounter an error. How should it be handled? : If we want the client to know about this error, the Command can send it back as a result. In another case, the Command can terminate the connection with the client, returning an error to the Invoker.To limit its execution time, the Command must know when it was received by the server. This time may differ from the start of execution. : The Command can receive it as a parameter.Thatâ€™s how the Command Pattern, adapted to our needs, might look. To see it in action, we need to consider one more thing.To send data somewhere, it must first be converted into a sequence of bytes. This can be done in various ways, which is why so many serialization formats exist. One of the most important metrics to consider is the number of bytes used by the format. The fewer bytes we need to transfer over the network, the faster our application will be.The MUS format was created with these thoughts in mind. It uses almost no metadata and is actually a fairly simple format. I donâ€™t want to repeat myself a lot, so hereâ€™s a link where you can read more about it.And thatâ€™s all for the theory.The ideas described above have already been implemented for Go in the form of two libraries:  and .cmd-stream-go is a high-performance client-server library that implements the Command Pattern and:Can work over TCP, TLS or mutual TLS.Has an asynchronous client, that uses only one connection for both sending Commands and receiving Results.Supports the server streaming, i.e. a Command can send back multiple Results.Provides reconnect and keepalive features.Supports the Circuit Breaker pattern.Has OpenTelemetry integration.Can work with various serialization formats.Has a modular architecture.mus-go is a MUS format serializer, it:Represents a set of serialization primitives that can be used to implement not only MUS but also other serialization formats.Can run on both 32 and 64-bit systems.Can validate and skip data while unmarshalling.Can serialize data structures such as graphs or linked lists.Supports data versioning.Supports out-of-order deserialization.Supports zero allocation deserialization.In addition, as you can see in the benchmarks, it demonstrates excellent performance:NS/OP â€” Nanoseconds per operation.B/SIZE â€” Number of bytes used to encode the data.B/OP â€” Number of bytes allocated per operation.ALLOCS/OP â€” Number of allocations per operation.Among these examples, you can find one where  is used as a communication tool for the RPC approach. As for benchmarks,  is about 3 times faster than :Sending Commands is a pretty good abstraction. Itâ€™s similar to RPC, but doesnâ€™t limit us to just one action. Moreover, the Command Pattern can either replace RPC or be used as a tool for building it. Also it offers several advantages mentioned above and already has the high-performance implementation. All of this makes the Command Pattern a great choice for an API architectural style.Command Pattern Over the Network â†’]]></content:encoded></item><item><title>&quot;Why is the Rust compiler so slow?&quot;</title><link>https://sharnoff.io/blog/why-rust-compiler-slow</link><author>/u/jahmez</author><category>dev</category><category>reddit</category><category>rust</category><pubDate>Thu, 26 Jun 2025 11:04:07 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[I spent a month repeatedly building my website in Docker, and now have horrors to share.My website (the one you're reading right now) is mainly served by a single Rust binary.
For  now, every time I wanted to make a change, I would:Build a new statically linked binary (with --target=x86_64-unknown-linux-musl)So instead, I'd like to switch to deploying my website with containers (be it Docker, Kubernetes, or otherwise),
matching the vast majority of software deployed any time in the last decade.The only issue is that fast Rust builds with Docker are not simple.Rust in Docker, the simple wayTo get your Rust program in a container, the typical approach you might find would be something
like:Unfortunately, this will rebuild everything from scratch whenever there's any change.In my case, building from scratch takes about 4 minutes (including 10s to download the crates every time).Sure, it could be worse. But I've grown accustomed to speedy local builds, thanks to incremental compilation â€” I don't
want to wait that long on every tiny change!Rust in Docker, with better cachingThankfully, there's a tool to help with this!Luca Palmieri's  makes it easy to pre-build all of the dependencies as a separate layer in the docker
build cache, so that changes in your codebase only trigger re-compilation of your codebase (and not your dependencies).I'll save the detailed explanation for Luca's blog post, but broadly  creates a simplified "recipe" file from
the current workspace, which can be "cooked" to cache the dependencies without being invalidated by changes in the
workspace.My website pulls in a few hundred dependencies, so this  help!...

Unfortunately though, it doesn't have quite the speedup we're looking for â€” most of the time is still in the final
binary:Weirdly, only 25% of the time is actually spent on the dependencies! As far as I could tell, my code isn't doing
anything fundamentally unreasonable. It's ~7k lines of gluing together various larger dependencies (, ,
, among others.)(Just to double-check, I tried running  with . It really was just a single
invocation of  that took almost 3 minutes!)What's  doing for all that time?In addition to that cargo-timing-<timestamp>.html file, there's also a . We'll
just copy out the canonical version:...

And with a little bit of container wrangling... cargo-timing.html
 container ... we should be able to see what's going on! Let's have a look: There's not really much information there! shows a bunch of information about how long each crate took to compile. But here, we only care
about the compilation time of the final crate!That aside, this does help give us more accurate timing. Measuring outside the compiler adds some extra moving
pieces, or requires searching the output of  â€” so using 's self-reported timings will make more
precise analysis a bit easier, later on.Just to check, the value here of 174.1s roughly matches the "2m 54s" we saw from the  output.Actually asking  this timeThe post from fasterthanlime had one more tip we can use â€” 's self-profiling feature, via the 
flag.Normally, you'd probably run something like: rustc  --  self-profile
(note: This is using  to pass extra flags to , with  to allow using the 
unstable flags on a stable compiler.)Unfortunately, this won't work here â€” the change in arguments will invalidate the cached dependencies from
, and there's no equivalent way to pass additional  flags through .Instead, we can funnel everything via the  environment variable: chef cook .

 build .
This gives us files like web_http_server-<random-number>.mm_profdata, which we can move and extract from the image in
the same way as we did for .(note: It's much easier to automate if we remove the profiling data that was added from  before the
final build. That's omitted here, for brevity.)Actually using the profdata â€“ produces plaintext output summarizing the profiling dataBut let's install a couple of these to take a look at what we've got: https://github.com/rust-lang/measureme flamegraph summarize
I personally use Firefox, so we'll hold off on the chrome tracing stuff for now.First, with  (which itself has the  and  subcommands):So at a high level, the two biggest things are link-time optimization (LTO) and
LLVM_module_codegen_emit_obj, whatever that is.Let's see if we can dig a bit deeper with the flamegraph:(It's interactive! If you're curious, you can click through and play around with it yourself.)So there's presumably some inter-mingling going on between codegen and LTO: codegen_module_perform_lto ends up falling
through to both / and .But either way, we've got a problem with LTO: codegen_module_perform_lto took ~80% of the total time.It's time to talk about LTOThe Rust compiler splits up crates into "codegen units", handing each to LLVM as a separate module to compile.
, optimizations take place within each codegen unit, and then they're linked together at the end.LTO controls the set of optimizations that LLVM will make during that link-time â€” for example, inlining or
optimization across codegen units."thin" LTO â€” in theory, similar performance benefits to "fat" LTO, but less expensive to run"fat" LTO â€” maximum amount of LTO, across all crates at the same timeAnd if the LTO option is not specified,  uses "thin local LTO", which limits "thin" LTO only to a single crate at
a time.What are the current settingsTurns out that a few years back, I had set  in my :And, while we're at it,  enables all debug symbols (where they'd normally be excluded by default for the
 profile). Maybe we should take a look at that as well.Tweaking the (normal) settingsLet's take a look at the compile times and binary sizes for a variety of  and  settings (using
 like before, for more precise timing).At a high level: It seems like the worst cases here are full debug symbols adding 30-50% to the compilation time, and
"fat" LTO taking about  than with LTO fully disabled.That mostly tracks with what we'd expect from the documentation â€” yeah, fat LTO takes longer. But when we disable
everything, we're still looking at 50 seconds compiling the final binary!A brief note: 50 seconds is , actually!Look, 50 seconds is already a great improvement â€” and if it requires disabling LTO and debug symbols... my website
gets approximately zero load. It would be totally fine. It would be perfectly sustainable, even!There's no practical reason to keep digging here.But where's the fun in leaving it there? We should be able to do better, right?Another brief note: Can't we just use incremental compilation?It's slightly more complicated, but yes, absolutely â€” for local development, at least. Consistently loading the build
cache isn't straightforward, but you'd want to make the  directory accessible with a "cache mount" in the
dockerfile, and persist that target directory between builds.That said, I value that  have a clean environment every time, and I think it's worthwhile to go
through docker's own caching system â€” which is why I'm using  in the first place.Digging deeper: Et tu, ?If we disable LTO and debug symbols, compiling the final binary still takes 50 seconds to do... something.Let's re-run the self-profiling to check out what's going on.It's ~70% just  â€” i.e. where LLVM is optimizing the code. Before diving into LLVM itself, let's
see if there's any easier knobs we can tune.The  profile uses  by default â€” maybe if we reduce the optimization level, we'll spend less
time on it.We can actually do one better â€” since our dependencies are cached, and we only care about the final binary, we can get
most of the benefits by only reducing optimizations on the final binary:Like the previous options, there's a handful of s we can choose from:, , and  enable increasing levels of optimizations and  are different flavors of prioritizing binary sizeGoing through a handful of combinations here again:The baseline for  level of optimizations on the final binary is about 50 secondsIf we disable all optimizations, then it's pretty quick: only ~15sRust relies pretty heavily on optimizations, and while it'd probably be fine to just blanket-disable them for the final
binary, it'd be pretty cool if we can at least keep  optimizations!So let's try to figure out what's taking so long.'s self-profiling doesn't give us any more detail though,
so we'll have to get it from LLVM. â€“ emit LLVM profiling information as plaintext â€“ emit LLVM profiling information in the chrome tracing format (again with that one!)Profiling LLVM with  â€” plain textLike before, let's skip the chrome tracing format for now, and see what we can get from plain text. chef cook .

 build .
... Unfortunately if you try to  again, you'll immediately hit something like:[output clipped, log limit 2MiB reached]
This is because BuildKit (if you're using ~recent Docker on Linux) has default output limits that are pretty small.So after getting unlimited  output on the terminal, what's in it?
 â€” probably not what you want to be copying from your terminal, anyways.So, redirecting to a file inside docker and copying that out like before, we get a bunch of pass/analysis timing
reports. They each look something like this:===-------------------------------------------------------------------------===
                          Pass execution timing report
===-------------------------------------------------------------------------===
  Total Execution Time: 0.0428 seconds (0.0433 wall clock)

   ---User Time---   --System Time--   --User+System--   ---Wall Time---  â€” Name ---
   0.0072 ( 19.2%)   0.0015 ( 27.4%)   0.0086 ( 20.2%)   0.0087 ( 20.0%)  InstCombinePass
   0.0040 ( 10.8%)   0.0006 ( 10.8%)   0.0046 ( 10.8%)   0.0047 ( 10.8%)  InlinerPass
   0.0024 (  6.4%)   0.0010 ( 18.0%)   0.0034 (  7.9%)   0.0034 (  7.8%)  SimplifyCFGPass
   0.0022 (  5.9%)   0.0002 (  4.5%)   0.0025 (  5.7%)   0.0024 (  5.6%)  EarlyCSEPass
   0.0021 (  5.5%)   0.0001 (  1.5%)   0.0021 (  5.0%)   0.0022 (  5.0%)  GVNPass
   0.0015 (  4.0%)   0.0001 (  2.2%)   0.0016 (  3.8%)   0.0018 (  4.2%)  ArgumentPromotionPass

   ... entries here continue, and more passes below, for hundreds of thousands of lines ...
It certainly is  to parse and analyze these! But it's also hard to be certain about what you're looking at
when each pass execution is emitted separately and multi-threading can interfere with timing.Let's see if there's a better way to get good data.Profiling LLVM with  â€” actual tracing this timeWe skipped  earlier because it emits the chrome tracing format. chef cook .

 build .
It produces a bunch of $package-$hash.llvm_timings.json files, alongside the normal compilation artifacts:(Why ? Setting up rootless docker didn't work when I tried it a few years back, and I haven't bothered since)So, deleting  between  and the final build, we can extract the singular profile for the
final binary into web_http_server.llvm_timings.json.There's just one minor hiccup:It's . It's also all one single line!In theory though, a wide variety of tools should be able to process this:None of these options worked for me â€” but it's a big JSON file with a known format, how hard can it be?Turns out, a 1.4GiB single line of JSON makes all the normal tools complain:If you try to view it with , scrolling blocks on processing the entire fileIf you try to process it with , it has to load the entire 1.4GiB into 's internal format (which expectedly
takes up  more than the original 1.4GiB)Vim hangs when you open itAnd you probably don't want to just  it to the terminal â€” again, it's 1.4GiB!So instead, we can just look at a few hundred characters, at the start and end of the file:Matching this to the "JSON Object Format" from the chrome tracing spec, it seems we have a single JSON object like:
    ...
  We'd be able to process it with normal tools if we split each event into its own object. That could be something like: web_http_server.llvm_timings.json  web-http-server.llvm_timings.jsonl
(i.e.: turn  into a newline, strip the start of the object, strip the end of the object)And  we can process this.What's in LLVM's trace events?It looks like these events all have .According to the spec, the  field gives the type of event, and  refers to "complete" events, recording how long a
particular piece of work took on a given thread (). The duration in microseconds is given by .Aside from that, we also have  events:These are "metadata" events â€” in our case, not much useful information.And aside from these, there's nothing else:Going back to those  events â€” there were a bunch of them with . What else do we have?Neat! It looks like we might be able to demangle some of the symbols to get timings on individual functions.If we track what's being run and how long it takes, we should be able to get a better sense of why our compile time is
so long.Later on, there's aggregate information for certain types of events, like . These are equivalent to
the sum of the duration for that event type (in this case, ). Let's see kind of operations are taking the
most time:This particular run took ~110 seconds on a 16-core machine, so it's clear that some passes are being double-counted
(which makes sense â€” we see both , and it looks like 
probably just calls ).But broadly, it seems like optimization () and inlining () are the two parts taking a lot of
time â€” let's see if we can do anything about it.Can we make  any faster?LLVM has a bunch of arguments that can be configured, which  exposes through the  flag. At time of
writing (June 2025), there's somewhere in the region of ~100 options that mention inlining (via rustc -C llvm-args='--help-list-hidden').
In particular, there's a bunch of relevant options in the file controlling the cost analysis.Now, I'll be honest, I know  about LLVM's inlining. Most of the options refer to the "cost" associated
with the inlining, or with the function being inlined, etc. I'm flying mostly bind here. But there's a few arguments
that seem like decent candidates for tuning:--inlinedefault-threshold=225 â€” "Default amount of inlining to perform" â€” "Control the amount of inlining to perform"--inlinehint-threshold=325 â€” "Threshold for inlining functions with inline hint"For all of these, the "threshold" roughly means "allow inlining functions with cost  the threshold", so a higher
threshold means more inlining.So if we set all of these to some value (e.g., ), we should see that there's less inlining, and in turn faster
compile times..
(Why separate ? I couldn't find a way to make the whitespace happy through the  environment
variable â€” maybe it's possible if you set  in , but this solution worked ðŸ¤·)In any case, reducing to a threshold of 50  end up faster! About 42.2s, down from 48.8s.Here's what that looks like across a handful of values:(note: The smallest value is 1, and not zero. Why 1? Sometimes zero has special behavior â€“ setting to one seemed like a safer bet.)Of these, it's hard to say exactly what the best value is, but for my use case (remember: my website gets ~zero load!),
setting the thresholds to 10 looks promising. We'll hold off on that for now though.Can we make  any faster?Optimizing functions was the other expensive task we saw.The knobs here are much less clear to me (we're already at , and  compeltely disables
optimizations). So, let's see what exactly is taking so long.First, a brief look at the event format:In its raw form, each of the events'  field has the mangled symbol of the function being optimized. We can
"demangle" these back to the original Rust symbols with  â€” for example:It's worth noting that in the list above, while there's several serde_json::value::to_value items, they actually have
distinct hashes:... which makes sense, given that serde_json::value::to_value is a generic function â€” it might be that it's being
optimized with different generic parameters ("monomorphizations").Wait, why are we optimizing functions from other crates?The short answer is that optimization is done in the context of the crate where a function is monomorphized. So if we
define a type  and then call methods on , those methods  will first exist in the
context of our crate â€” meaning it gets compiled and optimized with the same configuration as our crate.With some knowledge about how the compiler works under the hood, this should hopefully make some sense â€” but from the
outside, it's certainly a little odd!What's actually taking so long?Now that we know what we're looking at, we can start doing some analysis. For example, by finding the individual
functions we spent the most time optimizing:(Why two separate  invocations? If we did just one, the / call would load the entire file
into a single array before any processing, which is one of the key operations we're trying to avoid)This is a surprising amount of time on individual functions! Profiling roughly doubled the total time to compile, but
even 1 second optimizing a single function is quite a long time!But let's look into more detail here. We've got:web_http_server::photos::PhotosState::new::{{closure}} â€” this is  closure inside a giant, 400-line async
function that does the setup for https://sharnoff.io/photosweb_http_server::run::{{closure}} â€” this is inside the main entrypoint (also async), but all the closures are small
error-handling, like .wrap_err_with(|| format!("failed to bind address {addr:?}"))Maybe there's something weird going on here!... and a handful of dependencies that also took a while:, we could break it down by the outermost crate:This is, of course, a very imperfect measure â€” the outermost crate isn't necessarily the best one to attribute the
compilation time to, and there's a lot of items like  that aren't captured by this simple filtering.
But all that aside, it's still surprising that there's so much from !Digging more into closures, with mangling v0The long compile times for closures seems very suspicious â€” maybe it's worth digging further. There's just one
problem: the symbols all end with  without saying  is taking all the time.As it turns out, there's an easy fix! As of June 2025,  currently uses the "legacy" symbol mangling format by
default, but there's a newer option with more information: the v0 format.We can enable it by adding RUSTFLAGS="-C symbol-mangling-version=v0" to our existing flags, which now look something
like:RUSTC_BOOTSTRAP=1 RUSTFLAGS="-Csymbol-mangling-version=v0 -Zllvm-time-trace" cargo build --timings ...
(aside: The issue for that feature's been open for 6 years, why hasn't it been merged yet? Turns out, there's a lot of
upstream work required to add support in common tools like  and . A lot of that has been done, but not yet
everything.)The end result of this is that we get  better symbols coming out of the LLVM trace. As an example, here's what
those serde_json::value::to_value symbols look like now:So not only do we get better closure labeling (see e.g. ) but we also get full generics for everything!Exactly what's taking so long  be much clearer now:... but those first few closures are : is_jpg  path s app  feed And if we remove these closures, replacing them with separately defined functions where possible, LLVM  reports
taking a long time to optimize  in the outer function.So where are those closures coming from?After dumping the LLVM IR with RUSTFLAGS="--emit=llvm-ir" (which places it into ) and searching
through the generated functions, I found a line like:That  function was a nested async function, defined directly inside  â€” so why did the
symbol say it was defined inside a closure?It's because internally represents async functions/blocks with a nested closure. So all of these places that
we had async functions where compiling  took a long time were actually just referring to the function itself!With some quick github searching (is:issue state:open async fn closure mangle), it turned out there was already an
open issue about this!Big async functions considered harmful?Going back to our list from before â€“ those async functions where LLVM takes a long time to optimize  are
really just spending a long time on the body of the function itself. It would make sense that big functions are hard to
optimize, and async functions doubly so.It's  straightforward to identify all of the functions inside the main crate that are taking a long time:Some of the most expensive functions here are around setup.Let's try breaking up just one function, to see if it helps. We'll start with .On the first attempt, I tried breaking it up while also preserving the number of s â€“ it's easy to do both
accidentally, and this would hopefully isolate which type of complexity is causing problems.Interestingly, this didn't help all that much: only reducing the total time from 5.3s to 4.7s.So to add to that, I tried merging a handful of neighboring s into their own functions â€” reducing the total
number from 10 to 3.But that took substantially longer! It increased from 4.66s to 6.24s!At this point, it seemed like there was something strange happening with async functions. Otherwise, why would splitting
into more functions make things worse?Under the hood, async functions desugar to a complex state machine. There might be something odd happening there, so if
we want to make that simpler in the caller, we can turn the  into a trait object to obscure the implementation
behind it (typically ).So this time, let's add a new function like:
    futfutand using it everywhere we . For example: candidates  candidates This one worked â€” down to 2.14s.So, a reduction from 5.3s to 2.14s â€“ a notable improvement, albeit with a lot of effort to get there. (and, for the
record, when I wrapped the futures with  instead of a fresh function, it didn't make a difference here).Re-running the build without profiling, this gives a total reduction from 48.8s to 46.8s. It's pretty small, but that's
from just a single function!(Aside: What about ? I tried it with and without â€“ after boxing, compile times weren't any better
with inlining disabled for those functions, but it's still helpful for ensuring better attribution on the LLVM
timings.)(Aside: What about disabling inlining on the  functions? I also tried wrapping the async functions with a
 implementation having  on its poll function. That helped , but wasn't as good as
boxing.)There's a number of approaches available â€” let's try:Reducing inlining with LLVM args;Breaking up expensive functions in the main crate; andRemoving generics from dependencies to prevent needing to compile it in the main crateSo, updating the final Dockerfile commands to read:

...

... and many more small changes to the main crate:... alongside some changes to larger dependencies:... gives us a final compile time of .Disabling LTO (and debug symbols!) got us to 51s (-71%) Changing to  on the final crate got us to 48.8s (-4%)Reducing inlining with  got us to 40.7s (-16%) Local changes got us to 37.7s (-7%) And changes with dependencies got us to 32.3s (-14%) While I did hit a lot of issues here, the tooling honestly worked really well â€“ and the documentation was sufficient for
someone with relatively little experience to make meaningful improvements to their codebase.Some of the issues are straightforward: bugfixes to provide a nicer experience for the next person that finds themselves
in a similar mess.Others are more complicated:The compile time of deep call graphs of async functions needs to be improved â€“ perhaps LLVM has a degenerate edge
case that's easy to trigger with what  generates, or maybe it's as simple as a bad heuristic that's
under-utilized in other languages.It  be worthwhile for  to special-case core::ptr::drop_in_place<T> so that it's compiled in the crate
that defines . That approach wouldn't work for everything â€“ for example, generic types â€“ but would prevent
downstream crates from needing to re-compile the same destructor multiple times.There might also be room for tooling to help with isolating which parts of a codebase are taking up the most time
during compilation (and providing recommendations to mitigate) â€“ although that's a longer project than just this post.In the meantime, setting  might be just fine :)(questions? comments? Feel free to reach out below!)]]></content:encoded></item><item><title>Programming as Theory Building: Why Senior Developers Are More Valuable Than Ever</title><link>https://cekrem.github.io/posts/programming-as-theory-building-naur/</link><author>/u/cekrem</author><category>dev</category><category>reddit</category><pubDate>Thu, 26 Jun 2025 10:55:42 +0000</pubDate><source url="https://www.reddit.com/r/programming/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Programming</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Blender 5.0 Introducing HDR Support On Linux With Vulkan + Wayland</title><link>https://www.phoronix.com/news/Blender-5.0-HDR-Linux-Wayland</link><author>/u/B3_Kind_R3wind_</author><category>dev</category><category>reddit</category><pubDate>Thu, 26 Jun 2025 10:50:19 +0000</pubDate><source url="https://www.reddit.com/r/linux/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Linux</source><content:encoded><![CDATA[
The upcoming Blender 5.0 3D modeling software application is introducing High Dynamic Range (HDR) display support on Linux when making use of Wayland -- no X11 support for HDR -- and Vulkan graphics accelerator.
HDR support for Blender 5.0 on Linux is currently considered experimental. Enabling the HDR support on Linux for the Blender creator software requires having a High Dynamic Range display (of course) and be running on a Wayland desktop, enabling Vulkan API acceleration rather than OpenGL, and enabling the feature currently deemed experimental.
As the Blender HDR support on Linux has been tested with a limited number of configurations so far, it's currently being treated as experimental. Depending upon testing feedback it may be promoted beyond being an "experiment" feature or Blender 5.0, so we'll see. In my testing of the latest Blender 5.0 alpha build on Ubuntu Linux with Samsung Odyssey OLED G8 G81SF and ASUS ROG Swift OLED PG27UCDM displays, this experimental feature was working out fine in my basic tests.
More details on this initial HDR support for Blender 5.0 on Linux with Vulkan/Wayland can see this Blender DevTalk thread for all the details and to share your feedback on any testing.]]></content:encoded></item><item><title>Weekly: This Week I Learned (TWIL?) thread</title><link>https://www.reddit.com/r/kubernetes/comments/1lkw82j/weekly_this_week_i_learned_twil_thread/</link><author>/u/gctaylor</author><category>dev</category><category>reddit</category><category>k8s</category><pubDate>Thu, 26 Jun 2025 10:00:58 +0000</pubDate><source url="https://www.reddit.com/r/kubernetes/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Kubernetes</source><content:encoded><![CDATA[Did you learn something new this week? Share here!]]></content:encoded></item><item><title>My Journey from Java to Go: Why I Think Go&apos;s Packages Are Actually Better</title><link>https://www.reddit.com/r/golang/comments/1lkvjpi/my_journey_from_java_to_go_why_i_think_gos/</link><author>/u/hosmanagic</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Thu, 26 Jun 2025 09:17:04 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[When I was going through The Go Programming Language (Kernighan et al.), I thought Iâ€™d just skim the chapter on packages. In Java, at least, it's a relatively unremarkable topicâ€”something you donâ€™t spend much time thinking about.But Go is different. Interestingly, Go packages made me think more deeply about code organization than Java packages ever did.The more I reflected on Go packagesâ€”especially while writing this articleâ€”the more they made sense. And to be honest, I think Java should reconsider some of its package conventions, as they might be one of the reasons for its "notorious" verbosity.]]></content:encoded></item><item><title>Snow - Classic Macintosh emulator</title><link>https://snowemu.com/</link><author>ColinWright</author><category>dev</category><category>hn</category><pubDate>Thu, 26 Jun 2025 09:08:00 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[Snow emulates classic (Motorola 680x0-based) Macintosh computers. It features a graphical user interface to operate the emulated machine and provides extensive debugging capabilities. The aim of this project is to emulate the Macintosh on a hardware-level as much as possible, as opposed to emulators that patch the ROM or intercept system calls.It currently emulates the Macintosh 128K, Macintosh 512K, Macintosh Plus, Macintosh SE, Macintosh Classic and Macintosh II.There is a limited online demo available (only the emulated machine, no user interface or other functionality from the full software).Currently, only bleeding edge builds are available. These get generated automatically as work progresses
on the emulator.]]></content:encoded></item><item><title>Run web compatible Half-Life or Counter Strike 1.6 dedicated server using xash3d-fwgs and go pion</title><link>https://www.reddit.com/r/golang/comments/1lktz9l/run_web_compatible_halflife_or_counter_strike_16/</link><author>/u/yohimik</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Thu, 26 Jun 2025 07:32:08 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[Hey there Recently I made a cgo wrapper for xash3d-fwgs engine which runs hl and cs Furthermore, I added a webrtc example to demonstrate how to connect to the server from the web why go? go has backend session based engines like nakama, so it's easy to run something like cs2 using just cs1.6 and gohttps://github.com/yohimik/goxash3d-fwgs]]></content:encoded></item><item><title>The importance of kindness in engineering</title><link>https://ashouri.xyz/post/kindnessinengineering</link><author>/u/AlexandraLinnea</author><category>dev</category><category>reddit</category><pubDate>Thu, 26 Jun 2025 07:13:47 +0000</pubDate><source url="https://www.reddit.com/r/programming/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Programming</source><content:encoded><![CDATA[There are many traits I have seen successful engineers have over my years observing and being part of development teams but there is one trait above all others that the most successful engineers have and that is kindness.I can hear your eyes rolling from here but hear me out.Being kind does not mean being a doormat, minding your pâ€™s and qâ€™s or biting your lip when your team takes an action you disagree with. Sometimes it can mean being direct, arguing or even being a bit too abrupt.Remember when you just started out and a senior sat with you and explained some basic concepts behind their code without judgement and patience?Remember when you saw a colleague working on a gnarly problem and you stepped in to pair with them or vice versa?Remember when you were extremely tired and someone chased you for an update on a piece of work that was not a priority. Instead of snapping at them you took a breath and explained why you could not look into it right now but would circle back to them in a week or so?Kindness is not only about reactive patience and being helpful but also influences the way we work. For me a feature of kindness in engineering is keeping documentation like readmeâ€™s up to date because you want to help cut down on the time it would take engineers to make progress in future on the same codebase.Kindness can also be applied to writing code. For example when you write code you optimise on your teamâ€™s ability to read and comprehend the codebase because you want your colleagues to have an easier time onboarding and delivering features in the future rather than optimising on your own personal velocity.Kindness can even mean you choose not to make code more readable because your empathy leads you to believing that rearranging a pattern that the team has come to become familiar with would lead to them having to spend more time to understand changes in a codebase with low churn.Kindness also means that we write error messages with the user in mind and prioritise product features over and above technical implementation detail because we have of empathy for our users.Kindness means that you prioritise tickets that enable the team to ship quicker by reducing setup time through things like docker compose or makefiles.Kindness leads to greater cooperation, collaboration and transparency. The most productive teams I have worked on were not smartest but the kindest and the least productive team I ever worked on was ironically probably the smartest.There are lots of good engineers in the world but in my opinion the best engineers are the kindest engineers because they not only deliver world class products but they also raise the effectiveness of the entire team.]]></content:encoded></item><item><title>Optimizing Change-Driven Architectures - A New Cloud-Native Model with Drasi</title><link>https://www.youtube.com/watch?v=PsY1OilC3A0</link><author>CNCF [Cloud Native Computing Foundation]</author><category>dev</category><category>k8s</category><enclosure url="https://www.youtube.com/v/PsY1OilC3A0?version=3" length="" type=""/><pubDate>Thu, 26 Jun 2025 07:00:22 +0000</pubDate><source url="https://www.youtube.com/channel/UCvqbFHwN-nwalWPjPUKpvTA">Dev - CNCF</source><content:encoded><![CDATA[Building change-driven solutions that respond to specific changes in distributed data is challenging.  This talk introduces Drasi, a CNCF Sandbox project that simplifies the design and implementation of change-driven architectures by codifying the continuous query and reaction patterns, removing the need to write custom code.]]></content:encoded></item><item><title>Looking for an Open Source Kubernetes Replication Tool for Periodic Cluster Sync (Disaster Recovery Use Case)</title><link>https://www.reddit.com/r/kubernetes/comments/1lktgyy/looking_for_an_open_source_kubernetes_replication/</link><author>/u/Tulpar007</author><category>dev</category><category>reddit</category><category>k8s</category><pubDate>Thu, 26 Jun 2025 06:59:03 +0000</pubDate><source url="https://www.reddit.com/r/kubernetes/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Kubernetes</source><content:encoded><![CDATA[I have 2 Kubernetes clusters: one is production, the other is a standby. I want to periodically replicate all data (pods, PVCs, configs, etc.) from the prod cluster to the standby cluster.Goal: if prod goes down, the standby can quickly take over with minimal data loss.Looking for an open source tool that supports:PVC + resource replicationSo far Iâ€™ve seen: Velero, VolSync, TrilioVault CE, Stash â€” any recommendations or real-world experiences?]]></content:encoded></item><item><title>LLM code generation may lead to an erosion of trust</title><link>https://jaysthoughts.com/aithoughts1</link><author>CoffeeOnWrite</author><category>dev</category><category>hn</category><pubDate>Thu, 26 Jun 2025 06:07:49 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>How much code does that proc macro generate?</title><link>https://nnethercote.github.io/2025/06/26/how-much-code-does-that-proc-macro-generate.html</link><author>/u/nnethercote</author><category>dev</category><category>reddit</category><category>rust</category><pubDate>Thu, 26 Jun 2025 05:40:51 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>CNL: Integrating MCP metadata in your internal developer platform</title><link>https://www.youtube.com/watch?v=MhyMLykUMUc</link><author>CNCF [Cloud Native Computing Foundation]</author><category>dev</category><category>k8s</category><enclosure url="https://www.youtube.com/v/MhyMLykUMUc?version=3" length="" type=""/><pubDate>Thu, 26 Jun 2025 04:50:22 +0000</pubDate><source url="https://www.youtube.com/channel/UCvqbFHwN-nwalWPjPUKpvTA">Dev - CNCF</source><content:encoded><![CDATA[MCP, Model Context Protocol, is clearly the hot topic of 2025 and while we are seeing more and more interesting use cases around this, no one has really yet focused on all the metadata that MCP brings to the table: Tools description, Tool parameters description, prompt description. All of this is really useful information that can be used by the developer building AI Infused applications.

Itâ€™s also totally aligned with the Platform Engineering vision which tries to streamline the service catalogs to its platform user.

Join me in the mainly live coding session to see how to integrate MCP Metadata into your Platform Engineering strategy.]]></content:encoded></item><item><title>How Do You Handle Orphaned Processes?</title><link>https://www.reddit.com/r/golang/comments/1lknghk/how_do_you_handle_orphaned_processes/</link><author>/u/Hamguy1234</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Thu, 26 Jun 2025 01:27:04 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[For a little bit of context, I'm currently writing a library to assist in the creation of a chess GUI. This library implements the UCI chess protocol, and as part of that it will be necessary to run a variety of uci compatible chess engines.The straightforward approach is to use , and then if the engine begins to misbehave call . The obvious issue with this is that child processes are not killed and in the case of a chess engine these child processes could run for a very long time while taking a lot of cpu. To me it seems like it comes down to two options, but if Go has something more graceful than either of these I would love to know.Ignore child processes and hope they terminate promptly, (this seems to put too much faith in the assumption that other programmers will prevent orphaned processes from running for too long.)Create OS dependent code for killing a program (such as posix process groups).The second option seems to be the most correct, but it is more work on my side, and it forces me to say my library is only supported on certain platforms. ]]></content:encoded></item><item><title>How do you see the current state and future of Rust? And, will Rust get popular in game dev?</title><link>https://www.reddit.com/r/rust/comments/1lkmloc/how_do_you_see_the_current_state_and_future_of/</link><author>/u/lettsten</author><category>dev</category><category>reddit</category><category>rust</category><pubDate>Thu, 26 Jun 2025 00:45:41 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[I'm a hobbyist who've been eyeing Rust for a while, dabbled a bit. As a hobbyist I don't have my finger on the industrial pulse and would like to hear your thoughts and insights about the current state of Rust in generalâ€”things that are hard for me to look up on a wiki page and that requires the insights of those of you who work with it regularly or semi-regularly.What do you think about the current state of Rust as a language, ecosystem and community?I've seen some flak about async in Rust. Do you agree with it? How happy are you about the current state of the language? Is Rust your favourite language? What are your biggest gripes with the language, and do you think they will be resolved within the next 2-5 years?From what I understand, Rust jobs are rare. Is your impression that they are becoming more common? Do you think Rust will become more prevalent than C or C++ at some point?Are you happy with the Rust ecosystem, tooling, library availability and so on? Which areas shine, and which are most lacking? What are your opinions on the Rust community, in terms of demographics, friendliness, activity, open-source work and so on?My impression is that Rust is most suited to systems level programming, especially critical components where correctness is essential. Do you see Rust taking over other segments or domains?Reason I ask these questions is honestly because I would love to get psyched about Rust again, and because I would like an honest and well-informed impression of the current state of the language.Any and all insights are very welcome!Edit: I'm mostly interesting in the state of Rust as a whole, the gamedev question from the subject is secondary.]]></content:encoded></item><item><title>DockedUp: A Terminal Dashboard for Docker Containers, Built in Python</title><link>https://github.com/anilrajrimal1/dockedup</link><author>/u/Fragrant_Letter8595</author><category>dev</category><category>reddit</category><pubDate>Thu, 26 Jun 2025 00:42:33 +0000</pubDate><source url="https://www.reddit.com/r/programming/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Programming</source><content:encoded><![CDATA[Iâ€™ve been working on , a CLI tool that makes monitoring Docker containers easier and more intuitive. If youâ€™re tired of juggling , , and switching terminals to check logs or restart containers, this might be for you!DockedUp is a real-time, interactive dashboard that displays your Docker containersâ€™ status, health, CPU, and memory usage in a clean, color-coded terminal view. It automatically groups containers by docker-compose projects and uses emojis to make status (Up ðŸŸ¢, Down ðŸ”´) and health (Healthy âœ…, Unhealthy âš ï¸) instantly clear. Navigate containers with arrow keys and use hotkeys to: - : View live logs - : Restart a container - : Stop a container - : Open a shell inside a containerDockedUp is designed for developers and DevOps engineers who work with Docker containers and want a quick, unified view of their environment without leaving the terminal. Itâ€™s ideal for those managing docker-compose stacks in development or small-scale production setups. Whether youâ€™re a Python enthusiast, a CLI lover, or a DevOps pro looking to streamline workflows, DockedUp is built to save you time and hassle.Unlike  and , which require multiple commands and terminal switching, DockedUp offers a single, live-updating dashboard with interactive controls. Compared to tools like Portainer (web-based) or lazydocker (another CLI), DockedUp is lightweight, focuses on docker-compose project grouping, and integrates emoji-based visual cues for quick status checks. Itâ€™s Python-based, easy to install via PyPI, and doesnâ€™t need a web server, making it a great fit for terminal-centric workflows.Itâ€™s on PyPI and takes one command to install (I recommend  for CLI tools): bash pipx install dockedup  Or: bash pip install dockedup  Then run  to start the monitor. Check out the GitHub repo for more details and setup instructions. If you like the project, Iâ€™d really appreciate a â­ on GitHub to help spread the word!Iâ€™d love to hear your thoughtsâ€”any features youâ€™d like to see or issues you run into? Contributions are welcome (itâ€™s MIT-licensed). Whatâ€™s your go-to way to monitor Docker containers?Thanks for checking it out! ðŸš€]]></content:encoded></item><item><title>ArgoCD deploying sensitive non-Secrets</title><link>https://www.reddit.com/r/kubernetes/comments/1lkmgnf/argocd_deploying_sensitive_nonsecrets/</link><author>/u/nullvar2000</author><category>dev</category><category>reddit</category><category>k8s</category><pubDate>Thu, 26 Jun 2025 00:39:01 +0000</pubDate><source url="https://www.reddit.com/r/kubernetes/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Kubernetes</source><content:encoded><![CDATA[Happy Wednesday fellow Kubernetes enthusiasts! I have a homelab cluster that I've spent quite a bit of time learning and implementing Gitops using ArgoCD. I'm still planning out my secrets management, but I've run into a question that's somewhat related. How do I manage sensitive parameters in non-secrets? I'm talking about things like hostnames, domains, IP addresses, etc. For example, ingresses have my purchased domain included and even though I'm only using internal DNS records for them, I'd rather not have that kind of information public on Github.After some research, it would seem FluxCD has a post build variable substitution capability that could take care of this, but I'd like to find a solution using Kustomize or ArgoCD. Does anybody have another solution to this kind of data? Am I just being too paranoid about this?]]></content:encoded></item><item><title>lightning-image-viewer 0.2.0</title><link>https://github.com/shatsky/lightning-image-viewer/releases/tag/v0.2.0</link><author>/u/shatsky</author><category>dev</category><category>reddit</category><pubDate>Thu, 26 Jun 2025 00:10:10 +0000</pubDate><source url="https://www.reddit.com/r/linux/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Linux</source><content:encoded><![CDATA[Fast and lightweight desktop image viewer featuring minimalistic "transparent fullscreen overlay" UI/UX with controls similar to map apps. This is 1st release featuring pre-built binaries (for Ubuntu 25.04 and Windows, built on GitHub CI/CD) and web demo ( https://shatsky.github.io/lightning-image-viewer/ )   submitted by    /u/shatsky ]]></content:encoded></item><item><title>Puerto Rico&apos;s Solar Microgrids Beat Blackout</title><link>https://spectrum.ieee.org/puerto-rico-solar-microgrids</link><author>ohjeez</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 23:41:16 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[When power went out across all of Puerto Rico on 16 April, a lot of the lights in the town of Adjuntas stayed on. There, nestled in the mountains on the midwestern side of the island, a combination of experimental microgrids, solar panels, and storage kept power on for many businesses and residents. The rest of the island waited over 24 hours, and in some cases longer, for electricity to be restored.The blackout was the latest in a series of power interruptions that have come to define Puerto Ricoâ€™s aging electrical grid. Vegetation was to blame for Aprilâ€™s blackout, according to LUMA Energy, the private company that manages the islandâ€™s grid. A faulty old cable triggered the near total blackout on New Yearâ€™s Eve 2024, the company said. Tropical storm Ernestoâ€™s strong winds knocked out half of the islandâ€™s power in August 2024. The problems are the result of decades of mismanagement and disinvestment in the islandâ€™s grid infrastructure. Neglecting to keep up with regular maintenance and failing to meet increasing demand for power generation have contributed to the disarray. The long-standing issues set the stage for the grid to be crushed in 2017 by Hurricane Maria, the United Statesâ€™ second deadliest, which plunged Puerto Rico into months-long darkness and claimed nearly 3,000 lives. After that hurricane, the islandâ€™s state-run utility, Puerto Rico Electric Power Authority (PREPA), contracted with private entities for power generation, transmission, and distribution in the hopes of fixing the grid. Over $20 billion in U.S. federal disaster relief was awarded by the Federal Emergency Management Agency (FEMA) to improve the grid and boost its resilience. Yet bureaucratic red tape and politics in Puerto Rico and on the U.S. mainland have hindered much of that money from being spent.Now, the U.S. Department of Energy plans to redirect$365 million previously earmarked for rooftop solar toward infrastructure on Puerto Ricoâ€™s majority fossil-fuel-powered grid, according to an announcement from the agency on May 21. The money will  support â€œpractical fixes and emergency activities that offer a faster, more impactful solution to the current crisis,â€ the agency said. This will include â€œsystem flexibility and response, power flow and control, component strength, supply security, and safety,â€ according to the announcement. The move sparked an outcry from Puerto Ricoâ€™s solar industry and U.S. Representative Nydia Velazquez of New York. Velazquez, who is from Puerto Rico, called the move â€œshamefulâ€ in a post on X, saying the money was designed to serve vulnerable communities on the island.Solar Energyâ€™s Role in Puerto Ricoâ€™s GridThe ongoing political turmoil and bottlenecked federal funding have prompted the widespread development of solar-plus-storage systems across the island that are privately financed via leases, loans, or Power Purchase Agreements (PPAs). Each month, the island sees around 4,000 solar-plus-battery storage systems come online, RÃºa-Jovet says. These installations are connected to the grid but can also operate during blackouts.At the end of March, LUMA reported over 1.14 gigawatts of grid-connected distributed solar capacity, with an additional 2.34 gigawatt-hours of distributed batteries connected to the grid. Solar power produces over 2 terawatt-hours of electricity each year, which accounts for more than 12.5 percent of Puerto Ricoâ€™s total residential electricity consumption annually. The majority of that power is generated from residential solar, and capacity continues to grow as more residents install systems with private financing. Adjuntas, which has a population of about 18,000, took a more experimental approach. The townâ€™s local environmental nonprofit Casa Pueblo teamed up with researchers from the U.S. Department of Energyâ€™s Oak Ridge National Laboratory in Oak Ridge, Tenn., to develop a way to connect multiple microgrids to exchange power with one another, all without having to be hooked up to Puerto Ricoâ€™s grid. The strategy, called grid orchestration, ensures that if power is knocked out on one of the installations, the others arenâ€™t compromised. Itâ€™s what kept multiple areas in Adjuntas electrified during Aprilâ€™s island-wide blackout.During the blackout, Casa Pueblo and the Oak Ridge researchers were completing the testing of the orchestration strategy with three of the five microgrids connected in Adjuntas. These three microgrids are connected to the grid via net metering. The remaining two grids are isolated.â€œBy decentralizing, itâ€™s creating a more resilient and redundant energy setup,â€ says Arturo Massol-DeyÃ¡, Casa Puebloâ€™s executive director. â€œEngineers will say: If you have redundancy, thatâ€™s more resilient; thatâ€™s better.â€The teams demonstrated trading energy from one microgrid to the other, and vice versa. This kind of transfer enables the system to overcome energy limitations during peak demand times and draw from additional storage at night when the sun is down. Together, the townâ€™s five microgrids provide 228 kilowatts of photovoltaic capacity and an additional 1.2 megawatt-hours of storage, which serve residences and 15 commercial businesses. Itâ€™s a small amount of power, but an example of a way for systems to operate independently from the grid. Expanding Microgrid Connections in AdjuntasMoving forward, Massol-DeyÃ¡â€™s plan is to continue improving and expanding the bottom-up approach to microgrid connections. On April 20, Casa Pueblo launched a lab in Adjuntas called the Community Laboratory for the Energy Transition with the goal of bringing together academics and industry experts to test new microgrid technology as it develops. The next milestone, Massol-DeyÃ¡ says, will be successfully connecting microgrids that are not in close geographic proximity. â€œIn Adjuntas, weâ€™re bridging the gap between simulation and theoretical work with a real application,â€ he says.As warmer months approach, Puerto Rico is gearing up island-wide for a season of power failures as energy demand will likely exceed Puerto Ricoâ€™s generation capacity. This will likely be compounded by a stronger-than-normal Atlantic hurricane season. RÃºa-Jovet maintains that solar and batteries are an easily dispatchable resource that make a â€œgood dentâ€ in resiliency against island-wide power failures. Massol-DeyÃ¡ agrees and says that even with the government turning toward what he calls an â€œobsoleteâ€ model of fossil fuel power, the Puerto Rican people are embracing solar.â€œItâ€™s not top-down: Itâ€™s not by LUMA, itâ€™s not by the government. It has been pushed by the people. You have a huge and significant investment by the people on solar,â€ Massol-DeyÃ¡ says. ]]></content:encoded></item><item><title>Define policy forbidding use of AI code generators</title><link>https://github.com/qemu/qemu/commit/3d40db0efc22520fa6c399cf73960dced423b048</link><author>todsacerdoti</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 23:26:55 +0000</pubDate><source url="https://news.ycombinator.com/best">HN</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Wails goroutine question</title><link>https://www.reddit.com/r/golang/comments/1lkjzr3/wails_goroutine_question/</link><author>/u/New_Okra5546</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Wed, 25 Jun 2025 22:46:42 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[Wails is a lightweight and fast Electron/Tauri alternative for Go, and uses WebKit2What makes Wails special is the following:Bind your Go code to the frontend so it can be called from JavaScriptNow if you created lets say a new Wails + React project. It has a bound go method Greet, which you can call via JavaScript. I noticed, that the go methods like Greet are by default executed on another goroutine id. So I don't have to add goroutines myself. Of course, I don't want to hang my app while e.g. an api call is underway.I've searched for "go " and "go func", but didn't see it. ThanksEdit 1: In the frontend, this calls the bound go method:window.WailsInvoke('C' + JSON.stringify(payload));Then in the go side I think this receives the message, which starts with 'C' if not obfuscated:and on Line 45 registeredMethod.Call(args)and on Line 72 , but I didn't see a go keyword yet, so I am still wondering where it goes into a different goroutine id to not block id 1. The go library 'reflect' is involved, but AI says "The Go  package itself does not provide any functionality to run methods in a different goroutine "secretly" or automatically."Am I wrong and I have to implement a goroutine myself in each bound go method to not block the wails app, that runs on id 1?]]></content:encoded></item><item><title>Stop talking about Fedora change proposals like they have already decided on it.</title><link>https://www.reddit.com/r/linux/comments/1lkjj8l/stop_talking_about_fedora_change_proposals_like/</link><author>/u/wowieniceusername</author><category>dev</category><category>reddit</category><pubDate>Wed, 25 Jun 2025 22:27:13 +0000</pubDate><source url="https://www.reddit.com/r/linux/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Linux</source><content:encoded><![CDATA[Seriously. Everytime some controversial change gets proposed on Fedora, someone reports on it without making it clear that it only  get through after enough thought and discussion, and the entire comment section devolves into people yelling about this and that even though literally anybody can propose a change over there. And alot of the time those proposals don't even get through.I get that potential major change is big news and a good source for discussions but dear god in the past week alone I've seen two different news about a Fedora change proposal where people act like the developers have already decided on it and it has zero pushback and is going to happen soon (removing 32-bit support being one of them). I don't even use Fedora but it gets really annoying. Atleast make it clear.With that said I realized that readers will probably just be stupid and will overreact regardless but I don't think it hurts to be as clear as possible.]]></content:encoded></item><item><title>Bazzite Would Shut Down If Fedora Goes Ahead With Removing 32-Bit</title><link>https://linux.slashdot.org/story/25/06/25/2042242/bazzite-would-shut-down-if-fedora-goes-ahead-with-removing-32-bit?utm_source=rss1.0mainlinkanon&amp;utm_medium=feed</link><author>BeauHD</author><category>dev</category><category>slashdot</category><pubDate>Wed, 25 Jun 2025 22:10:00 +0000</pubDate><source url="https://linux.slashdot.org/">Dev - Slashdot - Linux</source><content:encoded><![CDATA[If Fedora drops 32-bit support, the gaming-focused Bazzite project would be forced to shut down, according to its founder Kyle Gospodnetich. "As much as I'd like this change to happen, it's too soon," said Gospodneitch in a post. "This change would kill off projects like Bazzite entirely right as Fedora is starting to make major headway in the gaming space. Neal Gompa already pointed out basic use cases that would be broken even if someone built the packages Steam itself needs to function."
 
He continued: "It's also causing irreparable damage to Fedora from a PR standpoint. I have been inundated all day with people sharing news articles and being genuinely concerned Steam is gong to stop working on their Fedora/Bazzite machines. I would argue not only should this change be rejected, the proposal should be rescinded to limit further damage to Fedora as a project. Perhaps open a separate one to talk about changing build architecture to build fewer 32-bit packages?"
 
When pushed further, Gospodnetich said: "I'm speaking as it's founder, if this change is actually made as it is written the best option for us is to just go ahead and disband the project."]]></content:encoded></item><item><title>What are your must have Go packages?</title><link>https://www.reddit.com/r/golang/comments/1lkioqb/what_are_your_must_have_go_packages/</link><author>/u/fenugurod</author><category>dev</category><category>reddit</category><category>go</category><pubDate>Wed, 25 Jun 2025 21:51:27 +0000</pubDate><source url="https://www.reddit.com/r/golang/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Go</source><content:encoded><![CDATA[I've been using for many years and I tend to use the same stack all the time because it works and I know the packages well enough, but I'm wondering if there is anything new that it's worth exploring.This is a very open question so feel free to answer whatever you want. For example this is what I need for my Go services:Tests: testify and testcontainers   submitted by    /u/fenugurod ]]></content:encoded></item><item><title>A new pyramid-like shape always lands the same side up</title><link>https://www.quantamagazine.org/a-new-pyramid-like-shape-always-lands-the-same-side-up-20250625/</link><author>robinhouston</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 20:01:07 +0000</pubDate><source url="https://news.ycombinator.com/best">HN</source><content:encoded><![CDATA[Achieving the right balance between the weight of the loading zone and the weight of the rest of the tetrahedron is easy in the abstract realm of mathematics â€”Â you can define the weight distribution without a care for whether itâ€™s physically possible. You might, for instance, let parts of the shape weigh nothing at all, while concentrating a large amount of mass in other parts.But that wasnâ€™t entirely satisfying to the mathematicians. AlmÃ¡di, Dawson and Domokos wanted to hold the shape in their hands. Was it possible to make a monostable tetrahedron in the real world, with real materials?The team returned to their computer search. They considered the various ways in which monostable tetrahedra might tip onto their stable face. For instance, one kind of tetrahedron might follow a very simple path: Face A tips to Face B, which tips to Face C, which tips to Face D. But in a different tetrahedron, Face A might tip to Face B, and both Face B and Face D will tip to Face C.The loading zones for these different tetrahedra look very different. The team calculated that to get one of these â€œfalling patternsâ€ to work, they would need to construct part of the shape out of a material about 1.5 times as dense as the sunâ€™s core.They focused on a more feasible falling pattern. Even so, part of their tetrahedron would have to be about 5,000 times as dense as the rest of it. And the materials had to be stiff â€” light, flimsy materials that could bend would ruin the project, since itâ€™s easy to make a round or smooth shape (like the roly-poly) monostable.In the end, they designed a tetrahedron that was mostly hollow. It consisted of a lightweight carbon fiber frame and one small portion constructed out of tungsten carbide, which is denser than lead. For the lighter portions to have as little weight as possible, even the carbon fiber frames had to be hollow.With this blueprint in hand, Domokos got in touch with a precision engineering company in Hungary to help build the tetrahedron. They had to be incredibly accurate in their measurements, even when it came to the weight of the tiny amounts of glue used to connect each of the shapeâ€™s faces. Several frustrating months and several thousand euros later, the team had a lovely model that didnâ€™t work at all. Then Domokos and the chief engineer of the model spotted a glob of stray glue clinging to one of its vertices. They asked a technician to remove it. About 20 minutes later, the glue was gone and AlmÃ¡di received a text from Domokos.â€œIt works,â€ the message read. AlmÃ¡di, who was on a walk, started jumping up and down in the street. â€œSeeing the lines on the computer is very far from reality,â€ he said. â€œThat we designed it, and it works, itâ€™s kind of fantastic.â€â€œI wanted to be an architect,â€ he added. â€œSo this is still very strange for me â€” how did I end up here?â€In the end, the work on monostable tetrahedra didnâ€™t involve any particularly sophisticated math, according to Richard Schwartz of Brown University. But, he said, itâ€™s important to ask this kind of question in the first place. Itâ€™s the kind of problem thatâ€™s often easiest to overlook. â€œItâ€™s a surprising thing, a leap, to conjecture that these things would exist,â€ Schwartz said.At the moment, itâ€™s not clear what new theoretical insights the model of the monostable tetrahedron will provide â€” but experimenting with it might help mathematicians uncover other intriguing questions to ask about polyhedra. In the meantime, Domokos and AlmÃ¡di are working to apply what they learned from their construction to help engineers design lunar landers that can turn themselves right side up after falling over.In any case, sometimes you just need to see something to believe it, Schwartz said. â€œEven for theoretical math, geometry especially, people are kind of right to be skeptical because itâ€™s quite hard to reason spatially. And you can make mistakes, people do.â€â€œConway didnâ€™t say anything about it, he just suggested it â€” never proved it, never proved it wrong, nothing. And now here we are, I donâ€™t know, 60 years later,â€ AlmÃ¡di said. â€œIf he were still alive, we could put this on his desk and show him: You were right.â€]]></content:encoded></item><item><title>-2000 Lines of code</title><link>https://www.folklore.org/Negative_2000_Lines_Of_Code.html</link><author>xeonmc</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 19:53:13 +0000</pubDate><source url="https://news.ycombinator.com/best">HN</source><content:encoded><![CDATA[In early 1982, the Lisa software team was trying to buckle down for the big push to ship the software within the next six months.  Some of the managers decided that it would be a good idea to track the progress of each individual engineer in terms of the amount of code that they wrote from week to week.  They devised a form that each engineer was required to submit every Friday, which included a field for the number of lines of code that were written that week.
Bill Atkinson, the author of Quickdraw and the main user interface designer, who was by far the most important Lisa implementer, thought that lines of code was a silly measure of software productivity.  He thought his goal was to write as small and fast a program as possible, and that the lines of code metric only encouraged writing sloppy, bloated, broken code.
He recently was working on optimizing Quickdraw's region calculation machinery, and had completely rewritten the region engine using a simpler, more general algorithm which, after some tweaking, made region operations almost six times faster.  As a by-product, the rewrite also saved around 2,000 lines of code.
He was just putting the finishing touches on the optimization when it was time to fill out the management form for the first time.  When he got to the lines of code part, he thought about it for a second, and then wrote in the number: -2000.
I'm not sure how the managers reacted to that, but I do know that after a couple more weeks, they stopped asking Bill to fill out the form, and he gladly complied.
  ]]></content:encoded></item><item><title>Writing Toy Software Is A Joy</title><link>https://blog.jsbarretto.com/post/software-is-joy</link><author>/u/NXGZ</author><category>dev</category><category>reddit</category><pubDate>Wed, 25 Jun 2025 19:47:46 +0000</pubDate><source url="https://www.reddit.com/r/programming/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Programming</source><content:encoded><![CDATA[I am a huge fan of Richard Feymanâ€™s famous quote:â€œWhat I cannot create, I do not understandâ€I think itâ€™s brilliant, and it remains true across many fields (if youâ€™re willing to be a little creative with the
definition of â€˜createâ€™). It is to this principle that I believe I owe everything Iâ€™m truly good at. Some will tell you
to avoid reinventing the wheel, but theyâ€™re wrong: you  build your own wheel, because itâ€™ll teach you more about
how they work than reading a thousand books on them ever will.In 2025, the beauty and craft of writing software is being eroded. AI is threatening to replace us (or, at least, the
most joyful aspects of our craft) and software development is being increasingly commodified, measured, packaged, and
industrialised. Software development needs more simple joy, and Iâ€™ve found that creating toy programs is a great way to
remember why I started working with computers again.Toy programs follow the 80:20 rule: 20% of the work, 80% of the functionality. The point is  to build
production-worthy software (although it is true that some of the best production software began life as a toy).
Aggressively avoid over-engineering, restrict yourself to only whatever code is necessary to achieve your goal. Have
every code path panic/crash until youâ€™re forced to implement it to make progress. You might be surprised by just how
easy it is to build toy versions of software you might previously have considered to be insummountably difficult to
create.Iâ€™ve been consistently surprised by just how often some arcane nugget of knowledge Iâ€™ve acquired when working on a toy
project has turned out to be immensely valuable in my day job, either by giving me a head-start on tracking down a
problem in a tool or library, or by recognising mistakes before theyâ€™re made.Understanding the constraints that define the shape of software is vital for working with it, and thereâ€™s no better way
to gain insight into those constraints than by running into them head-first. You might even come up with some novel
solutions!Here is a list of toy programs Iâ€™ve attempted over the past 15 years, rated by difficulty and time required. These
ratings are estimates and assume that youâ€™re already comfortable with at least one general-purpose programming language
and that, like me, you tend to only have an hour or two per day free to write code. Also included are some suggested
resources that I found useful.Regex engine (difficulty = 4/10, time = 5 days)A regex engine that can read a POSIX-style regex program and recognise strings that match it. Regex is simple yet
shockingly expressive, and writing a competent regex engine will teach you everything you need to know about using the
language too.x86 OS kernel (difficulty = 7/10, time = 2 months)A multiboot-compatible OS kernel with a simple CLI, keyboard/mouse driver, ANSI escape sequence support, memory manager,
scheduler, etc. Additional challenges include writing an in-memory filesystem, user mode and process isolation, loading
ELF executables, and supporting enough video hardware to render a GUI.GameBoy/NES emulator (difficulty = 6/10, time = 3 weeks)A crude emulator for the simplest GameBoy or NES games. The GB and the NES are classics, and both have relatively simple
instruction sets and peripheral hardware. Additional challenges include writing competent PPU (video) and PSG (audio)
implementations, along with dealing with some of the more exotic cartridge formats.GameBoy Advance game (difficulty = 3/10, time = 2 weeks)A sprite-based game (top-down or side-on platform). The GBA is a beautiful little console to write code for and thereâ€™s
an active and dedicated development community for the console. I truly believe that the GBA is one of the last game
consoles that can be fully and completely understood by a single developer, right down to instruction timings.Physics engine (difficulty = 5/10, time = 1 week)A 2D rigid body physics engine that implements Newtonian physics with support for rectangles, circles, etc. On the
simplest end, just spheres that push away from one-another is quite simple to implement. Things start to get complex
when you introduce more complex shapes, angular momentum, and the like. Additional challenges include making collision
resolution fast and scaleable, having complex interactions move toward a steady state over time, soft-body interactions,
etc.Dynamic interpreter (difficulty = 4/10, time = 1-2 weeks)A tree-walking interpreter for a JavaScript-like language with basic flow control. Thereâ€™s an unbounded list of extra
things to add to this one, but being able to write programs in my own language still gives me child-like elation. It
feels like a sort of techno-genesis: once youâ€™ve got your own language, you can start building the universe within it.Compiler for a C-like (difficulty = 8/10, time = 3 months)A compiler for a simply-typed C-like programming language with support for at least one target archtecture. Extra
challenges include implementing some of the most common optimisations (inlining, const folding, loop-invariant code
motion, etc.) and designing an intermediate representation (IR) thatâ€™s general enough to support multiple backends.Text editor (difficulty = 5/10, time = 2-4 weeks)This one has a lot of variability. At the blunt end, simply reading and writing a file can be done in a few lines of
Python. But building something thatâ€™s closer to a daily driver gets more complex. You could choose to implement the UI
using a toolkit like QT or GTK, but I personally favour an editor that works in the console. Properly handling unicode,
syntax highlighting, cursor movement, multi-buffer support, panes/windows, tabs, search/find functionality, LSP support,
etc. can all add between a week or a month to the project. But if you persist, you might join the elite company of those
developers who use an editor of their own creation.Async runtime (difficulty = 6/10, time = 1 week)Thereâ€™s a lot of language-specific variability as to what â€˜asyncâ€™ actually means. In Rust, at least, this means a
library that can ingest  tasks and poll them concurrently until completion. Adding support for I/O waking
makes for a fun challenge.Hash map (difficulty = 4/10, time = 3-5 days)Hash maps (or sets/dictionaries, as a higher-level language might call them) are a programmerâ€™s bread & butter. And yet,
surprisingly few of us understand how they really work under the bonnet. There are a plethora of techniques to throw
into the mix too: closed or open addressing, tombstones, the robin hood rule, etc. Youâ€™ll gain an appreciation for when
and why theyâ€™re fast, and also when you should just use a vector + linear search.Rasteriser / texture-mapper (difficulty = 6/10, time = 2 weeks)Most of us have played with simple 3D graphics at some point, but how many of us truly understand how the graphics
pipeline works and, more to the point, how to fix it when it doesnâ€™t work? Writing your own software rasteriser will
give you that knowledge, along with a new-found appreciation for the beauty of vector maths and half-spaces that have
applications across many other fields. Additional complexity involves properly implementing clipping, a Z-buffer, N-gon
rasterisation, perspective-correct texture-mapping, Phong or Gouraud shading, shadow-mapping, etc.SDF Rendering (difficulty = 5/10, time = 3 days)Signed Distance Fields are a beautifully simple way to render 3D spaces defined through mathematics, and are perfectly
suited to demoscene shaders. With relatively little work you can build yourself a cute little visualisation or some
moving shapes like the graphics demos of the 80s. Youâ€™ll also gain an appreciation for shader languages and vector
maths.Voxel engine (difficulty = 5/10, time = 2 weeks)I doubt there are many reading this that havenâ€™t played Minecraft. Itâ€™s surprisingly easy to build your own toy voxel
engine cut from a similar cloth, especially if youâ€™ve got some knowledge of 3D graphics or game development already. The
simplicity of a voxel engine, combined with the near-limitless creativity that can be expressed with them, never ceases
to fill me with joy. Additional complexity can be added by tackling textures, more complex procedural generation,
floodfill lighting, collisions, dynamic fluids, sending voxel data over the network, etc.Threaded Virtual Machine (difficulty = 6/10, time = 1 week)Writing interpreters is great fun. Whatâ€™s more fun? . If you keep pushing interpreters as far as
they can go without doing architecture-specific codegen (like AOT or JIT), youâ€™ll eventually wind up (re)discovering
 (not to be confused with multi-threading, which is a very different beast). Itâ€™s a beautiful way of
weaving programs together out highly-optimised miniature programs, and a decent implementation can even give an AOT
compiler a run for its money in the performance department.GUI Toolkit (difficulty = 6/10, time = 2-3 weeks)Most of us have probably cobbled together a GUI program using tkinter, GTK, QT, or WinForms. But why not try writing
your GUI toolkit? Additional complexity involves implementing a competent layout engine, good text shaping (inc.
unicode support), accessibility support, and more. Fair warning: do not encourage people to use your tool unless itâ€™s
 - the world has enough GUIs with little-to-no accessibility or localisation support.Orbital Mechanics Sim (difficulty = 6/10, time = 1 week)A simple simulation of Newtonian gravity can be cobbled together in a fairly short time. Infamously, gravitational
systems with more than two bodies cannot be solved analytically, so youâ€™ll have to get familiar with iterative
 methods. Additional complexity comes with implementing more precise and faster integration methods,
accounting for relativistic effects, and writing a visualiser. If youâ€™ve got the maths right, you can even try plugging
in real numbers from NASA to predict the next high tide or full moon.Bitwise Challenge (difficulty = 3/10, time = 2-3 days)Hereâ€™s one I came up with for myself, but I think it would make for a great game jam: write a game that only persists 64
bits of state between subsequent frames. Thatâ€™s 64 bits for everything: the entire frame-for-frame game state should be
reproducible using only 64 bits of data. It sounds simple, but it forces you to get incredibly creative with your game
state management. Details about the rules can be found on the GitHub page below.An ECS Framework (difficulty = 4/10, time = 1-2 weeks)For all those game devs out there: try building your own ECS
framework. Itâ€™s not as hard as you might think (you might have accidentally done it already!). Extra points if you can
build in safety and correctness features, as well as good integration with your programming language of choiceâ€™s type
system features.I built a custom ECS for my Super Mario 64 on the GBA project due to the
unique performance and memory constraints of the platform, and enjoyed it a lot.CHIP-8 Emulator (difficulty = 3/10, time = 3-6 days)The CHIP-8 is a beautifully simple virtual machine from the 70s. You can write
a fully compliant emulator in a day or two, and there are an enormous plethora of fan-made games that run on it.
Hereâ€™s a game I made for it.Chess engine (difficulty = 5/10, time = 2-5 days)Writing a chess engine is great fun. Youâ€™ll start off with every move it makes being illegal, but over time itâ€™ll get
smart and smarter. Experiencing a loss to your own chess engine really is a rite of passage, and it feels magical.POSIX shell (difficulty = 4/10, time = 3-5 days)We interact with shells every day, and building one will teach you can incredible amount about POSIX - how it works, and
how it doesnâ€™t. A simple one can be built in a day, but compliance with an existing shell language will take time and
teach you more than you ever wanted to know about its quirks.A note on learning and LLMsPerhaps youâ€™re a user of LLMs. I get it, theyâ€™re neat tools. Theyâ€™re useful for certain kinds of learning. But I might
suggest resisting the temptation to use them for projects like this. Knowledge is not supposed to be fed to you on a
plate. If you want that sort of learning, read a book - the joy in building toy projects like this comes from an
exploration of the unknown, without polluting oneâ€™s mind with an existing solution. If youâ€™ve been using LLMs for a
while, this cold-turkey approach might even be painful at first, but persist. There is no joy without pain.The runnerâ€™s high doesnâ€™t come to those that take the bus.]]></content:encoded></item><item><title>Coccinelle for Rust progress report</title><link>https://www.collabora.com/news-and-blog/blog/2025/06/25/coccinelle-for-rust-progress-report/</link><author>/u/mfilion</author><category>dev</category><category>reddit</category><pubDate>Wed, 25 Jun 2025 19:24:05 +0000</pubDate><source url="https://www.reddit.com/r/linux/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Linux</source><content:encoded><![CDATA[In collaboration with Inria (the French Institute for Research in Computer Science and Automation), Tathagata Roy shares the progress made over the past year on the CoccinelleForRust project, co-sponsored by Collabora.Coccinelle is a tool for automatic program matching and transformation that was originally developed for making large-scale changes to the Linux kernel source code (i.e., C code). Matches and transformations are driven by user-specific transformation rules in the form of abstracted patches, referred to as . As the Linux kernelâ€”and systems software more generallyâ€”is starting to adopt Rust, we are developing Coccinelle for Rust to make the power of Coccinelle available to Rust codebases.This diff illustrates a patch in which the  function was being called  confirming that the target itemâ€™s trait was implemented. A straightforward CfR-based fix is to find every expression of the form
expression.type_of(impl_id)

expression.type_of(impl_id).subst_identity()
There are roughly fifty occurrences of this pattern in the diff, so updating them all by hand would be quite tedious. The accompanying Semantic Patch to perform this transformation automatically is:@change_ty_of@
expression exp1, impl_id;
@@

-exp1.type_of(impl_id)
+exp1.type_of(impl_id).subst_identity()
While the above example could be achieved with a complicated and unreadable regex pattern, things can quickly become more complex.The following patch changes a function signature and all the related calls.@change_sig@
expression x;
identifier fname, sname;
@@

impl sname {
    ...
    pub(crate) fn fname(&self,
-       guard: &RevocableGuard<'_>
    ) -> Result { ... }
    ...
}

@modify_calls@
expression x, guard;
identifier change_sig.fname;
@@

x.fname(
    ...
-   guard
)
Rule  finds all the occurrences of functions which take a  of type  and removes that parameter. The rule  updates the calls to that method.This semantic patch can be used on a whole code-base where once a  variable is no longer needed, it can be removed. It can also serve as an integration test to check that no such code is present in new pull requests.Developments (2024â€“Present)Core pattern-matching engine using CTL.Shared with C version, adapted for Rustâ€™s expression-heavy syntax.Performance optimized with s and hash tables.SmPL includes Rust + custom syntax (, , , disjunctions).Custom parser for SmPL constructs; uses Rust Analyzer for Rust code.Define code transformations scoped to an environment.Support for rule inheritance.Rule dependencies not yet implemented.Connects code segments within the same control flow.Higher complexity due to Rustâ€™s flexible syntax. not yet supported.Alternative code match options.Can combine with ellipses for complex patterns.Developments in detail: 2024â€“PresentComputational Tree Logic (CTL) is the heart of Coccinelle, which takes semantic patches and generalizes them over Rust files. Prior to using this engine, CfR used an ad-hoc method for matching patterns of code. This engine is the same as the one used for Coccinelle for C, with a few minor changes. Most of the changes were idiomatic but to the same effect. More information on the engine and its language (CTL-VW) can be found in the POPL Paper. With a standard engine, each step of the matching process can be logged, allowing us to learn and reuse the same design patterns from Coccinelle for C, including critical test cases.The expression-dominated nature of Rust makes the matching and transformation process a bit different from that of C. For example, in the following semantic patch:@@
expression e
@@

-foo(e);
for C,  would be guaranteed to be present as an immediate child of a block, i.e.:{           // <- start of a block
    foo(e); // <- this statement
}
Blocks in C are present only in specific parts of the Abstract Syntax Tree, like in function definitions, loops, or conditional blocks. However, in Rust, blocks are expressions, which can appear anywhere an expression is allowed. For example:while { f(&mut a); a > 1 } {
    //
}
This makes searching much more computationally intensive. Thus, several optimizations were implemented in CfR to address this problem, including replacing lists in the CTL engine with s and hash tables.Semantic Patch Language (SmPL)While developing the parser for SmPL, we decided not to reinvent the wheel by writing a parser for the Rust language from scratch. SmPL contains custom syntax such as dots (), disjunctions, and modifiers ( and ). In the latest version, we parse only these constructs ourselves and hand off the rest to Rust Analyzer.A  refers to a set of changes given an environment. Multiple rules can inherit values from one another to transform code in different parts of a file.Used in SmPL as , ellipses connect two blocks of code:@@
expression q;
@@

drop_queue(q);
...
pop(q);
This is implemented in CTL using the  term.Disjunctions allow for conditional matching:f1(10);
(   // <--- disjunction start
foo(1);
|
bar(10);
)   // <--- disjunction end
f2();
Transforming macros posed a problem because of their non-standard nature. For example, should the following semantic patch match@@
expression e;
@@

foo!(
- e
+ 2
);
To avoid discrepancies, we support only macros which look like function calls. For example,  or .Pretty Printing has been improved. The transformed code is formatted using  and it is then compared with the formatting from the original code. This way only the transformed code is formatted without messing up the original file formatting.  Pretty printing is still a work-in-progress for rust macros as they are notoriously hard to deal with and  thus leaves them alone.Better tests have been added.A more robust UI has been implemented, with various debugging flags.Our current aim is to bring Coccinelle For Rust at par with Coccinelle For C in terms of basic functionalities. In the following months we are going on to work on:Rule Dependance - It lets a rule run only if a condition is satisfied by the rules before it.Scripting - Lets the user run arbitrary code for each match, allowing them to perform more things that are out of scope for now. This includes counting instances, matching with regex and performing other arbitrary operations.If you want to try out CoccinelleForRust it is available on Gitlab. Please feel free to reach out to us at the email addresses on our website CoccinelleForRust, we would be happy to answer your questions!]]></content:encoded></item><item><title>OpenAI is Ditching TypeScript to Rebuild Codex CLI with Rust</title><link>https://analyticsindiamag.com/global-tech/openai-is-ditching-typescript-to-rebuild-codex-cli-with-rust/</link><author>/u/GeneReddit123</author><category>dev</category><category>reddit</category><category>rust</category><pubDate>Wed, 25 Jun 2025 18:41:05 +0000</pubDate><source url="https://www.reddit.com/r/rust/top/?sort=top&amp;t=day&amp;limit=6">Reddit - Rust</source><content:encoded><![CDATA[When OpenAI launched Codex CLI, the aim was to make it easier for developers to interact with AI in the terminal using a familiar stackâ€”TypeScript and React-based Ink.Â While it tries to compete with Claude Code and similar tools, the team decided to revamp its foundation for better performance. â€œWeâ€™ve been working on a rewrite of Codex CLI into Rust,â€ Fouad Matin, a member of technical staff at OpenAI, said in a GitHub discussion thread.Â Although the TypeScript version was productive for fast prototyping, it started to show its limits as the Codex CLI matured with various use cases.Â Now, OpenAI plans to retire the TypeScript CLI entirely in favour of Rust. Matin mentioned that the TypeScript version will continue to receive bugfixes for now and that the focus is on bringing the native Rust build to feature parity and eventually making it the default.4 Benefits of Rust at Its CoreWhile Rust has its own set of problems and benefits, the switch isnâ€™t about language ideology. As Matin put it, â€œWe want to use the best tool for the job.â€ Codex CLI may have launched with â€œa neat terminal UIâ€ built on React.Â However, he said that, at its core, the CLI functions as a tool working in a loop that keeps talking to the AI model and working with the system, instead of simply displaying a nice terminal interface. For that kind of repeated interaction with local system resources and APIs, TypeScript began to fall short.â€œWe wanted to improve a few areas,â€ Matin explained.Â First, the installation experience required improvement, as the current version â€œrequires Node v22+, which can be frustrating or a blocker for some usersâ€. Second, improvements were to be made in native security bindings. â€œWe already ship a Rust for Linux sandboxing since the bindings were available.â€ And third, the focus was on runtime performance. â€œNo runtime garbage collection, resulting in lower memory consumption.â€Beyond performance, Rust offered architectural breathing room. Matin said OpenAI is developing a â€œwire protocolâ€ for Codex CLI, which will enable developers to extend the agent using various languages, such as TypeScript/JavaScript and Python. Rust is already supported for MCPs.In other words, Codex CLI isnâ€™t just a tool; it aims to evolve into a cross-language, plug-in-friendly runtime for model-based automation.Work in Progress, but â€˜Butter Smoothâ€™While the new Rust version is still under development, the response so far has been optimistic. One developer reported that â€œcodex native is butter smooth so farâ€, even though there are still some discrepancies between the TypeScript and native versions. This includes configuration file support and the ability to use the free tier mode or log in with an OpenAI account.OpenAI is systematically addressing those gaps. In a separate GitHub thread, Michael Bolin, a member of technical staff at OpenAI, categorised the remaining work as P0 (must-fix), P1 (feature parity), and P2 (quality-of-life).Â High-priority features for the native Rust version include â€˜Sign in with ChatGPTâ€™ and improved interruption handling. Other features, like session management and prompt suggestions, are set to follow after the feature parity is handled.â€œWe will ultimately be retiring the TypeScript version of the CLI in favour of the Rust one,â€ Bolin wrote in the GitHub thread. The roadmap reflects a methodical upgrade path rather than a rushed rewrite.Native is the New Normal?The move fits a larger industry narrative. On Hacker News, a user called it part of a â€œrecent resurgence of tools going nativeâ€.Â The user explained that the notion of JIT (just-in-time) interpreters becoming better and eliminating the need for native languages is increasingly being challenged.Meanwhile, another user noted that Rust and Go have made native development far more accessible. â€œThe package management is better, and statically linked native binaries eliminate so many deployment headaches,â€ the user wrote.With Rust, OpenAI isnâ€™t just changing the codebase; itâ€™s changing what kind of software Codex CLI can be. From terminal utility to programmable agent harness, the CLI is being rebuilt not just for speed, but also for flexibility, portability, and long-term maintainability.Â If the TypeScript version was deployed for a playground, the Rust rewrite is planned to be ready for the real world.]]></content:encoded></item><item><title>Better Auth, by a self-taught Ethiopian dev, raises $5M from Peak XV, YC</title><link>https://techcrunch.com/2025/06/25/this-self-taught-ethiopian-dev-built-an-authentication-tool-and-got-into-yc/</link><author>bundie</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 18:07:02 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[Itâ€™s rare to see a solo founder building a widely adopted developer infrastructure tool. Even more so if the founder happens to be from Africa. Bereket Engida, a self-taught programmer from Ethiopia, is quietly building what some developers say is the best authentication tool theyâ€™ve ever used.Engidaâ€™s startup, Better Auth, offers an open source framework that promises to simplify how developers manage user authentication, and itâ€™s caught the attention of some big name investors.Â It recently raised about $5 million in seed funding from Peak XV (formerly Sequoia India and Southeast Asia), Y Combinator, P1 Ventures, and Chapter One.Â But the most interesting part here isnâ€™t whoâ€™s on the startupâ€™s cap table: Engida says he built the entire product back home in Ethiopia before he set foot in the U.S.Engida told TechCrunch that he started programming at 18 after a friend declined to help him build an e-commerce search app, and he started working on the project himself. He went on to land some remote software jobs and eventually built a web analytics platform that lets developers monitor user behavior on their websites. But throughout his various jobs, Engida says he kept seeing an issue popping up everywhere: authentication. Every app needs to manage how users sign in and out and reset passwords, and sometimes administrators need to handle permissions and user roles. But he found existing tools were either too limited or too rigid â€” companies like Auth0, Firebase, and NextAuth offer managed services, but they store user data externally, limit customization, and are expensive at scale.â€œI remember needing an organization feature. Itâ€™s a very common use case for most SaaS applications, but it wasnâ€™t available from these providers,â€ Engida told TechCrunch. â€œSo I had to build it from scratch. It took me about two weeks, and I remember thinking, â€˜This is crazy; there has to be a better way to solve this.â€™â€He then scrapped that project and began working on a TypeScript-based authentication framework that would let developers access user data via open source libraries, support common permissions use cases â€” like teams and roles â€” out of the box, and scale with plug-ins.â€œThe idea was that you could add advanced features in just two or three lines of code,â€ Engida said.Over six months working mostly from his bedroom in Ethiopia, Engida built the first version of the library that would go on to become Better Auth. When he posted it to GitHub in September 2024, developers quickly saw the potential.Â Since then, Better Auth has clocked 150,000+ weekly downloads, 15,000+ GitHub stars, and a community of over 6,000 Discord members, the startup claims.Â Better Authâ€™s pitch is simple: Let developers implement everything from simple authentication flows to enterprise-grade systems directly on their databases and embed it all on the back end. Unlike hosted services, Better Auth is an open source library that developers can integrate directly into their codebase, keeping all user data on premise, in their database. For companies wary of handing over critical user information to third parties, this feature alone is a major point.The library has also found unexpected traction among early-stage AI startups, which need to build custom authentication flows that integrate with proprietary APIs, manage tokens securely, and be able to scale without racking up high costs.â€œWe first heard about the product from numerous startups weâ€™ve worked with,â€ said Arnav Sahu, partner at Peak XV and former principal at Y Combinator. â€œTheir auth product has seen phenomenal adoption among the next generation of AI startups.â€ Better Auth marks Peak XVâ€™s first direct investment in an African founder.Engida says Better Auth, currently free to use, will focus on improving its core features and launch a paid enterprise infrastructure that plugs into its open source base. This will give developers the flexibility to self-host or opt for Better Authâ€™s cloud add-ons as needed.Heâ€™s also thinking about how to scale without trading away the productâ€™s community-built feel. On the roadmap, therefore, is hiring a small team to help maintain the codebase, expand documentation, and support enterprise users. For now, though, Engida is still writing most of the code himself.Better Auth, which just graduated from YCâ€™s recent spring batch, is the third Ethiopian startup to pass through the accelerator, following drone-based digital health platform Avion, and food delivery platform BeU Delivery.Â â€œBuilding this feels important not just because people love the product, but because of what it represents,â€ said Engida. â€œThere arenâ€™t many Ethiopian founders building global products. For many, it feels almost impossible. So seeing that traction gives hope for other people to try to be more ambitious.â€]]></content:encoded></item><item><title>&apos;The Computer-Science Bubble Is Bursting&apos;</title><link>https://developers.slashdot.org/story/25/06/25/1730250/the-computer-science-bubble-is-bursting?utm_source=rss1.0mainlinkanon&amp;utm_medium=feed</link><author>msmash</author><category>dev</category><category>slashdot</category><pubDate>Wed, 25 Jun 2025 17:30:00 +0000</pubDate><source url="https://developers.slashdot.org/">Dev - Slashdot - Dev</source><content:encoded><![CDATA[theodp writes: The job of the future might already be past its prime," writes The Atlantic's Rose Horowitch in The Computer-Science Bubble Is Bursting. "For years, young people seeking a lucrative career were urged to go all in on computer science. From 2005 to 2023, the number of comp-sci majors in the United States quadrupled. All of which makes the latest batch of numbers so startling. This year, enrollment grew by only 0.2 percent nationally, and at many programs, it appears to already be in decline, according to interviews with professors and department chairs. At Stanford, widely considered one of the country's top programs, the number of comp-sci majors has stalled after years of blistering growth. Szymon Rusinkiewicz, the chair of Princeton's computer-science department, told me that, if current trends hold, the cohort of graduating comp-sci majors at Princeton is set to be 25 percent smaller in two years than it is today. The number of Duke students enrolled in introductory computer-science courses has dropped about 20 percent over the past year." 

"But if the decline is surprising, the reason for it is fairly straightforward: Young people are responding to a grim job outlook for entry-level coders. In recent years, the tech industry has been roiled by layoffs and hiring freezes. The leading culprit for the slowdown is technology itself. Artificial intelligence has proved to be even more valuable as a writer of computer code than as a writer of words. This means it is ideally suited to replacing the very type of person who built it. A recent Pew study found that Americans think software engineers will be most affected by generative AI. Many young people aren't waiting to find out whether that's true." 

Meanwhile, writing in the Communications of the ACM, Orit Hazzan and Avi Salmon ask: Should Universities Raise or Lower Admission Requirements for CS Programs in the Age of GenAI? "This debate raises a key dilemma: should universities raise admission standards for computer science programs to ensure that only highly skilled problem-solvers enter the field, lower them to fill the gaps left by those who now see computer science as obsolete due to GenAI, or restructure them to attract excellent candidates with diverse skill sets who may not have considered computer science prior to the rise of GenAI, but who now, with the intensive GenAI and vibe coding tools supporting programming tasks, may consider entering the field?]]></content:encoded></item><item><title>Build and Host AI-Powered Apps with Claude â€“ No Deployment Needed</title><link>https://www.anthropic.com/news/claude-powered-artifacts</link><author>davidbarker</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 17:14:35 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[Today, weâ€™re introducing the ability to build, host, and share interactive AI-powered apps directly in the Claude app. Now developers can iterate faster on their AI apps without worrying about the complexity and cost of scaling for a growing audience.Build and host Claude-powered appsHereâ€™s what we built: Claude can now create artifacts that interact with Claude through an APIâ€” turning these artifacts into AI-powered apps, where the economics actually work for sharing.When someone uses your Claude-powered app:They authenticate with their existing Claude accountTheir API usage counts against  subscription, not yoursYou pay nothing for their usageNo one needs to manage API keysClaude writes real code that orchestrates complex AI functionality. You can see it, modify it, and share it freely.Early users have already used interactive artifacts to build: with NPCs that remember conversations and adapt to player choices that adjust to individual skill levels and provide personalized tutoring where users upload CSVs and ask follow-up questions in natural language that help with everything from scripts to technical documentation that orchestrate multiple Claude calls for complex tasksStart building in the Claude app by enabling this new interactive capability. Simply describe what you want to create, and Claude will write the code for you.As you work together, Claude can debug and improve its own code based on your feedback. Once your app is ready, you can share it instantly through a linkâ€”no deployment process needed. Claude takes care of the technical details like prompt engineering, error handling, and orchestration logic, allowing you to focus entirely on bringing your idea to life.Use a Claude API within your artifactsProcess files and create rich UIs with ReactSee, fork, and customize any artifactNo external API calls (yet)Limited to a text-based completion APIThis capability is available in beta to Free, Pro, and Max plan users.]]></content:encoded></item><item><title>Americaâ€™s incarceration rate is in decline</title><link>https://www.theatlantic.com/ideas/archive/2025/06/prisoner-populations-are-plummeting/683310/</link><author>paulpauper</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 17:14:29 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[Updated at 12:35 p.m. ET on June 26, 2025For more than 40 years, the United Statesâ€”a nation that putatively cherishes freedomâ€”has had one of the largest prison systems in the world. Mass incarceration has been so persistent and pervasive that reform groups dedicated to reducing the prison population by half have often been derided as made up of fantasists. But the next decade could see this goal met and exceeded: After peaking at just more than 1.6 million Americans in 2009, the prison population was just more than 1.2 million at the end of 2023 (the most recent year for which data are available), and is on track to fall to about 600,000â€”a total decline of roughly 60 percent.Discerning the coming prison-population cliff requires understanding the relationship between crime and incarceration over generations. A city jail presents a snapshot of what happened last night (for example, the crowdâ€™s football-victory celebration turned ugly). But a prison is a portrait of what happened five, 10, and 20 years ago. Middle-aged people who have been law-abiding their whole life until â€œsomething snappedâ€ and they committed a terrible crime are a staple of crime novels and movies, but in real life, virtually everyone who ends up in prison starts their criminal career in their teens or young adulthood. As of 2016â€”the most recent year for which data are availableâ€”the average man in state prison had been arrested nine times, was currently incarcerated for his sixth time, and was serving a 16-year sentence.Because of that fundamental dynamic, the explanation for why roughly 1.6 million peopleâ€”more than 500 for every 100,000 Americansâ€”were in a state or federal prison in 2009 has very little to do with what was happening on the streets or with law-enforcement policies that year. Rather, the causes lay in the final decades of the 20th century.From the end of World War II until the mid-1970s, the proportion of Americans in prison each year never exceeded 120 per 100,000. But starting in the late 1960s, a multidecade crime wave swelled in America, and an unprecedented number of adolescents and young adults were criminally active. In response, the anti-crime policies of most local, state, and federal governments became more and more draconian. The combined result was that the prison population exploded. By 1985, the imprisonment rate had doubled from its historical norm, such that more than 200 in 100,000 Americans were in a state or federal prison. The number of people in prison increased an average of 8 percent a year for the next decade, breaching the 1 million mark in 1994 and continuing to grow until 2009. This had ramifications that were felt for years: Because most people who are released from prison return, the system has been stocked and restocked with the legacy of that American crime-and-punishment wave for a quarter century. Thatâ€™s why the 2009 peak of U.S. imprisonment came 18 years after the 1991 peak in the violent-crime rate. The prison system is like a badly overloaded tractor trailerâ€”it takes a long time to stop even after the brakes are hit.That tractor trailer is finally slowing down, decades after the â€œgreat crime declineâ€ began in the 1990s. Until 2009, the lengthier sentences handed down during the preceding crime wave and the tendency of released prisoners to be re-incarcerated kept imprisonment rising even as crime declined. But the falling crime that the U.S. experienced in the 1990s and 2000s is now finally translating into a shrinking prison population.This chart, using data from the U.S. Department of Justice, shows the collapse of criminal arrests of minors in the 21st century. Rapidly declining numbers of youth are committing crimes, getting arrested, and being incarcerated. This matters because young offenders are the raw material that feeds the prison system: As one generation ages out, another takes its place on the same horrid journey. The U.S. had an extremely high-crime generation followed by a lower-crime generation, meaning that the older population is not being replaced at an equal rate. The impact of this shift on the prison population began more than a decade ago but has been little noticed because it takes so long for the huge prison population of longer provenance to clear.But such a transformation is now well under way. One statistic vividly illustrates the change: In 2007, the imprisonment rate for 18- and 19-year-old men was more than five times that of men over the age of 64. But today, men in those normally crime-prone late-adolescent years are imprisoned at half the rate that senior citizens are today.As the snake digests the pig year after year, the American prison system is simply not going to have enough inmates to justify its continued size or staggering costs. Some states that are contemplating expanding their prison capacity will be wasting their moneyâ€”their facilities will be overbuilt and underused. By 2035, the overall imprisonment rate could be as low as 200 per 100,000 people. States should instead be tearing down their most deteriorated and inhumane correctional facilities, confident that they will not need the space.This optimistic analysis could have been written in 2019, when the imprisonment rate had been falling for more than a decade and hit a level not seen since 1995. I thought about writing this article then, but a world turned upside down shook my confidence.COVID initially looked like a boon for decarceration because states reduced prison admissions and accelerated releases in 2020 to reduce transmission, cutting the prison population by 16 percent. But whether it was due to this mass release, COVID, de-policing, other factors, or some combination thereof, crime exploded in 2020 after a long quiescent period, most shockingly with an unprecedented 30 percent increase in homicides. Crime spikes increase incarceration directly because more people are committing crimes and also because they lead the public to demand more aggressive policies, which often translate into longer and more frequent prison sentences. If the turmoil of the early 2020s had led to an extended period of high crime and high punishment similar to what the U.S. experienced in the late 20th century, the COVID-era contraction of the prison population could have been immediately nullified and then some when, in the ensuing years, the prison pipeline was eventually replenished.But thankfully, the spike was just a spike, not a new equilibrium. Crime stopped rising sometime in 2022, and fell in 2023 and 2024. The prison population inched up 2 percent in 2022 and again in 2023, and it is possible that a similar rise took place in 2024, but even collectively, this is a fraction of the sudden population decline during the early pandemic. The COVID era ended with prison populations lower rather than higher: A recent Vera Institute report found that, on balance, from 2019 to the spring of 2024, the number of federal prisoners declined by 11 percent, and the number of state prisoners declined by 13 percent.Accelerating the de-prisoning of America is worthwhile and possible. The benefits of a smaller prison population are not limited to those who would otherwise be locked up and the people who love them. Prisons crowd out other policy priorities that many voters would like the government to spend more money on. In all 50 states, the cost to imprison someone for a year significantly exceeds the cost of a year of Kâ€“12 education. But even greater than the financial savings would be the prosperity in human terms: Less crime and less incarceration are profound blessings for a society.The simplest available policy to accelerate the decarceration trend is to stop building prisons except in cases where a smaller, modern facility is replacing a larger, decaying institution. Though it will be nonintuitive to many reformers, particularly on the left, opposition to any such new facilities being private should be dropped. The principal political barrier to closing half-full prisons is the power of public-sector unions. In contrast, a private prison can be sent to its reward if its contract is canceled. Individual communities in areas of low employment will also fight to keep their prisons. Prison-closing commissions, analogous to military-base-closing commissions, may be necessary and should coordinate with legislators to provide worker retraining and financial assistance to compensate for the loss of high-wage jobs in communities whose economy revolves around corrections.Finally, America should not let its prison system become the most expensive and inhumane of nursing homes. The rate of recidivism among senior citizens is near zero, and compassionate release of sick and aging inmates should be the default rather than the exception, a reversal of current practice.In any given future year, small rises in imprisonment are possible, but the macro trend is ineluctable: Society is going to experience the benefits of past decades of lower crime throughout its prison system. The imprisonment rate will be lower in five years and lower still in 10. Prisons will still exist then and still be needed, but the rate at which Americans are confined in them could be lower than anything in the preceding half century. This is the fruit of a lower-crime societyâ€”good in and of itself, surely, particularly for the low-income and majority-minority communities where most crime occurs. It will also, of course, be a blessing for those who avoid prison, and for the taxpayers who no longer have to pay for it. The decline in the prison population will be something everyone in our polarized society will have reason to celebrate.A chart in this article showing the number of juvenile arrests from 1980 to 2020 has been updated to correct labeling on the Y axis.]]></content:encoded></item><item><title>What Problems to Solve (1966)</title><link>http://genius.cat-v.org/richard-feynman/writtings/letters/problems</link><author>jxmorris12</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 17:08:44 +0000</pubDate><source url="https://news.ycombinator.com/">HN Front</source><content:encoded><![CDATA[A former student, who was also once a student of Tomonagaâ€™s, wrote to extend
his congratulations. Feynman responded, asking Mr. Mano what he was now doing.
The response: â€œstudying the Coherence theory with some applications to the
propagation of electromagnetic waves through turbulent atmosphereâ€¦ a humble and
down-to-earth type of problem.â€Dear Koichi,

I was very happy to hear from you, and that you have such a position in the
Research Laboratories. Unfortunately your letter made me unhappy for you seem
to be truly sad. It seems that the influence of your teacher has been to give
you a false idea of what are worthwhile problems. The worthwhile problems are
the ones you can really solve or help solve, the ones you can really contribute
something to. A problem is grand in science if it lies before us unsolved and
we see some way for us to make some headway into it. I would advise you to take
even simpler, or as you say, humbler, problems until you find some you can
really solve easily, no matter how trivial. You will get the pleasure of
success, and of helping your fellow man, even if it is only to answer a
question in the mind of a colleague less able than you. You must not take away
from yourself these pleasures because you have some erroneous idea of what is
worthwhile.

You met me at the peak of my career when I seemed to you to be concerned with
problems close to the gods. But at the same time I had another Ph.D. Student
(Albert Hibbs) was on how it is that the winds build up waves blowing over
water in the sea. I accepted him as a student because he came to me with the
problem he wanted to solve. With you I made a mistake, I gave you the problem
instead of letting you find your own; and left you with a wrong idea of what is
interesting or pleasant or important to work on (namely those problems you see
you may do something about). I am sorry, excuse me. I hope by this letter to
correct it a little.

I have worked on innumerable problems that you would call humble, but which I
enjoyed and felt very good about because I sometimes could partially succeed.
For example, experiments on the coefficient of friction on highly polished
surfaces, to try to learn something about how friction worked (failure). Or,
how elastic properties of crystals depends on the forces between the atoms in
them, or how to make electroplated metal stick to plastic objects (like radio
knobs). Or, how neutrons diffuse out of Uranium. Or, the reflection of
electromagnetic waves from films coating glass. The development of shock waves
in explosions. The design of a neutron counter. Why some elements capture
electrons from the L-orbits, but not the K-orbits. General theory of how to
fold paper to make a certain type of childâ€™s toy (called flexagons). The energy
levels in the light nuclei. The theory of turbulence (I have spent several
years on it without success). Plus all the â€œgranderâ€ problems of quantum
theory.

No problem is too small or too trivial if we can really do something about it.

You say you are a nameless man. You are not to your wife and to your child. You
will not long remain so to your immediate colleagues if you can answer their
simple questions when they come into your office. You are not nameless to me.
Do not remain nameless to yourself â€“ it is too sad a way to be. now your place
in the world and evaluate yourself fairly, not in terms of your naÃ¯ve ideals of
your own youth, nor in terms of what you erroneously imagine your teacherâ€™s
ideals are.

Best of luck and happiness.  Sincerely, Richard P. Feynman.
]]></content:encoded></item><item><title>Deaf and Hard of Hearing WG Meeting - 2025-06-24</title><link>https://www.youtube.com/watch?v=l5D5oWhczYU</link><author>CNCF [Cloud Native Computing Foundation]</author><category>dev</category><category>k8s</category><enclosure url="https://www.youtube.com/v/l5D5oWhczYU?version=3" length="" type=""/><pubDate>Wed, 25 Jun 2025 14:13:59 +0000</pubDate><source url="https://www.youtube.com/channel/UCvqbFHwN-nwalWPjPUKpvTA">Dev - CNCF</source><content:encoded><![CDATA[Don't miss out! Join us at our next Flagship Conference: KubeCon + CloudNativeCon India in Hyderabad (August 6-7), and KubeCon + CloudNativeCon North America in Atlanta (November 10-13). Connect with our current graduated, incubating, and sandbox projects as the community gathers to further the education and advancement of cloud native computing. Learn more at https://kubecon.io]]></content:encoded></item><item><title>OpenAI charges by the minute, so speed up your audio</title><link>https://george.mand.is/2025/06/openai-charges-by-the-minute-so-make-the-minutes-shorter/</link><author>georgemandis</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 13:17:25 +0000</pubDate><source url="https://news.ycombinator.com/best">HN</source><content:encoded><![CDATA[Want to make OpenAI transcriptions faster and cheaper? Just speed up your audio.I mean that very literally. Run your audio through ffmpeg at 2x or 3x before transcribing it. Youâ€™ll spend fewer tokens and less time waiting with almost no drop in transcription quality.Hereâ€™s a script combining of all my favorite little toys and tricks to get the job. Youâ€™ll need yt-dlp, ffmpeg and llm installed.# Extract the audio from the video
yt-dlp -f 'bestaudio[ext=m4a]' --extract-audio --audio-format m4a -o 'video-audio.m4a' "https://www.youtube.com/watch?v=LCEmiRjPEtQ" -k;

# Create a low-bitrate MP3 version at 3x speed
ffmpeg -i "video-audio.m4a" -filter:a "atempo=3.0" -ac 1 -b:a 64k video-audio-3x.mp3;

# Send it along to OpenAI for a transcription
curl --request POST \
  --url https://api.openai.com/v1/audio/transcriptions \
  --header "Authorization: Bearer $OPENAI_API_KEY" \
  --header 'Content-Type: multipart/form-data' \
  --form [emailÂ protected] \
  --form model=gpt-4o-transcribe > video-transcript.txt;

# Get a nice little summary

cat video-transcript.txt | llm --system "Summarize the main points of this talk."
I just saved you time by jumping straight to the point, but read-on if you want more of a story about how I accidentally discovered this while trying to summarize a 40-minute talk from Andrej Karpathy.Also read-on if youâ€™re wondering why I didnâ€™t just use the built-in auto-transcription that YouTube provides, though the short answer there is easy: Iâ€™m sort of a doofus and thoughtâ€”incorrectlyâ€”it wasnâ€™t available. So I did things the hard way.I Just Wanted the TL;DW(atch)A former colleague of mine sent me this talk from Andrej Karpathy about how AI is changing software. I wasnâ€™t familiar with Andrej, but saw heâ€™d worked at Tesla. That coupled with the talk being part of a Y Combinator series and 40 minutes made me think â€œUgh. Do Iâ€¦ really want to watch this? Another 'AI is changing everything' talk from the usual suspects, to the usual crowds?â€If ever there were a use-case for dumping something into an LLM to get the gist of it and walk away, this felt like it. I respected the person who sent it to me though and wanted to do the noble thing: use AI to summarize the thing for me, blindly trust it and engage with the person pretending I had watched it.My first instinct was to pipe the transcript into an LLM and get the gist of it. This script is the one I would previously reach for to pull the auto-generated transcripts from YouTube:yt-dlp --all-subs --skip-download \
  --sub-format ttml/vtt/best \
  [url]
For some reason though, no subtitles were downloaded. I kept running into an error!Later, after some head-scratching and rereading the documentation, I realized my version (2025.04.03) was outdated.: Updating to the latest version (2025.06.09) fixed it, but for some reason I did not try this  going down a totally different rabbit hole. I guess I got this little write-up and exploration out of it though.If you care more about summarizing transcripts and less about the vagaries of audio-transcriptions and tokens, this is the correct answer and your off-ramp.My Transcription WorkflowI already had an old, home-brewed script that would extract the audio from any video URL, pipe it through whisper locally and dump the transcription in a text file.That worked, but I was on dwindling battery power in a coffee shop. Not ideal for longer, local inference, mighty as my M3 MacBook Air still feels to me. I figured I would try offloading it to OpenAIâ€™s API instead. Surely that would be faster?Testing OpenAIâ€™s Transcription ToolsOkay, using the  model itâ€™s  pretty slow, but it gets the job done. Had I opted for the model I knew and moved on, the story might end here.However, out of curiosity, I went straight for the newer  model first. Itâ€™s built to handle multimodal inputs and promises faster responses.I quickly hit another roadblock: thereâ€™s a 25-minute audio limit and my audio was nearly 40 minutes long.Let's Try Something ObviousAt first I thought about trimming the audio to fit somehow, but there wasnâ€™t an obvious 14 minutes to cut. Trimming the beginning and end would give me a minute or so at most.An interesting, weird idea I thought about for a second but never tried was cutting a chunk or two out of the middle. Maybe I would somehow still have enough info for a relevant summary?Then it crossed my mindâ€”what if I just sped up the audio before sending it over? People listen to podcasts at accelerated 1-2x speeds all the time.ffmpeg -i video-audio.m4a -filter:a "atempo=2.0" -ac 1 -b:a 64k video-audio-2x.mp3
Ta-da! Now I had something closer to a 20 minute file to send to OpenAI.I uploaded it andâ€¦ it worked like a charm! Behold the summary bestowed upon me that gave me enough confidence to reply to my colleague as though I had watched it.But there was something... interesting here. Did I just stumble across a sort of obvious, straightforward hack? Is everyone in the audio-transcription business already doing this and am I just haphazardly bumbling into their secrets?Why This Works: Our Brains Forgive, and So Does AIThereâ€™s an interesting parallel here in my mind with optimizing images. Traditionally you have lossy and lossless file formats. A lossy file-format kind of gives away the game in its descriptionâ€”the further you crunch and compact the bytes the more fidelity youâ€™re going to lose. It works because the human brain just isnâ€™t likely to pick-up on the artifacts and imperfectionBut even with a â€œlosslessâ€ file format there are tricks you can lean into that rely on the limits of human perception. One of the primary ways you can do that with a PNG or GIF is reducing the number of unique colors in the palette. Youâ€™d be surprised by how often a palette of 64 colors or fewer might actually be enough and perceived as significantly more.Thereâ€™s also a parallel in my head between this and the brainâ€™s ability to still comprehend text with spelling mistakes, dropped words and other errors, i.e. transposed letter effects. Our brains have a knack for filling in the gaps, and when you go looking through the world with magnifying glass you'll start to notice lots of them.Speeding up the audio starts to drop the more subtle sounds and occasionally shorter words from the audio, but it doesnâ€™t seem to hurt my ability to  what Iâ€™m hearingâ€”even if I do have to focus. These audio transcription models seem to be pretty good at this as well.Waitâ€”how far can I push this? Does It Actually Save Money?Turns out yes. OpenAI charges for transcription based on audio tokens, which scale with the duration of the input. Faster audio = fewer seconds = fewer tokens.Here are some rounded numbers based on the 40-minute audio file breaking down the audio input and text output token costs:Thatâ€™s a solid 33% price reduction on input tokens at 3x! However the bulk of your costs for these transcription models are still going to be the output tokens. Those are priced at $10 per 1M tokens whereas audio input tokens are priced at $6 per 1M token as of the time of this writing.Also interesting to noteâ€”my output tokens for the 2x and 3x versions were exactly the same: 2,048. This kind of makes sense, I think? To the extent the output tokens are a reflection of that model's ability to understand and summarize the input, my takeaway is a â€œsummarizedâ€ (i.e. reduced-token) version of the same audio yields the same amount of comprehensibility.This is also probably a reflection of the 4,096 token ceiling on transcriptions generally when using the  model. I suspect half the context window is reserved for the output tokens and this is basically reflecting our request using it up in its entirety. I suspect we might get diminishing results with longer transcriptions.So the back-of-the-envelope calculator for a single transcription looks something like this:6 * (audio_input_tokens / 1_000_000) + 10 * (text_output_tokens / 1_000_000);
That does  quite seem to jibe with the estimated cost of $0.006 per minute stated on the pricing page, at least for the 2x speed. That version (19-20 minutes) seemed to cost about $0.09 whereas the 3x version (13 minutes) cost about $0.07 (pretty accurate actually), if Iâ€™m adding up the tokens correctly.# Pricing for 2x speed
6 * (11_856 / 1_000_000) + 10 * (2_048 / 1_000_000) = 0.09

# Pricing for 3x speed
6 * (7_904 / 1_000_000) + 10 * (2_048 / 1_000_000) = 0.07
It would seem that estimate isnâ€™t just based on the length of the audio but also some assumptions around how many tokens per minute are going to be generated from a normal speaking cadence.Comparing these costs to  is easy because the pricing table more confidently advertises the costâ€”not â€œestimatedâ€ costâ€”as a flat $0.006 per minute. Iâ€™m assuming thatâ€™s minute of audio processed, not minute of inference.The  model actually compares pretty favorably.In short, yes! Itâ€™s not particularly rigorous, but it seems like we reduced the cost of transcribing our 40-minute audio file by 23% from $0.09 to $0.07 simply by speeding up the audio.If we could compare to a 1x version of the audio file trimmed to the 25-minute limit, I bet we could paint an even more impressive picture of cost reduction. We kind of can with the  chart. You could make the case this technique reduced costs by 67%!I donâ€™t knowâ€”I didnâ€™t watch it, lol. That was the whole point. And if that answer makes you uncomfortable, buckle-up for this future we're hurtling toward. Boy, howdy.More helpfully, I didnâ€™t compare word-for-word, but spot checks on the 2x and 3x versions looked solid. 4x speed was too fastâ€”the transcription started getting hilariously weird. So, 2x and 3x seem to be the sweet spot between efficiency and fidelity, though it will obviously depend on how fast the people are speaking in the first place.That sure didn't stop my call to summarize from trying though.Hey, not the worst talk I've been to!Always, in short, to save time and money, consider doubling or tripling the speed of the audio you want to transcribe. The trade-off is, as always, fidelity, but itâ€™s not an insignificant savings.Simple, fast, and surprisingly effective.OpenAI charges for transcriptions based on audio duration () or tokens ().You can  with  before uploading to save time and money.This reduces audio tokens (or duration), lowering your bill. works well.? Probably too muchâ€”but fun to try.If you find problems with my math, have questions, found a more rigorous study qualitatively comparing different output speeds please get in touch! Or if you thought this was so cool you want to hire me for something fun...--]]></content:encoded></item><item><title>Gemini CLI</title><link>https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/</link><author>sync</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 13:10:46 +0000</pubDate><source url="https://news.ycombinator.com/best">HN</source><content:encoded><![CDATA[
      [{"model": "blogsurvey.survey", "pk": 9, "fields": {"name": "AA - Google AI product use - I/O", "survey_id": "aa-google-ai-product-use-io_250519", "scroll_depth_trigger": 50, "previous_survey": null, "display_rate": 75, "thank_message": "Thank You!", "thank_emoji": "âœ…", "questions": "[{\"id\": \"e83606c3-7746-41ea-b405-439129885ead\", \"type\": \"simple_question\", \"value\": {\"question\": \"How often do you use Google AI tools like Gemini and NotebookLM?\", \"responses\": [{\"id\": \"32ecfe11-9171-405a-a9d3-785cca201a75\", \"type\": \"item\", \"value\": \"Daily\"}, {\"id\": \"29b253e9-e318-4677-a2b3-03364e48a6e7\", \"type\": \"item\", \"value\": \"Weekly\"}, {\"id\": \"5c5bb2ba-19b7-41dd-9000-2e3741878d19\", \"type\": \"item\", \"value\": \"Monthly\"}, {\"id\": \"697372e1-80b1-4901-81eb-48bf090a6a05\", \"type\": \"item\", \"value\": \"Hardly Ever\"}, {\"id\": \"b8e1604d-1146-4f2c-9184-6ed0f06fd863\", \"type\": \"item\", \"value\": \"Unsure\"}]}}]", "target_article_pages": true}}, {"model": "blogsurvey.survey", "pk": 9, "fields": {"name": "AA - Google AI product use - I/O", "survey_id": "aa-google-ai-product-use-io_250519", "scroll_depth_trigger": 50, "previous_survey": null, "display_rate": 75, "thank_message": "Thank You!", "thank_emoji": "âœ…", "questions": "[{\"id\": \"e83606c3-7746-41ea-b405-439129885ead\", \"type\": \"simple_question\", \"value\": {\"question\": \"How often do you use Google AI tools like Gemini and NotebookLM?\", \"responses\": [{\"id\": \"32ecfe11-9171-405a-a9d3-785cca201a75\", \"type\": \"item\", \"value\": \"Daily\"}, {\"id\": \"29b253e9-e318-4677-a2b3-03364e48a6e7\", \"type\": \"item\", \"value\": \"Weekly\"}, {\"id\": \"5c5bb2ba-19b7-41dd-9000-2e3741878d19\", \"type\": \"item\", \"value\": \"Monthly\"}, {\"id\": \"697372e1-80b1-4901-81eb-48bf090a6a05\", \"type\": \"item\", \"value\": \"Hardly Ever\"}, {\"id\": \"b8e1604d-1146-4f2c-9184-6ed0f06fd863\", \"type\": \"item\", \"value\": \"Unsure\"}]}}]", "target_article_pages": true}}, {"model": "blogsurvey.survey", "pk": 9, "fields": {"name": "AA - Google AI product use - I/O", "survey_id": "aa-google-ai-product-use-io_250519", "scroll_depth_trigger": 50, "previous_survey": null, "display_rate": 75, "thank_message": "Thank You!", "thank_emoji": "âœ…", "questions": "[{\"id\": \"e83606c3-7746-41ea-b405-439129885ead\", \"type\": \"simple_question\", \"value\": {\"question\": \"How often do you use Google AI tools like Gemini and NotebookLM?\", \"responses\": [{\"id\": \"32ecfe11-9171-405a-a9d3-785cca201a75\", \"type\": \"item\", \"value\": \"Daily\"}, {\"id\": \"29b253e9-e318-4677-a2b3-03364e48a6e7\", \"type\": \"item\", \"value\": \"Weekly\"}, {\"id\": \"5c5bb2ba-19b7-41dd-9000-2e3741878d19\", \"type\": \"item\", \"value\": \"Monthly\"}, {\"id\": \"697372e1-80b1-4901-81eb-48bf090a6a05\", \"type\": \"item\", \"value\": \"Hardly Ever\"}, {\"id\": \"b8e1604d-1146-4f2c-9184-6ed0f06fd863\", \"type\": \"item\", \"value\": \"Unsure\"}]}}]", "target_article_pages": true}}, {"model": "blogsurvey.survey", "pk": 9, "fields": {"name": "AA - Google AI product use - I/O", "survey_id": "aa-google-ai-product-use-io_250519", "scroll_depth_trigger": 50, "previous_survey": null, "display_rate": 75, "thank_message": "Thank You!", "thank_emoji": "âœ…", "questions": "[{\"id\": \"e83606c3-7746-41ea-b405-439129885ead\", \"type\": \"simple_question\", \"value\": {\"question\": \"How often do you use Google AI tools like Gemini and NotebookLM?\", \"responses\": [{\"id\": \"32ecfe11-9171-405a-a9d3-785cca201a75\", \"type\": \"item\", \"value\": \"Daily\"}, {\"id\": \"29b253e9-e318-4677-a2b3-03364e48a6e7\", \"type\": \"item\", \"value\": \"Weekly\"}, {\"id\": \"5c5bb2ba-19b7-41dd-9000-2e3741878d19\", \"type\": \"item\", \"value\": \"Monthly\"}, {\"id\": \"697372e1-80b1-4901-81eb-48bf090a6a05\", \"type\": \"item\", \"value\": \"Hardly Ever\"}, {\"id\": \"b8e1604d-1146-4f2c-9184-6ed0f06fd863\", \"type\": \"item\", \"value\": \"Unsure\"}]}}]", "target_article_pages": true}}, {"model": "blogsurvey.survey", "pk": 9, "fields": {"name": "AA - Google AI product use - I/O", "survey_id": "aa-google-ai-product-use-io_250519", "scroll_depth_trigger": 50, "previous_survey": null, "display_rate": 75, "thank_message": "Thank You!", "thank_emoji": "âœ…", "questions": "[{\"id\": \"e83606c3-7746-41ea-b405-439129885ead\", \"type\": \"simple_question\", \"value\": {\"question\": \"How often do you use Google AI tools like Gemini and NotebookLM?\", \"responses\": [{\"id\": \"32ecfe11-9171-405a-a9d3-785cca201a75\", \"type\": \"item\", \"value\": \"Daily\"}, {\"id\": \"29b253e9-e318-4677-a2b3-03364e48a6e7\", \"type\": \"item\", \"value\": \"Weekly\"}, {\"id\": \"5c5bb2ba-19b7-41dd-9000-2e3741878d19\", \"type\": \"item\", \"value\": \"Monthly\"}, {\"id\": \"697372e1-80b1-4901-81eb-48bf090a6a05\", \"type\": \"item\", \"value\": \"Hardly Ever\"}, {\"id\": \"b8e1604d-1146-4f2c-9184-6ed0f06fd863\", \"type\": \"item\", \"value\": \"Unsure\"}]}}]", "target_article_pages": true}}, {"model": "blogsurvey.survey", "pk": 7, "fields": {"name": "Article Improvements - March 2025", "survey_id": "article-improvements-march-2025_250321", "scroll_depth_trigger": 75, "previous_survey": null, "display_rate": 75, "thank_message": "Thank you!", "thank_emoji": "âœ…", "questions": "[{\"id\": \"5a12fd89-d978-4a1b-80e5-2442a91422be\", \"type\": \"simple_question\", \"value\": {\"question\": \"How could we improve this article?\", \"responses\": [{\"id\": \"30122b0d-1169-4376-af7c-20c9de52c91c\", \"type\": \"item\", \"value\": \"Make it more concise\"}, {\"id\": \"18f3016a-7235-468b-b246-ffe974911ae9\", \"type\": \"item\", \"value\": \"Add more detail\"}, {\"id\": \"5d19c11d-6a61-49d3-9f1d-dad5d661ba4f\", \"type\": \"item\", \"value\": \"Make it easier to understand\"}, {\"id\": \"97064d1f-d9af-4a83-a44f-a84f8ed899d6\", \"type\": \"item\", \"value\": \"Include more images or videos\"}, {\"id\": \"a9ec2a70-c7c5-4f00-a179-31a7b5641879\", \"type\": \"item\", \"value\": \"It's fine the way it is\"}]}}]", "target_article_pages": true}}]
    ]]></content:encoded></item><item><title>Growing Expert Generalists</title><link>https://martinfowler.com/articles/expert-generalist.html#GrowingExpertGeneralists</link><author>Martin Fowler</author><category>dev</category><pubDate>Wed, 25 Jun 2025 12:48:00 +0000</pubDate><source url="https://martinfowler.com/feed.atom">Dev - Martin Fowler</source><content:encoded><![CDATA[To grow Expert Generalists we need to focus attention on fundamentals
      rather tools. As an example, Unmesh, Gitanjali, and I describe a workshop we've used to
      break silos of application development, data engineering, and devops]]></content:encoded></item><item><title>An Intro to ty â€“ The Extremely Fast Python type checker</title><link>https://www.blog.pythonlibrary.org/2025/06/25/an-intro-to-ty-the-extremely-fast-python-type-checker/</link><author>Mike</author><category>dev</category><category>python</category><pubDate>Wed, 25 Jun 2025 12:45:46 +0000</pubDate><source url="https://www.blog.pythonlibrary.org/">Dev - Python Blog</source><content:encoded><![CDATA[Ty is a brand new, extremely fast Python type checker written in Rust from the fine folks at Astral, the makers of Ruff. Ty is in preview and is not ready for production use, but you can still try it out on your code base to see how it compares to Mypy or other popular Python type checkers.If you prefer to install ty, you can use pip:Using the ty Type CheckerWant to give ty a try? You can run it in much the same way as you would Ruff. Open up your terminal and navigate to your projectâ€™s top-level directory. Then run the following command:If ty finds anything, you will quickly see the output in your terminal.Astral has also provided a way to exclude files from type checking. By default, ty ignores files listed in anÂ Â orÂ Â file.Ruff is a great tool and has been adopted by many teams since its release. Ty will likely follow a similar trajectory if it as fast and useful as Ruff has been. Only time will tell. However, these new developments in Python tooling are exciting and will be fun to try. If you have used ty, feel free to jump into the comments and let me know what you think.]]></content:encoded></item><item><title>Show HN: Scream to Unlock â€“ Blocks social media until you scream â€œI&apos;m a loserâ€</title><link>https://news.ycombinator.com/item?id=44375761</link><author>madinmo</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 10:49:56 +0000</pubDate><source url="https://news.ycombinator.com/shownew">HN Show</source><content:encoded><![CDATA[Hi all,I kept wasting time on social media, even though Iâ€™d promised myself Iâ€™d stay focused. Regular site blockers didnâ€™t help.I needed something that felt annoying enough to break the habit. Thatâ€™s how the idea came up: make the blocker ask me to say something embarrassing out loud before it lets me back in. If I actually have to yell â€œIâ€™m a loserâ€ into my mic. Even better - the louder I screamed, the more time Iâ€™d get.So I put together Scream to Unlock. Itâ€™s silly, but so far itâ€™s done its job. My social feeds stay locked unless I really want them.]]></content:encoded></item><item><title>Cloud Native Live: One Environment to Rule Them All - How mirrord Eliminates Dev Environment Chaos</title><link>https://www.youtube.com/watch?v=pyY4xfh4ObQ</link><author>CNCF [Cloud Native Computing Foundation]</author><category>dev</category><category>k8s</category><enclosure url="https://www.youtube.com/v/pyY4xfh4ObQ?version=3" length="" type=""/><pubDate>Wed, 25 Jun 2025 05:06:01 +0000</pubDate><source url="https://www.youtube.com/channel/UCvqbFHwN-nwalWPjPUKpvTA">Dev - CNCF</source><content:encoded><![CDATA[Do you really need to spin up dozens of near-prod environments to support your developers?

Spoiler: you don't.

Most teams spin up isolated development environments for each developer which are expensive, hard to maintain, and often not even faithful to production. In this webinar, we'll show you how mirrord lets every developer safely treat your shared staging environment as their own, directly from their local machine. No more sky-high infra bills. No more surprise bugs in prod.

Join us to learn how you can

- Let devs test against staging safely, without affecting each other's work
- Run code locally but have it behave like it was running in your staging environment
- Reduce infra complexity and cost by consolidating environments]]></content:encoded></item><item><title>A new PNG spec</title><link>https://www.programmax.net/articles/png-is-back/</link><author>tbillington</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 03:54:43 +0000</pubDate><source url="https://news.ycombinator.com/best">HN</source><content:encoded><![CDATA[Proper HDR support (futureâ€proof, too!)
								Figure 1 shows the colors our eyes can see.
								The smaller, inner triangle represents the color space of most images.
								The larger, outer triangle represents the colors that are typical with a High Dynamic Range (HDR) image.
							This new HDR support uses only 4 bytes (plus the usual PNG chunk overhead).Finally recognizes APNGs (animations!)Animated PNGs were proposed by Mozilla quite some time ago. Support was added to Firefox, but other programs hesitated to adopt them.Today, animated PNGs are widely supported. It is time for the spec to reflect reality.Officially supports Exif dataExif stores additional information such as copyright information and even camera lens and GPS location of a photograph.General tidying upâ€”fixing errata, clarifications, etc.The last PNG spec was released over 20 years ago. Technology has advanced a lot since then. We're talking 3.5 years before the first iPhone.In fact, technological advancement is what resurrected PNG. The W3C Timed Text Working Group (think:Â subtitles) needed HDR support in PNG. A proposal was made, but a few experts decided we could do better.Momentum built, and additional parties became interested. Before we knew it, we had representation from (in alphabetical order) Adobe, Apple, BBC, Comcast / NBCUniversal, Google, MovieLabs, and of course W3C, who maintains the spec. It's quite the dream team.With these titans behind it, the image format is back with full momentum. Work has already begun on the  PNG spec updates.Many of the programs you use already support the new PNG spec: Chrome, Safari, Firefox, iOS/macOS, Photoshop, DaVinci Resolve, Avid Media Composer...Plus, you saw some broadcast companies in that list above. Behind the scenes, hardware and tooling are being updated to support the new PNG spec. The next time you see a news ticker scrolling  or the score banner update as your team pulls out a clutch play, check if it is HDR.I know you all immediately wondered, . We're already working on that. And parallel encoding/decoding, too! Just like this update, we want to make sure we do it right.We expect the next PNG update (Fourth Edition) to be short. It will improve HDR & Standard Dynamic Range (SDR) interoperability. While we work on that, we'll be researching compression updates for PNG Fifth Edition.]]></content:encoded></item><item><title>Thnickels</title><link>https://thick-coins.net/?_bhlid=8a5736885893b7837e681aa73f890b9805a4673e</link><author>jxmorris12</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 00:13:27 +0000</pubDate><source url="https://news.ycombinator.com/best">HN</source><content:encoded><![CDATA[Hello this is Theodore Nichols and welcome to my world wide web page. I have partnered with someone to help me take pre-orders for thnickels. Slots limited. I have received hundreds of e-Mails from my flyer. I told my grandson that flyers still work in this day and age. He said societal media is the only way, but I was right. And he is still very thin. Thank you all for the interest, I will be in touch.-Theo Thank you for the huge interest in my coins. Yes there are some pre order slots left but going fast.Nickels are too thin we need a much heftier coin. That is why I am making thicker coins in my new minting facility.Some burglars recently entered my garage to pilfer my things. The only weapon nearby was a , which I brandished at the ruffians.The burglars  about the slight bag of coins. They did not  me or .They stole the nickels and my best push broom. I have never felt so humiliated.That's when I resolved to NEVER be disrespected about my pocketchange again.Introducing: Thicker CoinsMy new coins have a  when compared to currency from the U.S. Mint.The enhanced weight is both  to good guys and  to bad guys.You can see in the photograph above how  a regular "nickel" is between my fingers.The "thnickel" is , there is much more coin per coin.Feel free to review my designs below. I welcome feedback on the designs as long as it is positive and respectful of me.I have converted my garage into a mint. I am dedicated to producing enough thnickels for everyone in need of respect.My new state of some art facility is equipped with several tools and a powerful workhorse (me)!Please help spread the word about my coins.Post it in your neighborhood or city to let the people know about thnickels.NUMMOS CRASSIORES OMNIBUSIf you want a thnickel coin or have any questions about my new mint please e-Mail me or call my phone.]]></content:encoded></item><item><title>Microsoft Edit</title><link>https://github.com/microsoft/edit</link><author>ethanpil</author><category>dev</category><category>hn</category><pubDate>Wed, 25 Jun 2025 00:07:04 +0000</pubDate><source url="https://news.ycombinator.com/best">HN</source><content:encoded><![CDATA[]]></content:encoded></item><item><title>Image Compatibility In Cloud Native Environments</title><link>https://kubernetes.io/blog/2025/06/25/image-compatibility-in-cloud-native-environments/</link><author></author><category>dev</category><category>k8s</category><pubDate>Wed, 25 Jun 2025 00:00:00 +0000</pubDate><source url="https://kubernetes.io/">Dev - Kubernetes Blog</source><content:encoded><![CDATA[In industries where systems must run very reliably and meet strict performance criteria such as telecommunication, high-performance or AI computing, containerized applications often need specific operating system configuration or hardware presence.
It is common practice to require the use of specific versions of the kernel, its configuration, device drivers, or system components.
Despite the existence of the Open Container Initiative (OCI), a governing community to define standards and specifications for container images, there has been a gap in expression of such compatibility requirements.
The need to address this issue has led to different proposals and, ultimately, an implementation in Kubernetes' Node Feature Discovery (NFD).NFD is an open source Kubernetes project that automatically detects and reports hardware and system features of cluster nodes. This information helps users to schedule workloads on nodes that meet specific system requirements, which is especially useful for applications with strict hardware or operating system dependencies.Dependencies between containers and host OSA container image is built on a base image, which provides a minimal runtime environment, often a stripped-down Linux userland, completely empty or distroless. When an application requires certain features from the host OS, compatibility issues arise. These dependencies can manifest in several ways::
Host driver versions must match the supported range of a library version inside the container to avoid compatibility problems. Examples include GPUs and network drivers.:
The container must come with a specific version or range of versions for a library or software to run optimally in the environment. Examples from high performance computing are MPI, EFA, or Infiniband.Kernel Modules or Features::
Specific kernel features or modules must be present. Examples include having support of write protected huge page faults, or the presence of VFIOWhile containers in Kubernetes are the most likely unit of abstraction for these needs, the definition of compatibility can extend further to include other container technologies such as Singularity and other OCI artifacts such as binaries from a spack binary cache.Multi-cloud and hybrid cloud challengesContainerized applications are deployed across various Kubernetes distributions and cloud providers, where different host operating systems introduce compatibility challenges.
Often those have to be pre-configured before workload deployment or are immutable.
For instance, different cloud providers will include different operating systems like:Each OS comes with unique kernel versions, configurations, and drivers, making compatibility a non-trivial issue for applications requiring specific features.
It must be possible to quickly assess a container for its suitability to run on any specific environment.An effort was made within the Open Containers Initiative Image Compatibility working group to introduce a standard for image compatibility metadata.
A specification for compatibility would allow container authors to declare required host OS features, making compatibility requirements discoverable and programmable.
The specification implemented in Kubernetes Node Feature Discovery is one of the discussed proposals.
It aims to:Define a structured way to express compatibility in OCI image manifests.Support a compatibility specification alongside container images in image registries.Allow automated validation of compatibility before scheduling containers.The concept has since been implemented in the Kubernetes Node Feature Discovery project.Implementation in Node Feature DiscoveryThe solution integrates compatibility metadata into Kubernetes via NFD features and the NodeFeatureGroup API.
This interface enables the user to match containers to nodes based on exposing features of hardware and software, allowing for intelligent scheduling and workload optimization.The compatibility specification is a structured list of compatibility objects containing .
These objects define image requirements and facilitate validation against host nodes.
The feature requirements are described by using the list of available features from the NFD project.
The schema has the following structure: (string) - Specifies the API version. (array of objects) - List of compatibility sets.
 (int, optional) - Node affinity weight. (string, optional) - Categorization tag. (string, optional) - Short description.An example might look like the following:Client implementation for node validationTo streamline compatibility validation, we implemented a client tool that allows for node validation based on an image's compatibility artifact.
In this workflow, the image author would generate a compatibility artifact that points to the image it describes in a registry via the referrers API.
When a need arises to assess the fit of an image to a host, the tool can discover the artifact and verify compatibility of an image to a node before deployment.
The client can validate nodes both inside and outside a Kubernetes cluster, extending the utility of the tool beyond the single Kubernetes use case.
In the future, image compatibility could play a crucial role in creating specific workload profiles based on image compatibility requirements, aiding in more efficient scheduling.
Additionally, it could potentially enable automatic node configuration to some extent, further optimizing resource allocation and ensuring seamless deployment of specialized workloads.Define image compatibility metadata
A container image can have metadata that describes its requirements based on features discovered from nodes, like kernel modules or CPU models.
The previous compatibility specification example in this article exemplified this use case.Attach the artifact to the image
The image compatibility specification is stored as an OCI artifact.
You can attach this metadata to your container image using the oras tool.
The registry only needs to support OCI artifacts, support for arbitrary types is not required.
Keep in mind that the container image and the artifact must be stored in the same registry.
Use the following command to attach the artifact to the image:Validate image compatibility
After attaching the compatibility specification, you can validate whether a node meets the image's requirements.
This validation can be done using the nfd client:nfd compat validate-node --image <image-url>Read the output from the client
Finally you can read the report generated by the tool or use your own tools to act based on the generated JSON report.The addition of image compatibility to Kubernetes through Node Feature Discovery underscores the growing importance of addressing compatibility in cloud native environments.
It is only a start, as further work is needed to integrate compatibility into scheduling of workloads within and outside of Kubernetes.
However, by integrating this feature into Kubernetes, mission-critical workloads can now define and validate host OS requirements more efficiently.
Moving forward, the adoption of compatibility metadata within Kubernetes ecosystems will significantly enhance the reliability and performance of specialized containerized applications, ensuring they meet the stringent requirements of industries like telecommunications, high-performance computing or any environment that requires special hardware or host OS configuration.Join the Kubernetes Node Feature Discovery project if you're interested in getting involved with the design and development of Image Compatibility API and tools.
We always welcome new contributors.]]></content:encoded></item><item><title>Deaf in Cloud Native: KubeCon + CloudNativeCon EU 2025 Keynote Experience</title><link>https://www.youtube.com/watch?v=NtKrOlTjjhk</link><author>CNCF [Cloud Native Computing Foundation]</author><category>dev</category><category>k8s</category><enclosure url="https://www.youtube.com/v/NtKrOlTjjhk?version=3" length="" type=""/><pubDate>Tue, 24 Jun 2025 22:36:43 +0000</pubDate><source url="https://www.youtube.com/channel/UCvqbFHwN-nwalWPjPUKpvTA">Dev - CNCF</source><content:encoded><![CDATA[Join the Deaf in Cloud Native community as we look back at our wonderful experience at KubeCon + CloudNativeCon Europe 2025 in London. This recap celebrates a landmark moment for our community - the first solo keynote delivered by one of our own, Rob Koch, CNCF DHHWG Co-Chair. In this session, Rob shares the behind-the-scenes story of his presentation, â€œEmpowering Accessibility Through Kubernetes: The Future of Real-Time Sign Language Interpretation.â€ Following Robâ€™s story, community leaders Milad Vafaeifard and Anastasiia Gubska, a CNCF Ambassador, share their key takeaways, leading into a community roundtable where everyone shares their highlights from the conference.]]></content:encoded></item><item><title>Microsoft Releases Classic MS-DOS Editor For Linux</title><link>https://linux.slashdot.org/story/25/06/24/2039231/microsoft-releases-classic-ms-dos-editor-for-linux?utm_source=rss1.0mainlinkanon&amp;utm_medium=feed</link><author>BeauHD</author><category>dev</category><category>slashdot</category><pubDate>Tue, 24 Jun 2025 22:10:00 +0000</pubDate><source url="https://linux.slashdot.org/">Dev - Slashdot - Linux</source><content:encoded><![CDATA[Microsoft has released a modern, open-source version of its classic MS-DOS Editor -- built with Rust and compatible with Windows, macOS, and Linux. It's now simple called "Edit." Ars Technica reports: 
Aside from ease of use, Microsoft's main reason for creating the new version of Edit stems from a peculiar gap in modern Windows. "What motivated us to build Edit was the need for a default CLI text editor in 64-bit versions of Windows," writes [Christopher Nguyen, a product manager on Microsoft's Windows Terminal team] while referring to the command-line interface, or CLI. "32-bit versions of Windows ship with the MS-DOS editor, but 64-bit versions do not have a CLI editor installed inbox." [...]
 
Linux users can download Edit from the project's GitHub releases page or install it through an unofficial snap package. Oh, and if you're a fan of the vintage editor and crave a 16-bit text-mode for your retro machine that actually runs MS-DOS, you can download a copy on the Internet Archive. [...]
 
At 250KB, the new Edit maintains the lightweight philosophy of its predecessor while adding features the original couldn't dream of: Unicode support, regular expressions, and the ability to handle gigabyte-sized files. The original editor was limited to files smaller than 300KB depending on available conventional memory -- a constraint that seems quaint in an era of terabyte storage. But the web publication OMG! Ubuntu found that the modern Edit not only "works great on Ubuntu" but noted its speed when handling gigabyte-sized documents.]]></content:encoded></item><item><title>Fun with uv and PEP 723</title><link>https://www.cottongeeks.com/articles/2025-06-24-fun-with-uv-and-pep-723</link><author>deepakjois</author><category>dev</category><category>hn</category><pubDate>Tue, 24 Jun 2025 18:41:26 +0000</pubDate><source url="https://news.ycombinator.com/best">HN</source><content:encoded><![CDATA[For the longest time, I have been frustrated with Python because I couldnâ€™t use it for one-off scripts. I had to first ensure it was running in an environment where it could find the right Python version and the dependencies installed. That is now a thing of the past.If you are not a Pythonista (or one possibly living under a rock), uv is an extremely fast Python package and project manager, written in Rust.uv also provides this nifty tool called  (kinda like  from the Node/NPM ecosystem for Javascript/Typescript packages) which can be used to invoke a Python tool inside a package.  takes care of creating a (cached) disposable virtual environment, setting up the right Python version and installing all the dependencies before running.PEP 723 is a Python Enhancement Proposal that specifies a metadata format that can be embedded in single-file Python scripts to assist launchers, IDEs and other external tools which may need to interact with such scripts.Here is the example directly lifted from the proposal:Combining uv and the PEP-723 metadata inside a Python script, we can run the script in the previous section as follows:We can combine things we covered in the previous sections to create a simple executable script that can extract YouTube transcripts.First we create a Python script with a shebang and inline metadata.Note the shebang line: #!/usr/bin/env -S uv run --script. It is important to specify  with the  flag when used on the shebang line.We save this script as  and then make it executable with .We can now run the script like:This opens up a lot of possibilities for running Python code more seamlessly. Before this I used to prefer Go for one-off scripts because it was easy to create a self-contained binary executable. But now that I could use uv, I coded up a quick MCP server in Python for extracting YouTube transcripts. Check it out on Github at cottongeeks/ytt-mcp.]]></content:encoded></item></channel></rss>