<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Recent Discussions</title><link>https://planet.crystal-lang.org/</link><description></description><item><title>Memory usage of HTTP one-shot vs maintaining a persistent connection</title><link>https://forum.crystal-lang.org/t/memory-usage-of-http-one-shot-vs-maintaining-a-persistent-connection/8237</link><author>jgaskins</author><category>community</category><pubDate>Tue, 15 Jul 2025 19:58:05 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I deployed a Mastodon bot a couple weeks ago that polls a US National Weather Service RSS feed for an airport in my county and posts to Mastodon when it updates. I was using the  “one-shot” methods that spin up an HTTP connection, send the request, then terminate the connection.I expected this bot to use very little RAM (less than 10MB) because it’s  very little:Makes an HTTP request to get the RSS feedIterates over each feed item (there’s only one)If it hasn’t been posted yet (tracked by a key in Redis or a record in SQLite), make an HTTP request to the Mastodon APIWhat surprised me was that RAM consumption grew over time.The first two lines show linear memory growth. I restarted the app and it happened again. Then I tried a few more experiments:Replace SQLite with RedisReplace the RSS feed parser with using stdlib  directlyRemove all XML parsing and just use regexes (yes, I know, don’t worry about it)Compile the app using  for the specific aarch64 CPUs I’m using on GCPCap memory usage to 20MB so it’ll just restart when it exceeds itUse a persistent HTTP connectionThe first 4 didn’t do anything useful. Capping memory usage actually caused an additional problem — it caused the app to crash  persisting that it was posting to Mastodon but  actually posting.The punchline is in the image above, but after almost 24 hours using a persistent HTTP connection (with a connection pool) for both the RSS feed and the Mastodon API, memory usage has tapered at about 5MB. This is the only thing that kept RAM stable at single-digit MB.That makes me wonder if there’s something in OpenSSL (either in the version of OpenSSL itself that’s included in the 84codes Alpine-based container images or in the Crystal bindings for it) that’s causing it to leak memory. I’ve only ever seen this kind of memory growth in Ktistec, which is why I thought it might be something in SQLite but it happening when running one-shot HTTP requests would also track.Regardless of the reason, if you want to minimize memory consumption in an app that talks to other HTTP services, reusing HTTP connections will do that.]]></content:encoded></item><item><title>OpenSSL::Digest store and resume</title><link>https://forum.crystal-lang.org/t/openssl-digest-store-and-resume/8236</link><author>dup2</author><category>community</category><pubDate>Tue, 15 Jul 2025 16:41:52 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I’m trying to implement a “resumable” SHA256 digest which can be persisted and later resumed when new data arrives, the use case is a distributed uploader where the data arrives in chunks.For this, I’m trying to store a LibCrypto::EVP_MD_CTX_Struct somewhere (disk, redis) and then later resuming with a new Digest::SHA256 instance (or an extension of it as the initializer with a ctx is protected).Any pointers for this? Is this even possible? (I failed so far..)]]></content:encoded></item><item><title>Bind macro for use in web dev</title><link>https://forum.crystal-lang.org/t/bind-macro-for-use-in-web-dev/8229</link><author>u89012</author><category>community</category><pubDate>Mon, 14 Jul 2025 11:47:57 +0000</pubDate><source url="https://forum.crystal-lang.org/latest">Forum</source><content:encoded><![CDATA[I’ve the following macros (which works fine) which I’d like to enhance so it can be used to bind to form args as well – I’ve tried a bunch of variations but can’t seem to get it right, LLMs haven’t been helpful either (as they seem to produce code that iterates over the  which refuses to compile), can someone please help?macro bind(type)
  {{type}}.from_json(context.request.body.not_nil!)
end

macro bind(**args)
  NamedTuple({{args.double_splat}}).from_json(context.request.body.not_nil!)
end
Which can be used like so:alias User = NamedTuple(email: String, password: String, remember_me: Bool?)
#...
payload = bind(User) #works fine for predefined types

# using the second version with **args
payload = bind(email: String, password: String, remember_me: Bool?) #works fine for one off captures too
Assuming  exists (which merges ,  and ) how would one go about extending the above two macros so it handles both JSON and form params? I understand binding to form params can be tricky for nested structures but I’m hoping to get to a bare minimum version that can be useful.]]></content:encoded></item></channel></rss>